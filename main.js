/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self = debug2;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self, args);
          const logFn = self.log || createDebug.log;
          logFn.apply(self, args);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug.useColors();
        debug2.color = createDebug.selectColor(namespace);
        debug2.extend = extend;
        debug2.destroy = createDebug.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug2);
        }
        return debug2;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module2) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/debug/src/node.js"(exports, module2) {
    var tty = require("tty");
    var util = require("util");
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug2) {
      debug2.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug2.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common()(exports);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/@kwsites/file-exists/dist/src/index.js
var require_src2 = __commonJS({
  "node_modules/@kwsites/file-exists/dist/src/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var fs_1 = require("fs");
    var debug_1 = __importDefault(require_src());
    var log = debug_1.default("@kwsites/file-exists");
    function check(path, isFile, isDirectory) {
      log(`checking %s`, path);
      try {
        const stat = fs_1.statSync(path);
        if (stat.isFile() && isFile) {
          log(`[OK] path represents a file`);
          return true;
        }
        if (stat.isDirectory() && isDirectory) {
          log(`[OK] path represents a directory`);
          return true;
        }
        log(`[FAIL] path represents something other than a file or directory`);
        return false;
      } catch (e) {
        if (e.code === "ENOENT") {
          log(`[FAIL] path is not accessible: %o`, e);
          return false;
        }
        log(`[FATAL] %o`, e);
        throw e;
      }
    }
    function exists2(path, type = exports.READABLE) {
      return check(path, (type & exports.FILE) > 0, (type & exports.FOLDER) > 0);
    }
    exports.exists = exists2;
    exports.FILE = 1;
    exports.FOLDER = 2;
    exports.READABLE = exports.FILE + exports.FOLDER;
  }
});

// node_modules/@kwsites/file-exists/dist/index.js
var require_dist = __commonJS({
  "node_modules/@kwsites/file-exists/dist/index.js"(exports) {
    "use strict";
    function __export3(m) {
      for (var p in m)
        if (!exports.hasOwnProperty(p))
          exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export3(require_src2());
  }
});

// node_modules/@kwsites/promise-deferred/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@kwsites/promise-deferred/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDeferred = exports.deferred = void 0;
    function deferred2() {
      let done;
      let fail;
      let status = "pending";
      const promise = new Promise((_done, _fail) => {
        done = _done;
        fail = _fail;
      });
      return {
        promise,
        done(result) {
          if (status === "pending") {
            status = "resolved";
            done(result);
          }
        },
        fail(error) {
          if (status === "pending") {
            status = "rejected";
            fail(error);
          }
        },
        get fulfilled() {
          return status !== "pending";
        },
        get status() {
          return status;
        }
      };
    }
    exports.deferred = deferred2;
    exports.createDeferred = deferred2;
    exports.default = deferred2;
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => GitSyncPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// node_modules/simple-git/dist/esm/index.js
var import_file_exists = __toESM(require_dist(), 1);
var import_debug = __toESM(require_src(), 1);
var import_child_process = require("child_process");
var import_promise_deferred = __toESM(require_dist2(), 1);
var import_promise_deferred2 = __toESM(require_dist2(), 1);
var import_node_events = require("node:events");
var __defProp2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp2.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames2(fn)[0]])(fn = 0)), res;
};
var __commonJS2 = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export2 = (target, all) => {
  for (var name in all)
    __defProp2(target, name, { get: all[name], enumerable: true });
};
var __copyProps2 = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames2(from))
      if (!__hasOwnProp2.call(to, key) && key !== except)
        __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function pathspec(...paths) {
  const key = new String(paths);
  cache.set(key, paths);
  return key;
}
function isPathSpec(path) {
  return path instanceof String && cache.has(path);
}
function toPaths(pathSpec) {
  return cache.get(pathSpec) || [];
}
var cache;
var init_pathspec = __esm({
  "src/lib/args/pathspec.ts"() {
    "use strict";
    cache = /* @__PURE__ */ new WeakMap();
  }
});
var GitError;
var init_git_error = __esm({
  "src/lib/errors/git-error.ts"() {
    "use strict";
    GitError = class extends Error {
      constructor(task, message) {
        super(message);
        this.task = task;
        Object.setPrototypeOf(this, new.target.prototype);
      }
    };
  }
});
var GitResponseError;
var init_git_response_error = __esm({
  "src/lib/errors/git-response-error.ts"() {
    "use strict";
    init_git_error();
    GitResponseError = class extends GitError {
      constructor(git, message) {
        super(void 0, message || String(git));
        this.git = git;
      }
    };
  }
});
var TaskConfigurationError;
var init_task_configuration_error = __esm({
  "src/lib/errors/task-configuration-error.ts"() {
    "use strict";
    init_git_error();
    TaskConfigurationError = class extends GitError {
      constructor(message) {
        super(void 0, message);
      }
    };
  }
});
function asFunction(source) {
  return typeof source === "function" ? source : NOOP;
}
function isUserFunction(source) {
  return typeof source === "function" && source !== NOOP;
}
function splitOn(input, char) {
  const index = input.indexOf(char);
  if (index <= 0) {
    return [input, ""];
  }
  return [input.substr(0, index), input.substr(index + 1)];
}
function first(input, offset = 0) {
  return isArrayLike(input) && input.length > offset ? input[offset] : void 0;
}
function last(input, offset = 0) {
  if (isArrayLike(input) && input.length > offset) {
    return input[input.length - 1 - offset];
  }
}
function isArrayLike(input) {
  return !!(input && typeof input.length === "number");
}
function toLinesWithContent(input = "", trimmed2 = true, separator = "\n") {
  return input.split(separator).reduce((output, line) => {
    const lineContent = trimmed2 ? line.trim() : line;
    if (lineContent) {
      output.push(lineContent);
    }
    return output;
  }, []);
}
function forEachLineWithContent(input, callback) {
  return toLinesWithContent(input, true).map((line) => callback(line));
}
function folderExists(path) {
  return (0, import_file_exists.exists)(path, import_file_exists.FOLDER);
}
function append(target, item) {
  if (Array.isArray(target)) {
    if (!target.includes(item)) {
      target.push(item);
    }
  } else {
    target.add(item);
  }
  return item;
}
function including(target, item) {
  if (Array.isArray(target) && !target.includes(item)) {
    target.push(item);
  }
  return target;
}
function remove(target, item) {
  if (Array.isArray(target)) {
    const index = target.indexOf(item);
    if (index >= 0) {
      target.splice(index, 1);
    }
  } else {
    target.delete(item);
  }
  return item;
}
function asArray(source) {
  return Array.isArray(source) ? source : [source];
}
function asCamelCase(str) {
  return str.replace(/[\s-]+(.)/g, (_all, chr) => {
    return chr.toUpperCase();
  });
}
function asStringArray(source) {
  return asArray(source).map(String);
}
function asNumber(source, onNaN = 0) {
  if (source == null) {
    return onNaN;
  }
  const num = parseInt(source, 10);
  return isNaN(num) ? onNaN : num;
}
function prefixedArray(input, prefix) {
  const output = [];
  for (let i = 0, max = input.length; i < max; i++) {
    output.push(prefix, input[i]);
  }
  return output;
}
function bufferToString(input) {
  return (Array.isArray(input) ? Buffer.concat(input) : input).toString("utf-8");
}
function pick(source, properties) {
  return Object.assign(
    {},
    ...properties.map((property) => property in source ? { [property]: source[property] } : {})
  );
}
function delay(duration = 0) {
  return new Promise((done) => setTimeout(done, duration));
}
function orVoid(input) {
  if (input === false) {
    return void 0;
  }
  return input;
}
var NULL;
var NOOP;
var objectToString;
var init_util = __esm({
  "src/lib/utils/util.ts"() {
    "use strict";
    NULL = "\0";
    NOOP = () => {
    };
    objectToString = Object.prototype.toString.call.bind(Object.prototype.toString);
  }
});
function filterType(input, filter, def) {
  if (filter(input)) {
    return input;
  }
  return arguments.length > 2 ? def : void 0;
}
function filterPrimitives(input, omit) {
  const type = isPathSpec(input) ? "string" : typeof input;
  return /number|string|boolean/.test(type) && (!omit || !omit.includes(type));
}
function filterPlainObject(input) {
  return !!input && objectToString(input) === "[object Object]";
}
function filterFunction(input) {
  return typeof input === "function";
}
var filterArray;
var filterString;
var filterStringArray;
var filterStringOrStringArray;
var filterHasLength;
var init_argument_filters = __esm({
  "src/lib/utils/argument-filters.ts"() {
    "use strict";
    init_util();
    init_pathspec();
    filterArray = (input) => {
      return Array.isArray(input);
    };
    filterString = (input) => {
      return typeof input === "string";
    };
    filterStringArray = (input) => {
      return Array.isArray(input) && input.every(filterString);
    };
    filterStringOrStringArray = (input) => {
      return filterString(input) || Array.isArray(input) && input.every(filterString);
    };
    filterHasLength = (input) => {
      if (input == null || "number|boolean|function".includes(typeof input)) {
        return false;
      }
      return Array.isArray(input) || typeof input === "string" || typeof input.length === "number";
    };
  }
});
var ExitCodes;
var init_exit_codes = __esm({
  "src/lib/utils/exit-codes.ts"() {
    "use strict";
    ExitCodes = /* @__PURE__ */ ((ExitCodes2) => {
      ExitCodes2[ExitCodes2["SUCCESS"] = 0] = "SUCCESS";
      ExitCodes2[ExitCodes2["ERROR"] = 1] = "ERROR";
      ExitCodes2[ExitCodes2["NOT_FOUND"] = -2] = "NOT_FOUND";
      ExitCodes2[ExitCodes2["UNCLEAN"] = 128] = "UNCLEAN";
      return ExitCodes2;
    })(ExitCodes || {});
  }
});
var GitOutputStreams;
var init_git_output_streams = __esm({
  "src/lib/utils/git-output-streams.ts"() {
    "use strict";
    GitOutputStreams = class {
      constructor(stdOut, stdErr) {
        this.stdOut = stdOut;
        this.stdErr = stdErr;
      }
      asStrings() {
        return new GitOutputStreams(this.stdOut.toString("utf8"), this.stdErr.toString("utf8"));
      }
    };
  }
});
var LineParser;
var RemoteLineParser;
var init_line_parser = __esm({
  "src/lib/utils/line-parser.ts"() {
    "use strict";
    LineParser = class {
      constructor(regExp, useMatches) {
        this.matches = [];
        this.parse = (line, target) => {
          this.resetMatches();
          if (!this._regExp.every((reg, index) => this.addMatch(reg, index, line(index)))) {
            return false;
          }
          return this.useMatches(target, this.prepareMatches()) !== false;
        };
        this._regExp = Array.isArray(regExp) ? regExp : [regExp];
        if (useMatches) {
          this.useMatches = useMatches;
        }
      }
      useMatches(target, match) {
        throw new Error(`LineParser:useMatches not implemented`);
      }
      resetMatches() {
        this.matches.length = 0;
      }
      prepareMatches() {
        return this.matches;
      }
      addMatch(reg, index, line) {
        const matched = line && reg.exec(line);
        if (matched) {
          this.pushMatch(index, matched);
        }
        return !!matched;
      }
      pushMatch(_index, matched) {
        this.matches.push(...matched.slice(1));
      }
    };
    RemoteLineParser = class extends LineParser {
      addMatch(reg, index, line) {
        return /^remote:\s/.test(String(line)) && super.addMatch(reg, index, line);
      }
      pushMatch(index, matched) {
        if (index > 0 || matched.length > 1) {
          super.pushMatch(index, matched);
        }
      }
    };
  }
});
function createInstanceConfig(...options) {
  const baseDir = process.cwd();
  const config = Object.assign(
    __spreadValues({ baseDir }, defaultOptions),
    ...options.filter((o) => typeof o === "object" && o)
  );
  config.baseDir = config.baseDir || baseDir;
  config.trimmed = config.trimmed === true;
  return config;
}
var defaultOptions;
var init_simple_git_options = __esm({
  "src/lib/utils/simple-git-options.ts"() {
    "use strict";
    defaultOptions = {
      binary: "git",
      maxConcurrentProcesses: 5,
      config: [],
      trimmed: false
    };
  }
});
function appendTaskOptions(options, commands = []) {
  if (!filterPlainObject(options)) {
    return commands;
  }
  return Object.keys(options).reduce((commands2, key) => {
    const value = options[key];
    if (isPathSpec(value)) {
      commands2.push(value);
    } else if (filterPrimitives(value, ["boolean"])) {
      commands2.push(key + "=" + value);
    } else {
      commands2.push(key);
    }
    return commands2;
  }, commands);
}
function getTrailingOptions(args, initialPrimitive = 0, objectOnly = false) {
  const command = [];
  for (let i = 0, max = initialPrimitive < 0 ? args.length : initialPrimitive; i < max; i++) {
    if ("string|number".includes(typeof args[i])) {
      command.push(String(args[i]));
    }
  }
  appendTaskOptions(trailingOptionsArgument(args), command);
  if (!objectOnly) {
    command.push(...trailingArrayArgument(args));
  }
  return command;
}
function trailingArrayArgument(args) {
  const hasTrailingCallback = typeof last(args) === "function";
  return filterType(last(args, hasTrailingCallback ? 1 : 0), filterArray, []);
}
function trailingOptionsArgument(args) {
  const hasTrailingCallback = filterFunction(last(args));
  return filterType(last(args, hasTrailingCallback ? 1 : 0), filterPlainObject);
}
function trailingFunctionArgument(args, includeNoop = true) {
  const callback = asFunction(last(args));
  return includeNoop || isUserFunction(callback) ? callback : void 0;
}
var init_task_options = __esm({
  "src/lib/utils/task-options.ts"() {
    "use strict";
    init_argument_filters();
    init_util();
    init_pathspec();
  }
});
function callTaskParser(parser4, streams) {
  return parser4(streams.stdOut, streams.stdErr);
}
function parseStringResponse(result, parsers12, texts, trim = true) {
  asArray(texts).forEach((text) => {
    for (let lines = toLinesWithContent(text, trim), i = 0, max = lines.length; i < max; i++) {
      const line = (offset = 0) => {
        if (i + offset >= max) {
          return;
        }
        return lines[i + offset];
      };
      parsers12.some(({ parse }) => parse(line, result));
    }
  });
  return result;
}
var init_task_parser = __esm({
  "src/lib/utils/task-parser.ts"() {
    "use strict";
    init_util();
  }
});
var utils_exports = {};
__export2(utils_exports, {
  ExitCodes: () => ExitCodes,
  GitOutputStreams: () => GitOutputStreams,
  LineParser: () => LineParser,
  NOOP: () => NOOP,
  NULL: () => NULL,
  RemoteLineParser: () => RemoteLineParser,
  append: () => append,
  appendTaskOptions: () => appendTaskOptions,
  asArray: () => asArray,
  asCamelCase: () => asCamelCase,
  asFunction: () => asFunction,
  asNumber: () => asNumber,
  asStringArray: () => asStringArray,
  bufferToString: () => bufferToString,
  callTaskParser: () => callTaskParser,
  createInstanceConfig: () => createInstanceConfig,
  delay: () => delay,
  filterArray: () => filterArray,
  filterFunction: () => filterFunction,
  filterHasLength: () => filterHasLength,
  filterPlainObject: () => filterPlainObject,
  filterPrimitives: () => filterPrimitives,
  filterString: () => filterString,
  filterStringArray: () => filterStringArray,
  filterStringOrStringArray: () => filterStringOrStringArray,
  filterType: () => filterType,
  first: () => first,
  folderExists: () => folderExists,
  forEachLineWithContent: () => forEachLineWithContent,
  getTrailingOptions: () => getTrailingOptions,
  including: () => including,
  isUserFunction: () => isUserFunction,
  last: () => last,
  objectToString: () => objectToString,
  orVoid: () => orVoid,
  parseStringResponse: () => parseStringResponse,
  pick: () => pick,
  prefixedArray: () => prefixedArray,
  remove: () => remove,
  splitOn: () => splitOn,
  toLinesWithContent: () => toLinesWithContent,
  trailingFunctionArgument: () => trailingFunctionArgument,
  trailingOptionsArgument: () => trailingOptionsArgument
});
var init_utils = __esm({
  "src/lib/utils/index.ts"() {
    "use strict";
    init_argument_filters();
    init_exit_codes();
    init_git_output_streams();
    init_line_parser();
    init_simple_git_options();
    init_task_options();
    init_task_parser();
    init_util();
  }
});
var check_is_repo_exports = {};
__export2(check_is_repo_exports, {
  CheckRepoActions: () => CheckRepoActions,
  checkIsBareRepoTask: () => checkIsBareRepoTask,
  checkIsRepoRootTask: () => checkIsRepoRootTask,
  checkIsRepoTask: () => checkIsRepoTask
});
function checkIsRepoTask(action) {
  switch (action) {
    case "bare":
      return checkIsBareRepoTask();
    case "root":
      return checkIsRepoRootTask();
  }
  const commands = ["rev-parse", "--is-inside-work-tree"];
  return {
    commands,
    format: "utf-8",
    onError,
    parser
  };
}
function checkIsRepoRootTask() {
  const commands = ["rev-parse", "--git-dir"];
  return {
    commands,
    format: "utf-8",
    onError,
    parser(path) {
      return /^\.(git)?$/.test(path.trim());
    }
  };
}
function checkIsBareRepoTask() {
  const commands = ["rev-parse", "--is-bare-repository"];
  return {
    commands,
    format: "utf-8",
    onError,
    parser
  };
}
function isNotRepoMessage(error) {
  return /(Not a git repository|Kein Git-Repository)/i.test(String(error));
}
var CheckRepoActions;
var onError;
var parser;
var init_check_is_repo = __esm({
  "src/lib/tasks/check-is-repo.ts"() {
    "use strict";
    init_utils();
    CheckRepoActions = /* @__PURE__ */ ((CheckRepoActions2) => {
      CheckRepoActions2["BARE"] = "bare";
      CheckRepoActions2["IN_TREE"] = "tree";
      CheckRepoActions2["IS_REPO_ROOT"] = "root";
      return CheckRepoActions2;
    })(CheckRepoActions || {});
    onError = ({ exitCode }, error, done, fail) => {
      if (exitCode === 128 && isNotRepoMessage(error)) {
        return done(Buffer.from("false"));
      }
      fail(error);
    };
    parser = (text) => {
      return text.trim() === "true";
    };
  }
});
function cleanSummaryParser(dryRun, text) {
  const summary = new CleanResponse(dryRun);
  const regexp = dryRun ? dryRunRemovalRegexp : removalRegexp;
  toLinesWithContent(text).forEach((line) => {
    const removed = line.replace(regexp, "");
    summary.paths.push(removed);
    (isFolderRegexp.test(removed) ? summary.folders : summary.files).push(removed);
  });
  return summary;
}
var CleanResponse;
var removalRegexp;
var dryRunRemovalRegexp;
var isFolderRegexp;
var init_CleanSummary = __esm({
  "src/lib/responses/CleanSummary.ts"() {
    "use strict";
    init_utils();
    CleanResponse = class {
      constructor(dryRun) {
        this.dryRun = dryRun;
        this.paths = [];
        this.files = [];
        this.folders = [];
      }
    };
    removalRegexp = /^[a-z]+\s*/i;
    dryRunRemovalRegexp = /^[a-z]+\s+[a-z]+\s*/i;
    isFolderRegexp = /\/$/;
  }
});
var task_exports = {};
__export2(task_exports, {
  EMPTY_COMMANDS: () => EMPTY_COMMANDS,
  adhocExecTask: () => adhocExecTask,
  configurationErrorTask: () => configurationErrorTask,
  isBufferTask: () => isBufferTask,
  isEmptyTask: () => isEmptyTask,
  straightThroughBufferTask: () => straightThroughBufferTask,
  straightThroughStringTask: () => straightThroughStringTask
});
function adhocExecTask(parser4) {
  return {
    commands: EMPTY_COMMANDS,
    format: "empty",
    parser: parser4
  };
}
function configurationErrorTask(error) {
  return {
    commands: EMPTY_COMMANDS,
    format: "empty",
    parser() {
      throw typeof error === "string" ? new TaskConfigurationError(error) : error;
    }
  };
}
function straightThroughStringTask(commands, trimmed2 = false) {
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return trimmed2 ? String(text).trim() : text;
    }
  };
}
function straightThroughBufferTask(commands) {
  return {
    commands,
    format: "buffer",
    parser(buffer) {
      return buffer;
    }
  };
}
function isBufferTask(task) {
  return task.format === "buffer";
}
function isEmptyTask(task) {
  return task.format === "empty" || !task.commands.length;
}
var EMPTY_COMMANDS;
var init_task = __esm({
  "src/lib/tasks/task.ts"() {
    "use strict";
    init_task_configuration_error();
    EMPTY_COMMANDS = [];
  }
});
var clean_exports = {};
__export2(clean_exports, {
  CONFIG_ERROR_INTERACTIVE_MODE: () => CONFIG_ERROR_INTERACTIVE_MODE,
  CONFIG_ERROR_MODE_REQUIRED: () => CONFIG_ERROR_MODE_REQUIRED,
  CONFIG_ERROR_UNKNOWN_OPTION: () => CONFIG_ERROR_UNKNOWN_OPTION,
  CleanOptions: () => CleanOptions,
  cleanTask: () => cleanTask,
  cleanWithOptionsTask: () => cleanWithOptionsTask,
  isCleanOptionsArray: () => isCleanOptionsArray
});
function cleanWithOptionsTask(mode, customArgs) {
  const { cleanMode, options, valid } = getCleanOptions(mode);
  if (!cleanMode) {
    return configurationErrorTask(CONFIG_ERROR_MODE_REQUIRED);
  }
  if (!valid.options) {
    return configurationErrorTask(CONFIG_ERROR_UNKNOWN_OPTION + JSON.stringify(mode));
  }
  options.push(...customArgs);
  if (options.some(isInteractiveMode)) {
    return configurationErrorTask(CONFIG_ERROR_INTERACTIVE_MODE);
  }
  return cleanTask(cleanMode, options);
}
function cleanTask(mode, customArgs) {
  const commands = ["clean", `-${mode}`, ...customArgs];
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return cleanSummaryParser(mode === "n", text);
    }
  };
}
function isCleanOptionsArray(input) {
  return Array.isArray(input) && input.every((test) => CleanOptionValues.has(test));
}
function getCleanOptions(input) {
  let cleanMode;
  let options = [];
  let valid = { cleanMode: false, options: true };
  input.replace(/[^a-z]i/g, "").split("").forEach((char) => {
    if (isCleanMode(char)) {
      cleanMode = char;
      valid.cleanMode = true;
    } else {
      valid.options = valid.options && isKnownOption(options[options.length] = `-${char}`);
    }
  });
  return {
    cleanMode,
    options,
    valid
  };
}
function isCleanMode(cleanMode) {
  return cleanMode === "f" || cleanMode === "n";
}
function isKnownOption(option) {
  return /^-[a-z]$/i.test(option) && CleanOptionValues.has(option.charAt(1));
}
function isInteractiveMode(option) {
  if (/^-[^\-]/.test(option)) {
    return option.indexOf("i") > 0;
  }
  return option === "--interactive";
}
var CONFIG_ERROR_INTERACTIVE_MODE;
var CONFIG_ERROR_MODE_REQUIRED;
var CONFIG_ERROR_UNKNOWN_OPTION;
var CleanOptions;
var CleanOptionValues;
var init_clean = __esm({
  "src/lib/tasks/clean.ts"() {
    "use strict";
    init_CleanSummary();
    init_utils();
    init_task();
    CONFIG_ERROR_INTERACTIVE_MODE = "Git clean interactive mode is not supported";
    CONFIG_ERROR_MODE_REQUIRED = 'Git clean mode parameter ("n" or "f") is required';
    CONFIG_ERROR_UNKNOWN_OPTION = "Git clean unknown option found in: ";
    CleanOptions = /* @__PURE__ */ ((CleanOptions2) => {
      CleanOptions2["DRY_RUN"] = "n";
      CleanOptions2["FORCE"] = "f";
      CleanOptions2["IGNORED_INCLUDED"] = "x";
      CleanOptions2["IGNORED_ONLY"] = "X";
      CleanOptions2["EXCLUDING"] = "e";
      CleanOptions2["QUIET"] = "q";
      CleanOptions2["RECURSIVE"] = "d";
      return CleanOptions2;
    })(CleanOptions || {});
    CleanOptionValues = /* @__PURE__ */ new Set([
      "i",
      ...asStringArray(Object.values(CleanOptions))
    ]);
  }
});
function configListParser(text) {
  const config = new ConfigList();
  for (const item of configParser(text)) {
    config.addValue(item.file, String(item.key), item.value);
  }
  return config;
}
function configGetParser(text, key) {
  let value = null;
  const values = [];
  const scopes = /* @__PURE__ */ new Map();
  for (const item of configParser(text, key)) {
    if (item.key !== key) {
      continue;
    }
    values.push(value = item.value);
    if (!scopes.has(item.file)) {
      scopes.set(item.file, []);
    }
    scopes.get(item.file).push(value);
  }
  return {
    key,
    paths: Array.from(scopes.keys()),
    scopes,
    value,
    values
  };
}
function configFilePath(filePath) {
  return filePath.replace(/^(file):/, "");
}
function* configParser(text, requestedKey = null) {
  const lines = text.split("\0");
  for (let i = 0, max = lines.length - 1; i < max; ) {
    const file = configFilePath(lines[i++]);
    let value = lines[i++];
    let key = requestedKey;
    if (value.includes("\n")) {
      const line = splitOn(value, "\n");
      key = line[0];
      value = line[1];
    }
    yield { file, key, value };
  }
}
var ConfigList;
var init_ConfigList = __esm({
  "src/lib/responses/ConfigList.ts"() {
    "use strict";
    init_utils();
    ConfigList = class {
      constructor() {
        this.files = [];
        this.values = /* @__PURE__ */ Object.create(null);
      }
      get all() {
        if (!this._all) {
          this._all = this.files.reduce((all, file) => {
            return Object.assign(all, this.values[file]);
          }, {});
        }
        return this._all;
      }
      addFile(file) {
        if (!(file in this.values)) {
          const latest = last(this.files);
          this.values[file] = latest ? Object.create(this.values[latest]) : {};
          this.files.push(file);
        }
        return this.values[file];
      }
      addValue(file, key, value) {
        const values = this.addFile(file);
        if (!values.hasOwnProperty(key)) {
          values[key] = value;
        } else if (Array.isArray(values[key])) {
          values[key].push(value);
        } else {
          values[key] = [values[key], value];
        }
        this._all = void 0;
      }
    };
  }
});
function asConfigScope(scope, fallback) {
  if (typeof scope === "string" && GitConfigScope.hasOwnProperty(scope)) {
    return scope;
  }
  return fallback;
}
function addConfigTask(key, value, append2, scope) {
  const commands = ["config", `--${scope}`];
  if (append2) {
    commands.push("--add");
  }
  commands.push(key, value);
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return text;
    }
  };
}
function getConfigTask(key, scope) {
  const commands = ["config", "--null", "--show-origin", "--get-all", key];
  if (scope) {
    commands.splice(1, 0, `--${scope}`);
  }
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return configGetParser(text, key);
    }
  };
}
function listConfigTask(scope) {
  const commands = ["config", "--list", "--show-origin", "--null"];
  if (scope) {
    commands.push(`--${scope}`);
  }
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return configListParser(text);
    }
  };
}
function config_default() {
  return {
    addConfig(key, value, ...rest) {
      return this._runTask(
        addConfigTask(
          key,
          value,
          rest[0] === true,
          asConfigScope(
            rest[1],
            "local"
            /* local */
          )
        ),
        trailingFunctionArgument(arguments)
      );
    },
    getConfig(key, scope) {
      return this._runTask(
        getConfigTask(key, asConfigScope(scope, void 0)),
        trailingFunctionArgument(arguments)
      );
    },
    listConfig(...rest) {
      return this._runTask(
        listConfigTask(asConfigScope(rest[0], void 0)),
        trailingFunctionArgument(arguments)
      );
    }
  };
}
var GitConfigScope;
var init_config = __esm({
  "src/lib/tasks/config.ts"() {
    "use strict";
    init_ConfigList();
    init_utils();
    GitConfigScope = /* @__PURE__ */ ((GitConfigScope2) => {
      GitConfigScope2["system"] = "system";
      GitConfigScope2["global"] = "global";
      GitConfigScope2["local"] = "local";
      GitConfigScope2["worktree"] = "worktree";
      return GitConfigScope2;
    })(GitConfigScope || {});
  }
});
function isDiffNameStatus(input) {
  return diffNameStatus.has(input);
}
var DiffNameStatus;
var diffNameStatus;
var init_diff_name_status = __esm({
  "src/lib/tasks/diff-name-status.ts"() {
    "use strict";
    DiffNameStatus = /* @__PURE__ */ ((DiffNameStatus2) => {
      DiffNameStatus2["ADDED"] = "A";
      DiffNameStatus2["COPIED"] = "C";
      DiffNameStatus2["DELETED"] = "D";
      DiffNameStatus2["MODIFIED"] = "M";
      DiffNameStatus2["RENAMED"] = "R";
      DiffNameStatus2["CHANGED"] = "T";
      DiffNameStatus2["UNMERGED"] = "U";
      DiffNameStatus2["UNKNOWN"] = "X";
      DiffNameStatus2["BROKEN"] = "B";
      return DiffNameStatus2;
    })(DiffNameStatus || {});
    diffNameStatus = new Set(Object.values(DiffNameStatus));
  }
});
function grepQueryBuilder(...params) {
  return new GrepQuery().param(...params);
}
function parseGrep(grep) {
  const paths = /* @__PURE__ */ new Set();
  const results = {};
  forEachLineWithContent(grep, (input) => {
    const [path, line, preview] = input.split(NULL);
    paths.add(path);
    (results[path] = results[path] || []).push({
      line: asNumber(line),
      path,
      preview
    });
  });
  return {
    paths,
    results
  };
}
function grep_default() {
  return {
    grep(searchTerm) {
      const then = trailingFunctionArgument(arguments);
      const options = getTrailingOptions(arguments);
      for (const option of disallowedOptions) {
        if (options.includes(option)) {
          return this._runTask(
            configurationErrorTask(`git.grep: use of "${option}" is not supported.`),
            then
          );
        }
      }
      if (typeof searchTerm === "string") {
        searchTerm = grepQueryBuilder().param(searchTerm);
      }
      const commands = ["grep", "--null", "-n", "--full-name", ...options, ...searchTerm];
      return this._runTask(
        {
          commands,
          format: "utf-8",
          parser(stdOut) {
            return parseGrep(stdOut);
          }
        },
        then
      );
    }
  };
}
var disallowedOptions;
var Query;
var _a;
var GrepQuery;
var init_grep = __esm({
  "src/lib/tasks/grep.ts"() {
    "use strict";
    init_utils();
    init_task();
    disallowedOptions = ["-h"];
    Query = Symbol("grepQuery");
    GrepQuery = class {
      constructor() {
        this[_a] = [];
      }
      *[(_a = Query, Symbol.iterator)]() {
        for (const query of this[Query]) {
          yield query;
        }
      }
      and(...and) {
        and.length && this[Query].push("--and", "(", ...prefixedArray(and, "-e"), ")");
        return this;
      }
      param(...param) {
        this[Query].push(...prefixedArray(param, "-e"));
        return this;
      }
    };
  }
});
var reset_exports = {};
__export2(reset_exports, {
  ResetMode: () => ResetMode,
  getResetMode: () => getResetMode,
  resetTask: () => resetTask
});
function resetTask(mode, customArgs) {
  const commands = ["reset"];
  if (isValidResetMode(mode)) {
    commands.push(`--${mode}`);
  }
  commands.push(...customArgs);
  return straightThroughStringTask(commands);
}
function getResetMode(mode) {
  if (isValidResetMode(mode)) {
    return mode;
  }
  switch (typeof mode) {
    case "string":
    case "undefined":
      return "soft";
  }
  return;
}
function isValidResetMode(mode) {
  return ResetModes.includes(mode);
}
var ResetMode;
var ResetModes;
var init_reset = __esm({
  "src/lib/tasks/reset.ts"() {
    "use strict";
    init_task();
    ResetMode = /* @__PURE__ */ ((ResetMode2) => {
      ResetMode2["MIXED"] = "mixed";
      ResetMode2["SOFT"] = "soft";
      ResetMode2["HARD"] = "hard";
      ResetMode2["MERGE"] = "merge";
      ResetMode2["KEEP"] = "keep";
      return ResetMode2;
    })(ResetMode || {});
    ResetModes = Array.from(Object.values(ResetMode));
  }
});
function createLog() {
  return (0, import_debug.default)("simple-git");
}
function prefixedLogger(to, prefix, forward) {
  if (!prefix || !String(prefix).replace(/\s*/, "")) {
    return !forward ? to : (message, ...args) => {
      to(message, ...args);
      forward(message, ...args);
    };
  }
  return (message, ...args) => {
    to(`%s ${message}`, prefix, ...args);
    if (forward) {
      forward(message, ...args);
    }
  };
}
function childLoggerName(name, childDebugger, { namespace: parentNamespace }) {
  if (typeof name === "string") {
    return name;
  }
  const childNamespace = childDebugger && childDebugger.namespace || "";
  if (childNamespace.startsWith(parentNamespace)) {
    return childNamespace.substr(parentNamespace.length + 1);
  }
  return childNamespace || parentNamespace;
}
function createLogger(label, verbose, initialStep, infoDebugger = createLog()) {
  const labelPrefix = label && `[${label}]` || "";
  const spawned = [];
  const debugDebugger = typeof verbose === "string" ? infoDebugger.extend(verbose) : verbose;
  const key = childLoggerName(filterType(verbose, filterString), debugDebugger, infoDebugger);
  return step(initialStep);
  function sibling(name, initial) {
    return append(
      spawned,
      createLogger(label, key.replace(/^[^:]+/, name), initial, infoDebugger)
    );
  }
  function step(phase) {
    const stepPrefix = phase && `[${phase}]` || "";
    const debug2 = debugDebugger && prefixedLogger(debugDebugger, stepPrefix) || NOOP;
    const info = prefixedLogger(infoDebugger, `${labelPrefix} ${stepPrefix}`, debug2);
    return Object.assign(debugDebugger ? debug2 : info, {
      label,
      sibling,
      info,
      step
    });
  }
}
var init_git_logger = __esm({
  "src/lib/git-logger.ts"() {
    "use strict";
    init_utils();
    import_debug.default.formatters.L = (value) => String(filterHasLength(value) ? value.length : "-");
    import_debug.default.formatters.B = (value) => {
      if (Buffer.isBuffer(value)) {
        return value.toString("utf8");
      }
      return objectToString(value);
    };
  }
});
var _TasksPendingQueue;
var TasksPendingQueue;
var init_tasks_pending_queue = __esm({
  "src/lib/runners/tasks-pending-queue.ts"() {
    "use strict";
    init_git_error();
    init_git_logger();
    _TasksPendingQueue = class {
      constructor(logLabel = "GitExecutor") {
        this.logLabel = logLabel;
        this._queue = /* @__PURE__ */ new Map();
      }
      withProgress(task) {
        return this._queue.get(task);
      }
      createProgress(task) {
        const name = _TasksPendingQueue.getName(task.commands[0]);
        const logger = createLogger(this.logLabel, name);
        return {
          task,
          logger,
          name
        };
      }
      push(task) {
        const progress = this.createProgress(task);
        progress.logger("Adding task to the queue, commands = %o", task.commands);
        this._queue.set(task, progress);
        return progress;
      }
      fatal(err) {
        for (const [task, { logger }] of Array.from(this._queue.entries())) {
          if (task === err.task) {
            logger.info(`Failed %o`, err);
            logger(
              `Fatal exception, any as-yet un-started tasks run through this executor will not be attempted`
            );
          } else {
            logger.info(
              `A fatal exception occurred in a previous task, the queue has been purged: %o`,
              err.message
            );
          }
          this.complete(task);
        }
        if (this._queue.size !== 0) {
          throw new Error(`Queue size should be zero after fatal: ${this._queue.size}`);
        }
      }
      complete(task) {
        const progress = this.withProgress(task);
        if (progress) {
          this._queue.delete(task);
        }
      }
      attempt(task) {
        const progress = this.withProgress(task);
        if (!progress) {
          throw new GitError(void 0, "TasksPendingQueue: attempt called for an unknown task");
        }
        progress.logger("Starting task");
        return progress;
      }
      static getName(name = "empty") {
        return `task:${name}:${++_TasksPendingQueue.counter}`;
      }
    };
    TasksPendingQueue = _TasksPendingQueue;
    TasksPendingQueue.counter = 0;
  }
});
function pluginContext(task, commands) {
  return {
    method: first(task.commands) || "",
    commands
  };
}
function onErrorReceived(target, logger) {
  return (err) => {
    logger(`[ERROR] child process exception %o`, err);
    target.push(Buffer.from(String(err.stack), "ascii"));
  };
}
function onDataReceived(target, name, logger, output) {
  return (buffer) => {
    logger(`%s received %L bytes`, name, buffer);
    output(`%B`, buffer);
    target.push(buffer);
  };
}
var GitExecutorChain;
var init_git_executor_chain = __esm({
  "src/lib/runners/git-executor-chain.ts"() {
    "use strict";
    init_git_error();
    init_task();
    init_utils();
    init_tasks_pending_queue();
    GitExecutorChain = class {
      constructor(_executor, _scheduler, _plugins) {
        this._executor = _executor;
        this._scheduler = _scheduler;
        this._plugins = _plugins;
        this._chain = Promise.resolve();
        this._queue = new TasksPendingQueue();
      }
      get cwd() {
        return this._cwd || this._executor.cwd;
      }
      set cwd(cwd) {
        this._cwd = cwd;
      }
      get env() {
        return this._executor.env;
      }
      get outputHandler() {
        return this._executor.outputHandler;
      }
      chain() {
        return this;
      }
      push(task) {
        this._queue.push(task);
        return this._chain = this._chain.then(() => this.attemptTask(task));
      }
      attemptTask(task) {
        return __async(this, null, function* () {
          const onScheduleComplete = yield this._scheduler.next();
          const onQueueComplete = () => this._queue.complete(task);
          try {
            const { logger } = this._queue.attempt(task);
            return yield isEmptyTask(task) ? this.attemptEmptyTask(task, logger) : this.attemptRemoteTask(task, logger);
          } catch (e) {
            throw this.onFatalException(task, e);
          } finally {
            onQueueComplete();
            onScheduleComplete();
          }
        });
      }
      onFatalException(task, e) {
        const gitError = e instanceof GitError ? Object.assign(e, { task }) : new GitError(task, e && String(e));
        this._chain = Promise.resolve();
        this._queue.fatal(gitError);
        return gitError;
      }
      attemptRemoteTask(task, logger) {
        return __async(this, null, function* () {
          const binary = this._plugins.exec("spawn.binary", "", pluginContext(task, task.commands));
          const args = this._plugins.exec(
            "spawn.args",
            [...task.commands],
            pluginContext(task, task.commands)
          );
          const raw = yield this.gitResponse(
            task,
            binary,
            args,
            this.outputHandler,
            logger.step("SPAWN")
          );
          const outputStreams = yield this.handleTaskData(task, args, raw, logger.step("HANDLE"));
          logger(`passing response to task's parser as a %s`, task.format);
          if (isBufferTask(task)) {
            return callTaskParser(task.parser, outputStreams);
          }
          return callTaskParser(task.parser, outputStreams.asStrings());
        });
      }
      attemptEmptyTask(task, logger) {
        return __async(this, null, function* () {
          logger(`empty task bypassing child process to call to task's parser`);
          return task.parser(this);
        });
      }
      handleTaskData(task, args, result, logger) {
        const { exitCode, rejection, stdOut, stdErr } = result;
        return new Promise((done, fail) => {
          logger(`Preparing to handle process response exitCode=%d stdOut=`, exitCode);
          const { error } = this._plugins.exec(
            "task.error",
            { error: rejection },
            __spreadValues(__spreadValues({}, pluginContext(task, args)), result)
          );
          if (error && task.onError) {
            logger.info(`exitCode=%s handling with custom error handler`);
            return task.onError(
              result,
              error,
              (newStdOut) => {
                logger.info(`custom error handler treated as success`);
                logger(`custom error returned a %s`, objectToString(newStdOut));
                done(
                  new GitOutputStreams(
                    Array.isArray(newStdOut) ? Buffer.concat(newStdOut) : newStdOut,
                    Buffer.concat(stdErr)
                  )
                );
              },
              fail
            );
          }
          if (error) {
            logger.info(
              `handling as error: exitCode=%s stdErr=%s rejection=%o`,
              exitCode,
              stdErr.length,
              rejection
            );
            return fail(error);
          }
          logger.info(`retrieving task output complete`);
          done(new GitOutputStreams(Buffer.concat(stdOut), Buffer.concat(stdErr)));
        });
      }
      gitResponse(task, command, args, outputHandler, logger) {
        return __async(this, null, function* () {
          const outputLogger = logger.sibling("output");
          const spawnOptions = this._plugins.exec(
            "spawn.options",
            {
              cwd: this.cwd,
              env: this.env,
              windowsHide: true
            },
            pluginContext(task, task.commands)
          );
          return new Promise((done) => {
            const stdOut = [];
            const stdErr = [];
            logger.info(`%s %o`, command, args);
            logger("%O", spawnOptions);
            let rejection = this._beforeSpawn(task, args);
            if (rejection) {
              return done({
                stdOut,
                stdErr,
                exitCode: 9901,
                rejection
              });
            }
            this._plugins.exec("spawn.before", void 0, __spreadProps(__spreadValues({}, pluginContext(task, args)), {
              kill(reason) {
                rejection = reason || rejection;
              }
            }));
            const spawned = (0, import_child_process.spawn)(command, args, spawnOptions);
            spawned.stdout.on(
              "data",
              onDataReceived(stdOut, "stdOut", logger, outputLogger.step("stdOut"))
            );
            spawned.stderr.on(
              "data",
              onDataReceived(stdErr, "stdErr", logger, outputLogger.step("stdErr"))
            );
            spawned.on("error", onErrorReceived(stdErr, logger));
            if (outputHandler) {
              logger(`Passing child process stdOut/stdErr to custom outputHandler`);
              outputHandler(command, spawned.stdout, spawned.stderr, [...args]);
            }
            this._plugins.exec("spawn.after", void 0, __spreadProps(__spreadValues({}, pluginContext(task, args)), {
              spawned,
              close(exitCode, reason) {
                done({
                  stdOut,
                  stdErr,
                  exitCode,
                  rejection: rejection || reason
                });
              },
              kill(reason) {
                if (spawned.killed) {
                  return;
                }
                rejection = reason;
                spawned.kill("SIGINT");
              }
            }));
          });
        });
      }
      _beforeSpawn(task, args) {
        let rejection;
        this._plugins.exec("spawn.before", void 0, __spreadProps(__spreadValues({}, pluginContext(task, args)), {
          kill(reason) {
            rejection = reason || rejection;
          }
        }));
        return rejection;
      }
    };
  }
});
var git_executor_exports = {};
__export2(git_executor_exports, {
  GitExecutor: () => GitExecutor
});
var GitExecutor;
var init_git_executor = __esm({
  "src/lib/runners/git-executor.ts"() {
    "use strict";
    init_git_executor_chain();
    GitExecutor = class {
      constructor(cwd, _scheduler, _plugins) {
        this.cwd = cwd;
        this._scheduler = _scheduler;
        this._plugins = _plugins;
        this._chain = new GitExecutorChain(this, this._scheduler, this._plugins);
      }
      chain() {
        return new GitExecutorChain(this, this._scheduler, this._plugins);
      }
      push(task) {
        return this._chain.push(task);
      }
    };
  }
});
function taskCallback(task, response, callback = NOOP) {
  const onSuccess = (data) => {
    callback(null, data);
  };
  const onError2 = (err) => {
    if ((err == null ? void 0 : err.task) === task) {
      callback(
        err instanceof GitResponseError ? addDeprecationNoticeToError(err) : err,
        void 0
      );
    }
  };
  response.then(onSuccess, onError2);
}
function addDeprecationNoticeToError(err) {
  let log = (name) => {
    console.warn(
      `simple-git deprecation notice: accessing GitResponseError.${name} should be GitResponseError.git.${name}, this will no longer be available in version 3`
    );
    log = NOOP;
  };
  return Object.create(err, Object.getOwnPropertyNames(err.git).reduce(descriptorReducer, {}));
  function descriptorReducer(all, name) {
    if (name in err) {
      return all;
    }
    all[name] = {
      enumerable: false,
      configurable: false,
      get() {
        log(name);
        return err.git[name];
      }
    };
    return all;
  }
}
var init_task_callback = __esm({
  "src/lib/task-callback.ts"() {
    "use strict";
    init_git_response_error();
    init_utils();
  }
});
function changeWorkingDirectoryTask(directory, root) {
  return adhocExecTask((instance) => {
    if (!folderExists(directory)) {
      throw new Error(`Git.cwd: cannot change to non-directory "${directory}"`);
    }
    return (root || instance).cwd = directory;
  });
}
var init_change_working_directory = __esm({
  "src/lib/tasks/change-working-directory.ts"() {
    "use strict";
    init_utils();
    init_task();
  }
});
function checkoutTask(args) {
  const commands = ["checkout", ...args];
  if (commands[1] === "-b" && commands.includes("-B")) {
    commands[1] = remove(commands, "-B");
  }
  return straightThroughStringTask(commands);
}
function checkout_default() {
  return {
    checkout() {
      return this._runTask(
        checkoutTask(getTrailingOptions(arguments, 1)),
        trailingFunctionArgument(arguments)
      );
    },
    checkoutBranch(branchName, startPoint) {
      return this._runTask(
        checkoutTask(["-b", branchName, startPoint, ...getTrailingOptions(arguments)]),
        trailingFunctionArgument(arguments)
      );
    },
    checkoutLocalBranch(branchName) {
      return this._runTask(
        checkoutTask(["-b", branchName, ...getTrailingOptions(arguments)]),
        trailingFunctionArgument(arguments)
      );
    }
  };
}
var init_checkout = __esm({
  "src/lib/tasks/checkout.ts"() {
    "use strict";
    init_utils();
    init_task();
  }
});
function countObjectsResponse() {
  return {
    count: 0,
    garbage: 0,
    inPack: 0,
    packs: 0,
    prunePackable: 0,
    size: 0,
    sizeGarbage: 0,
    sizePack: 0
  };
}
function count_objects_default() {
  return {
    countObjects() {
      return this._runTask({
        commands: ["count-objects", "--verbose"],
        format: "utf-8",
        parser(stdOut) {
          return parseStringResponse(countObjectsResponse(), [parser2], stdOut);
        }
      });
    }
  };
}
var parser2;
var init_count_objects = __esm({
  "src/lib/tasks/count-objects.ts"() {
    "use strict";
    init_utils();
    parser2 = new LineParser(
      /([a-z-]+): (\d+)$/,
      (result, [key, value]) => {
        const property = asCamelCase(key);
        if (result.hasOwnProperty(property)) {
          result[property] = asNumber(value);
        }
      }
    );
  }
});
function parseCommitResult(stdOut) {
  const result = {
    author: null,
    branch: "",
    commit: "",
    root: false,
    summary: {
      changes: 0,
      insertions: 0,
      deletions: 0
    }
  };
  return parseStringResponse(result, parsers, stdOut);
}
var parsers;
var init_parse_commit = __esm({
  "src/lib/parsers/parse-commit.ts"() {
    "use strict";
    init_utils();
    parsers = [
      new LineParser(/^\[([^\s]+)( \([^)]+\))? ([^\]]+)/, (result, [branch, root, commit]) => {
        result.branch = branch;
        result.commit = commit;
        result.root = !!root;
      }),
      new LineParser(/\s*Author:\s(.+)/i, (result, [author]) => {
        const parts = author.split("<");
        const email = parts.pop();
        if (!email || !email.includes("@")) {
          return;
        }
        result.author = {
          email: email.substr(0, email.length - 1),
          name: parts.join("<").trim()
        };
      }),
      new LineParser(
        /(\d+)[^,]*(?:,\s*(\d+)[^,]*)(?:,\s*(\d+))/g,
        (result, [changes, insertions, deletions]) => {
          result.summary.changes = parseInt(changes, 10) || 0;
          result.summary.insertions = parseInt(insertions, 10) || 0;
          result.summary.deletions = parseInt(deletions, 10) || 0;
        }
      ),
      new LineParser(
        /^(\d+)[^,]*(?:,\s*(\d+)[^(]+\(([+-]))?/,
        (result, [changes, lines, direction]) => {
          result.summary.changes = parseInt(changes, 10) || 0;
          const count = parseInt(lines, 10) || 0;
          if (direction === "-") {
            result.summary.deletions = count;
          } else if (direction === "+") {
            result.summary.insertions = count;
          }
        }
      )
    ];
  }
});
function commitTask(message, files, customArgs) {
  const commands = [
    "-c",
    "core.abbrev=40",
    "commit",
    ...prefixedArray(message, "-m"),
    ...files,
    ...customArgs
  ];
  return {
    commands,
    format: "utf-8",
    parser: parseCommitResult
  };
}
function commit_default() {
  return {
    commit(message, ...rest) {
      const next = trailingFunctionArgument(arguments);
      const task = rejectDeprecatedSignatures(message) || commitTask(
        asArray(message),
        asArray(filterType(rest[0], filterStringOrStringArray, [])),
        [...filterType(rest[1], filterArray, []), ...getTrailingOptions(arguments, 0, true)]
      );
      return this._runTask(task, next);
    }
  };
  function rejectDeprecatedSignatures(message) {
    return !filterStringOrStringArray(message) && configurationErrorTask(
      `git.commit: requires the commit message to be supplied as a string/string[]`
    );
  }
}
var init_commit = __esm({
  "src/lib/tasks/commit.ts"() {
    "use strict";
    init_parse_commit();
    init_utils();
    init_task();
  }
});
function first_commit_default() {
  return {
    firstCommit() {
      return this._runTask(
        straightThroughStringTask(["rev-list", "--max-parents=0", "HEAD"], true),
        trailingFunctionArgument(arguments)
      );
    }
  };
}
var init_first_commit = __esm({
  "src/lib/tasks/first-commit.ts"() {
    "use strict";
    init_utils();
    init_task();
  }
});
function hashObjectTask(filePath, write) {
  const commands = ["hash-object", filePath];
  if (write) {
    commands.push("-w");
  }
  return straightThroughStringTask(commands, true);
}
var init_hash_object = __esm({
  "src/lib/tasks/hash-object.ts"() {
    "use strict";
    init_task();
  }
});
function parseInit(bare, path, text) {
  const response = String(text).trim();
  let result;
  if (result = initResponseRegex.exec(response)) {
    return new InitSummary(bare, path, false, result[1]);
  }
  if (result = reInitResponseRegex.exec(response)) {
    return new InitSummary(bare, path, true, result[1]);
  }
  let gitDir = "";
  const tokens = response.split(" ");
  while (tokens.length) {
    const token = tokens.shift();
    if (token === "in") {
      gitDir = tokens.join(" ");
      break;
    }
  }
  return new InitSummary(bare, path, /^re/i.test(response), gitDir);
}
var InitSummary;
var initResponseRegex;
var reInitResponseRegex;
var init_InitSummary = __esm({
  "src/lib/responses/InitSummary.ts"() {
    "use strict";
    InitSummary = class {
      constructor(bare, path, existing, gitDir) {
        this.bare = bare;
        this.path = path;
        this.existing = existing;
        this.gitDir = gitDir;
      }
    };
    initResponseRegex = /^Init.+ repository in (.+)$/;
    reInitResponseRegex = /^Rein.+ in (.+)$/;
  }
});
function hasBareCommand(command) {
  return command.includes(bareCommand);
}
function initTask(bare = false, path, customArgs) {
  const commands = ["init", ...customArgs];
  if (bare && !hasBareCommand(commands)) {
    commands.splice(1, 0, bareCommand);
  }
  return {
    commands,
    format: "utf-8",
    parser(text) {
      return parseInit(commands.includes("--bare"), path, text);
    }
  };
}
var bareCommand;
var init_init = __esm({
  "src/lib/tasks/init.ts"() {
    "use strict";
    init_InitSummary();
    bareCommand = "--bare";
  }
});
function logFormatFromCommand(customArgs) {
  for (let i = 0; i < customArgs.length; i++) {
    const format = logFormatRegex.exec(customArgs[i]);
    if (format) {
      return `--${format[1]}`;
    }
  }
  return "";
}
function isLogFormat(customArg) {
  return logFormatRegex.test(customArg);
}
var logFormatRegex;
var init_log_format = __esm({
  "src/lib/args/log-format.ts"() {
    "use strict";
    logFormatRegex = /^--(stat|numstat|name-only|name-status)(=|$)/;
  }
});
var DiffSummary;
var init_DiffSummary = __esm({
  "src/lib/responses/DiffSummary.ts"() {
    "use strict";
    DiffSummary = class {
      constructor() {
        this.changed = 0;
        this.deletions = 0;
        this.insertions = 0;
        this.files = [];
      }
    };
  }
});
function getDiffParser(format = "") {
  const parser4 = diffSummaryParsers[format];
  return (stdOut) => parseStringResponse(new DiffSummary(), parser4, stdOut, false);
}
var statParser;
var numStatParser;
var nameOnlyParser;
var nameStatusParser;
var diffSummaryParsers;
var init_parse_diff_summary = __esm({
  "src/lib/parsers/parse-diff-summary.ts"() {
    "use strict";
    init_log_format();
    init_DiffSummary();
    init_diff_name_status();
    init_utils();
    statParser = [
      new LineParser(
        /^(.+)\s+\|\s+(\d+)(\s+[+\-]+)?$/,
        (result, [file, changes, alterations = ""]) => {
          result.files.push({
            file: file.trim(),
            changes: asNumber(changes),
            insertions: alterations.replace(/[^+]/g, "").length,
            deletions: alterations.replace(/[^-]/g, "").length,
            binary: false
          });
        }
      ),
      new LineParser(
        /^(.+) \|\s+Bin ([0-9.]+) -> ([0-9.]+) ([a-z]+)/,
        (result, [file, before, after]) => {
          result.files.push({
            file: file.trim(),
            before: asNumber(before),
            after: asNumber(after),
            binary: true
          });
        }
      ),
      new LineParser(
        /(\d+) files? changed\s*((?:, \d+ [^,]+){0,2})/,
        (result, [changed, summary]) => {
          const inserted = /(\d+) i/.exec(summary);
          const deleted = /(\d+) d/.exec(summary);
          result.changed = asNumber(changed);
          result.insertions = asNumber(inserted == null ? void 0 : inserted[1]);
          result.deletions = asNumber(deleted == null ? void 0 : deleted[1]);
        }
      )
    ];
    numStatParser = [
      new LineParser(
        /(\d+)\t(\d+)\t(.+)$/,
        (result, [changesInsert, changesDelete, file]) => {
          const insertions = asNumber(changesInsert);
          const deletions = asNumber(changesDelete);
          result.changed++;
          result.insertions += insertions;
          result.deletions += deletions;
          result.files.push({
            file,
            changes: insertions + deletions,
            insertions,
            deletions,
            binary: false
          });
        }
      ),
      new LineParser(/-\t-\t(.+)$/, (result, [file]) => {
        result.changed++;
        result.files.push({
          file,
          after: 0,
          before: 0,
          binary: true
        });
      })
    ];
    nameOnlyParser = [
      new LineParser(/(.+)$/, (result, [file]) => {
        result.changed++;
        result.files.push({
          file,
          changes: 0,
          insertions: 0,
          deletions: 0,
          binary: false
        });
      })
    ];
    nameStatusParser = [
      new LineParser(
        /([ACDMRTUXB])([0-9]{0,3})\t(.[^\t]*)(\t(.[^\t]*))?$/,
        (result, [status, similarity, from, _to, to]) => {
          result.changed++;
          result.files.push({
            file: to != null ? to : from,
            changes: 0,
            insertions: 0,
            deletions: 0,
            binary: false,
            status: orVoid(isDiffNameStatus(status) && status),
            from: orVoid(!!to && from !== to && from),
            similarity: asNumber(similarity)
          });
        }
      )
    ];
    diffSummaryParsers = {
      [
        ""
        /* NONE */
      ]: statParser,
      [
        "--stat"
        /* STAT */
      ]: statParser,
      [
        "--numstat"
        /* NUM_STAT */
      ]: numStatParser,
      [
        "--name-status"
        /* NAME_STATUS */
      ]: nameStatusParser,
      [
        "--name-only"
        /* NAME_ONLY */
      ]: nameOnlyParser
    };
  }
});
function lineBuilder(tokens, fields) {
  return fields.reduce(
    (line, field, index) => {
      line[field] = tokens[index] || "";
      return line;
    },
    /* @__PURE__ */ Object.create({ diff: null })
  );
}
function createListLogSummaryParser(splitter = SPLITTER, fields = defaultFieldNames, logFormat = "") {
  const parseDiffResult = getDiffParser(logFormat);
  return function(stdOut) {
    const all = toLinesWithContent(
      stdOut.trim(),
      false,
      START_BOUNDARY
    ).map(function(item) {
      const lineDetail = item.split(COMMIT_BOUNDARY);
      const listLogLine = lineBuilder(lineDetail[0].split(splitter), fields);
      if (lineDetail.length > 1 && !!lineDetail[1].trim()) {
        listLogLine.diff = parseDiffResult(lineDetail[1]);
      }
      return listLogLine;
    });
    return {
      all,
      latest: all.length && all[0] || null,
      total: all.length
    };
  };
}
var START_BOUNDARY;
var COMMIT_BOUNDARY;
var SPLITTER;
var defaultFieldNames;
var init_parse_list_log_summary = __esm({
  "src/lib/parsers/parse-list-log-summary.ts"() {
    "use strict";
    init_utils();
    init_parse_diff_summary();
    init_log_format();
    START_BOUNDARY = "\xF2\xF2\xF2\xF2\xF2\xF2 ";
    COMMIT_BOUNDARY = " \xF2\xF2";
    SPLITTER = " \xF2 ";
    defaultFieldNames = ["hash", "date", "message", "refs", "author_name", "author_email"];
  }
});
var diff_exports = {};
__export2(diff_exports, {
  diffSummaryTask: () => diffSummaryTask,
  validateLogFormatConfig: () => validateLogFormatConfig
});
function diffSummaryTask(customArgs) {
  let logFormat = logFormatFromCommand(customArgs);
  const commands = ["diff"];
  if (logFormat === "") {
    logFormat = "--stat";
    commands.push("--stat=4096");
  }
  commands.push(...customArgs);
  return validateLogFormatConfig(commands) || {
    commands,
    format: "utf-8",
    parser: getDiffParser(logFormat)
  };
}
function validateLogFormatConfig(customArgs) {
  const flags = customArgs.filter(isLogFormat);
  if (flags.length > 1) {
    return configurationErrorTask(
      `Summary flags are mutually exclusive - pick one of ${flags.join(",")}`
    );
  }
  if (flags.length && customArgs.includes("-z")) {
    return configurationErrorTask(
      `Summary flag ${flags} parsing is not compatible with null termination option '-z'`
    );
  }
}
var init_diff = __esm({
  "src/lib/tasks/diff.ts"() {
    "use strict";
    init_log_format();
    init_parse_diff_summary();
    init_task();
  }
});
function prettyFormat(format, splitter) {
  const fields = [];
  const formatStr = [];
  Object.keys(format).forEach((field) => {
    fields.push(field);
    formatStr.push(String(format[field]));
  });
  return [fields, formatStr.join(splitter)];
}
function userOptions(input) {
  return Object.keys(input).reduce((out, key) => {
    if (!(key in excludeOptions)) {
      out[key] = input[key];
    }
    return out;
  }, {});
}
function parseLogOptions(opt = {}, customArgs = []) {
  const splitter = filterType(opt.splitter, filterString, SPLITTER);
  const format = !filterPrimitives(opt.format) && opt.format ? opt.format : {
    hash: "%H",
    date: opt.strictDate === false ? "%ai" : "%aI",
    message: "%s",
    refs: "%D",
    body: opt.multiLine ? "%B" : "%b",
    author_name: opt.mailMap !== false ? "%aN" : "%an",
    author_email: opt.mailMap !== false ? "%aE" : "%ae"
  };
  const [fields, formatStr] = prettyFormat(format, splitter);
  const suffix = [];
  const command = [
    `--pretty=format:${START_BOUNDARY}${formatStr}${COMMIT_BOUNDARY}`,
    ...customArgs
  ];
  const maxCount = opt.n || opt["max-count"] || opt.maxCount;
  if (maxCount) {
    command.push(`--max-count=${maxCount}`);
  }
  if (opt.from || opt.to) {
    const rangeOperator = opt.symmetric !== false ? "..." : "..";
    suffix.push(`${opt.from || ""}${rangeOperator}${opt.to || ""}`);
  }
  if (filterString(opt.file)) {
    command.push("--follow", pathspec(opt.file));
  }
  appendTaskOptions(userOptions(opt), command);
  return {
    fields,
    splitter,
    commands: [...command, ...suffix]
  };
}
function logTask(splitter, fields, customArgs) {
  const parser4 = createListLogSummaryParser(splitter, fields, logFormatFromCommand(customArgs));
  return {
    commands: ["log", ...customArgs],
    format: "utf-8",
    parser: parser4
  };
}
function log_default() {
  return {
    log(...rest) {
      const next = trailingFunctionArgument(arguments);
      const options = parseLogOptions(
        trailingOptionsArgument(arguments),
        filterType(arguments[0], filterArray)
      );
      const task = rejectDeprecatedSignatures(...rest) || validateLogFormatConfig(options.commands) || createLogTask(options);
      return this._runTask(task, next);
    }
  };
  function createLogTask(options) {
    return logTask(options.splitter, options.fields, options.commands);
  }
  function rejectDeprecatedSignatures(from, to) {
    return filterString(from) && filterString(to) && configurationErrorTask(
      `git.log(string, string) should be replaced with git.log({ from: string, to: string })`
    );
  }
}
var excludeOptions;
var init_log = __esm({
  "src/lib/tasks/log.ts"() {
    "use strict";
    init_log_format();
    init_pathspec();
    init_parse_list_log_summary();
    init_utils();
    init_task();
    init_diff();
    excludeOptions = /* @__PURE__ */ ((excludeOptions2) => {
      excludeOptions2[excludeOptions2["--pretty"] = 0] = "--pretty";
      excludeOptions2[excludeOptions2["max-count"] = 1] = "max-count";
      excludeOptions2[excludeOptions2["maxCount"] = 2] = "maxCount";
      excludeOptions2[excludeOptions2["n"] = 3] = "n";
      excludeOptions2[excludeOptions2["file"] = 4] = "file";
      excludeOptions2[excludeOptions2["format"] = 5] = "format";
      excludeOptions2[excludeOptions2["from"] = 6] = "from";
      excludeOptions2[excludeOptions2["to"] = 7] = "to";
      excludeOptions2[excludeOptions2["splitter"] = 8] = "splitter";
      excludeOptions2[excludeOptions2["symmetric"] = 9] = "symmetric";
      excludeOptions2[excludeOptions2["mailMap"] = 10] = "mailMap";
      excludeOptions2[excludeOptions2["multiLine"] = 11] = "multiLine";
      excludeOptions2[excludeOptions2["strictDate"] = 12] = "strictDate";
      return excludeOptions2;
    })(excludeOptions || {});
  }
});
var MergeSummaryConflict;
var MergeSummaryDetail;
var init_MergeSummary = __esm({
  "src/lib/responses/MergeSummary.ts"() {
    "use strict";
    MergeSummaryConflict = class {
      constructor(reason, file = null, meta) {
        this.reason = reason;
        this.file = file;
        this.meta = meta;
      }
      toString() {
        return `${this.file}:${this.reason}`;
      }
    };
    MergeSummaryDetail = class {
      constructor() {
        this.conflicts = [];
        this.merges = [];
        this.result = "success";
      }
      get failed() {
        return this.conflicts.length > 0;
      }
      get reason() {
        return this.result;
      }
      toString() {
        if (this.conflicts.length) {
          return `CONFLICTS: ${this.conflicts.join(", ")}`;
        }
        return "OK";
      }
    };
  }
});
var PullSummary;
var PullFailedSummary;
var init_PullSummary = __esm({
  "src/lib/responses/PullSummary.ts"() {
    "use strict";
    PullSummary = class {
      constructor() {
        this.remoteMessages = {
          all: []
        };
        this.created = [];
        this.deleted = [];
        this.files = [];
        this.deletions = {};
        this.insertions = {};
        this.summary = {
          changes: 0,
          deletions: 0,
          insertions: 0
        };
      }
    };
    PullFailedSummary = class {
      constructor() {
        this.remote = "";
        this.hash = {
          local: "",
          remote: ""
        };
        this.branch = {
          local: "",
          remote: ""
        };
        this.message = "";
      }
      toString() {
        return this.message;
      }
    };
  }
});
function objectEnumerationResult(remoteMessages) {
  return remoteMessages.objects = remoteMessages.objects || {
    compressing: 0,
    counting: 0,
    enumerating: 0,
    packReused: 0,
    reused: { count: 0, delta: 0 },
    total: { count: 0, delta: 0 }
  };
}
function asObjectCount(source) {
  const count = /^\s*(\d+)/.exec(source);
  const delta = /delta (\d+)/i.exec(source);
  return {
    count: asNumber(count && count[1] || "0"),
    delta: asNumber(delta && delta[1] || "0")
  };
}
var remoteMessagesObjectParsers;
var init_parse_remote_objects = __esm({
  "src/lib/parsers/parse-remote-objects.ts"() {
    "use strict";
    init_utils();
    remoteMessagesObjectParsers = [
      new RemoteLineParser(
        /^remote:\s*(enumerating|counting|compressing) objects: (\d+),/i,
        (result, [action, count]) => {
          const key = action.toLowerCase();
          const enumeration = objectEnumerationResult(result.remoteMessages);
          Object.assign(enumeration, { [key]: asNumber(count) });
        }
      ),
      new RemoteLineParser(
        /^remote:\s*(enumerating|counting|compressing) objects: \d+% \(\d+\/(\d+)\),/i,
        (result, [action, count]) => {
          const key = action.toLowerCase();
          const enumeration = objectEnumerationResult(result.remoteMessages);
          Object.assign(enumeration, { [key]: asNumber(count) });
        }
      ),
      new RemoteLineParser(
        /total ([^,]+), reused ([^,]+), pack-reused (\d+)/i,
        (result, [total, reused, packReused]) => {
          const objects = objectEnumerationResult(result.remoteMessages);
          objects.total = asObjectCount(total);
          objects.reused = asObjectCount(reused);
          objects.packReused = asNumber(packReused);
        }
      )
    ];
  }
});
function parseRemoteMessages(_stdOut, stdErr) {
  return parseStringResponse({ remoteMessages: new RemoteMessageSummary() }, parsers2, stdErr);
}
var parsers2;
var RemoteMessageSummary;
var init_parse_remote_messages = __esm({
  "src/lib/parsers/parse-remote-messages.ts"() {
    "use strict";
    init_utils();
    init_parse_remote_objects();
    parsers2 = [
      new RemoteLineParser(/^remote:\s*(.+)$/, (result, [text]) => {
        result.remoteMessages.all.push(text.trim());
        return false;
      }),
      ...remoteMessagesObjectParsers,
      new RemoteLineParser(
        [/create a (?:pull|merge) request/i, /\s(https?:\/\/\S+)$/],
        (result, [pullRequestUrl]) => {
          result.remoteMessages.pullRequestUrl = pullRequestUrl;
        }
      ),
      new RemoteLineParser(
        [/found (\d+) vulnerabilities.+\(([^)]+)\)/i, /\s(https?:\/\/\S+)$/],
        (result, [count, summary, url]) => {
          result.remoteMessages.vulnerabilities = {
            count: asNumber(count),
            summary,
            url
          };
        }
      )
    ];
    RemoteMessageSummary = class {
      constructor() {
        this.all = [];
      }
    };
  }
});
function parsePullErrorResult(stdOut, stdErr) {
  const pullError = parseStringResponse(new PullFailedSummary(), errorParsers, [stdOut, stdErr]);
  return pullError.message && pullError;
}
var FILE_UPDATE_REGEX;
var SUMMARY_REGEX;
var ACTION_REGEX;
var parsers3;
var errorParsers;
var parsePullDetail;
var parsePullResult;
var init_parse_pull = __esm({
  "src/lib/parsers/parse-pull.ts"() {
    "use strict";
    init_PullSummary();
    init_utils();
    init_parse_remote_messages();
    FILE_UPDATE_REGEX = /^\s*(.+?)\s+\|\s+\d+\s*(\+*)(-*)/;
    SUMMARY_REGEX = /(\d+)\D+((\d+)\D+\(\+\))?(\D+(\d+)\D+\(-\))?/;
    ACTION_REGEX = /^(create|delete) mode \d+ (.+)/;
    parsers3 = [
      new LineParser(FILE_UPDATE_REGEX, (result, [file, insertions, deletions]) => {
        result.files.push(file);
        if (insertions) {
          result.insertions[file] = insertions.length;
        }
        if (deletions) {
          result.deletions[file] = deletions.length;
        }
      }),
      new LineParser(SUMMARY_REGEX, (result, [changes, , insertions, , deletions]) => {
        if (insertions !== void 0 || deletions !== void 0) {
          result.summary.changes = +changes || 0;
          result.summary.insertions = +insertions || 0;
          result.summary.deletions = +deletions || 0;
          return true;
        }
        return false;
      }),
      new LineParser(ACTION_REGEX, (result, [action, file]) => {
        append(result.files, file);
        append(action === "create" ? result.created : result.deleted, file);
      })
    ];
    errorParsers = [
      new LineParser(/^from\s(.+)$/i, (result, [remote]) => void (result.remote = remote)),
      new LineParser(/^fatal:\s(.+)$/, (result, [message]) => void (result.message = message)),
      new LineParser(
        /([a-z0-9]+)\.\.([a-z0-9]+)\s+(\S+)\s+->\s+(\S+)$/,
        (result, [hashLocal, hashRemote, branchLocal, branchRemote]) => {
          result.branch.local = branchLocal;
          result.hash.local = hashLocal;
          result.branch.remote = branchRemote;
          result.hash.remote = hashRemote;
        }
      )
    ];
    parsePullDetail = (stdOut, stdErr) => {
      return parseStringResponse(new PullSummary(), parsers3, [stdOut, stdErr]);
    };
    parsePullResult = (stdOut, stdErr) => {
      return Object.assign(
        new PullSummary(),
        parsePullDetail(stdOut, stdErr),
        parseRemoteMessages(stdOut, stdErr)
      );
    };
  }
});
var parsers4;
var parseMergeResult;
var parseMergeDetail;
var init_parse_merge = __esm({
  "src/lib/parsers/parse-merge.ts"() {
    "use strict";
    init_MergeSummary();
    init_utils();
    init_parse_pull();
    parsers4 = [
      new LineParser(/^Auto-merging\s+(.+)$/, (summary, [autoMerge]) => {
        summary.merges.push(autoMerge);
      }),
      new LineParser(/^CONFLICT\s+\((.+)\): Merge conflict in (.+)$/, (summary, [reason, file]) => {
        summary.conflicts.push(new MergeSummaryConflict(reason, file));
      }),
      new LineParser(
        /^CONFLICT\s+\((.+\/delete)\): (.+) deleted in (.+) and/,
        (summary, [reason, file, deleteRef]) => {
          summary.conflicts.push(new MergeSummaryConflict(reason, file, { deleteRef }));
        }
      ),
      new LineParser(/^CONFLICT\s+\((.+)\):/, (summary, [reason]) => {
        summary.conflicts.push(new MergeSummaryConflict(reason, null));
      }),
      new LineParser(/^Automatic merge failed;\s+(.+)$/, (summary, [result]) => {
        summary.result = result;
      })
    ];
    parseMergeResult = (stdOut, stdErr) => {
      return Object.assign(parseMergeDetail(stdOut, stdErr), parsePullResult(stdOut, stdErr));
    };
    parseMergeDetail = (stdOut) => {
      return parseStringResponse(new MergeSummaryDetail(), parsers4, stdOut);
    };
  }
});
function mergeTask(customArgs) {
  if (!customArgs.length) {
    return configurationErrorTask("Git.merge requires at least one option");
  }
  return {
    commands: ["merge", ...customArgs],
    format: "utf-8",
    parser(stdOut, stdErr) {
      const merge = parseMergeResult(stdOut, stdErr);
      if (merge.failed) {
        throw new GitResponseError(merge);
      }
      return merge;
    }
  };
}
var init_merge = __esm({
  "src/lib/tasks/merge.ts"() {
    "use strict";
    init_git_response_error();
    init_parse_merge();
    init_task();
  }
});
function pushResultPushedItem(local, remote, status) {
  const deleted = status.includes("deleted");
  const tag = status.includes("tag") || /^refs\/tags/.test(local);
  const alreadyUpdated = !status.includes("new");
  return {
    deleted,
    tag,
    branch: !tag,
    new: !alreadyUpdated,
    alreadyUpdated,
    local,
    remote
  };
}
var parsers5;
var parsePushResult;
var parsePushDetail;
var init_parse_push = __esm({
  "src/lib/parsers/parse-push.ts"() {
    "use strict";
    init_utils();
    init_parse_remote_messages();
    parsers5 = [
      new LineParser(/^Pushing to (.+)$/, (result, [repo]) => {
        result.repo = repo;
      }),
      new LineParser(/^updating local tracking ref '(.+)'/, (result, [local]) => {
        result.ref = __spreadProps(__spreadValues({}, result.ref || {}), {
          local
        });
      }),
      new LineParser(/^[=*-]\s+([^:]+):(\S+)\s+\[(.+)]$/, (result, [local, remote, type]) => {
        result.pushed.push(pushResultPushedItem(local, remote, type));
      }),
      new LineParser(
        /^Branch '([^']+)' set up to track remote branch '([^']+)' from '([^']+)'/,
        (result, [local, remote, remoteName]) => {
          result.branch = __spreadProps(__spreadValues({}, result.branch || {}), {
            local,
            remote,
            remoteName
          });
        }
      ),
      new LineParser(
        /^([^:]+):(\S+)\s+([a-z0-9]+)\.\.([a-z0-9]+)$/,
        (result, [local, remote, from, to]) => {
          result.update = {
            head: {
              local,
              remote
            },
            hash: {
              from,
              to
            }
          };
        }
      )
    ];
    parsePushResult = (stdOut, stdErr) => {
      const pushDetail = parsePushDetail(stdOut, stdErr);
      const responseDetail = parseRemoteMessages(stdOut, stdErr);
      return __spreadValues(__spreadValues({}, pushDetail), responseDetail);
    };
    parsePushDetail = (stdOut, stdErr) => {
      return parseStringResponse({ pushed: [] }, parsers5, [stdOut, stdErr]);
    };
  }
});
var push_exports = {};
__export2(push_exports, {
  pushTagsTask: () => pushTagsTask,
  pushTask: () => pushTask
});
function pushTagsTask(ref = {}, customArgs) {
  append(customArgs, "--tags");
  return pushTask(ref, customArgs);
}
function pushTask(ref = {}, customArgs) {
  const commands = ["push", ...customArgs];
  if (ref.branch) {
    commands.splice(1, 0, ref.branch);
  }
  if (ref.remote) {
    commands.splice(1, 0, ref.remote);
  }
  remove(commands, "-v");
  append(commands, "--verbose");
  append(commands, "--porcelain");
  return {
    commands,
    format: "utf-8",
    parser: parsePushResult
  };
}
var init_push = __esm({
  "src/lib/tasks/push.ts"() {
    "use strict";
    init_parse_push();
    init_utils();
  }
});
function show_default() {
  return {
    showBuffer() {
      const commands = ["show", ...getTrailingOptions(arguments, 1)];
      if (!commands.includes("--binary")) {
        commands.splice(1, 0, "--binary");
      }
      return this._runTask(
        straightThroughBufferTask(commands),
        trailingFunctionArgument(arguments)
      );
    },
    show() {
      const commands = ["show", ...getTrailingOptions(arguments, 1)];
      return this._runTask(
        straightThroughStringTask(commands),
        trailingFunctionArgument(arguments)
      );
    }
  };
}
var init_show = __esm({
  "src/lib/tasks/show.ts"() {
    "use strict";
    init_utils();
    init_task();
  }
});
var fromPathRegex;
var FileStatusSummary;
var init_FileStatusSummary = __esm({
  "src/lib/responses/FileStatusSummary.ts"() {
    "use strict";
    fromPathRegex = /^(.+)\0(.+)$/;
    FileStatusSummary = class {
      constructor(path, index, working_dir) {
        this.path = path;
        this.index = index;
        this.working_dir = working_dir;
        if (index === "R" || working_dir === "R") {
          const detail = fromPathRegex.exec(path) || [null, path, path];
          this.from = detail[2] || "";
          this.path = detail[1] || "";
        }
      }
    };
  }
});
function renamedFile(line) {
  const [to, from] = line.split(NULL);
  return {
    from: from || to,
    to
  };
}
function parser3(indexX, indexY, handler) {
  return [`${indexX}${indexY}`, handler];
}
function conflicts(indexX, ...indexY) {
  return indexY.map((y) => parser3(indexX, y, (result, file) => append(result.conflicted, file)));
}
function splitLine(result, lineStr) {
  const trimmed2 = lineStr.trim();
  switch (" ") {
    case trimmed2.charAt(2):
      return data(trimmed2.charAt(0), trimmed2.charAt(1), trimmed2.substr(3));
    case trimmed2.charAt(1):
      return data(" ", trimmed2.charAt(0), trimmed2.substr(2));
    default:
      return;
  }
  function data(index, workingDir, path) {
    const raw = `${index}${workingDir}`;
    const handler = parsers6.get(raw);
    if (handler) {
      handler(result, path);
    }
    if (raw !== "##" && raw !== "!!") {
      result.files.push(new FileStatusSummary(path, index, workingDir));
    }
  }
}
var StatusSummary;
var parsers6;
var parseStatusSummary;
var init_StatusSummary = __esm({
  "src/lib/responses/StatusSummary.ts"() {
    "use strict";
    init_utils();
    init_FileStatusSummary();
    StatusSummary = class {
      constructor() {
        this.not_added = [];
        this.conflicted = [];
        this.created = [];
        this.deleted = [];
        this.ignored = void 0;
        this.modified = [];
        this.renamed = [];
        this.files = [];
        this.staged = [];
        this.ahead = 0;
        this.behind = 0;
        this.current = null;
        this.tracking = null;
        this.detached = false;
        this.isClean = () => {
          return !this.files.length;
        };
      }
    };
    parsers6 = new Map([
      parser3(
        " ",
        "A",
        (result, file) => append(result.created, file)
      ),
      parser3(
        " ",
        "D",
        (result, file) => append(result.deleted, file)
      ),
      parser3(
        " ",
        "M",
        (result, file) => append(result.modified, file)
      ),
      parser3(
        "A",
        " ",
        (result, file) => append(result.created, file) && append(result.staged, file)
      ),
      parser3(
        "A",
        "M",
        (result, file) => append(result.created, file) && append(result.staged, file) && append(result.modified, file)
      ),
      parser3(
        "D",
        " ",
        (result, file) => append(result.deleted, file) && append(result.staged, file)
      ),
      parser3(
        "M",
        " ",
        (result, file) => append(result.modified, file) && append(result.staged, file)
      ),
      parser3(
        "M",
        "M",
        (result, file) => append(result.modified, file) && append(result.staged, file)
      ),
      parser3("R", " ", (result, file) => {
        append(result.renamed, renamedFile(file));
      }),
      parser3("R", "M", (result, file) => {
        const renamed = renamedFile(file);
        append(result.renamed, renamed);
        append(result.modified, renamed.to);
      }),
      parser3("!", "!", (_result, _file) => {
        append(_result.ignored = _result.ignored || [], _file);
      }),
      parser3(
        "?",
        "?",
        (result, file) => append(result.not_added, file)
      ),
      ...conflicts(
        "A",
        "A",
        "U"
        /* UNMERGED */
      ),
      ...conflicts(
        "D",
        "D",
        "U"
        /* UNMERGED */
      ),
      ...conflicts(
        "U",
        "A",
        "D",
        "U"
        /* UNMERGED */
      ),
      [
        "##",
        (result, line) => {
          const aheadReg = /ahead (\d+)/;
          const behindReg = /behind (\d+)/;
          const currentReg = /^(.+?(?=(?:\.{3}|\s|$)))/;
          const trackingReg = /\.{3}(\S*)/;
          const onEmptyBranchReg = /\son\s([\S]+)$/;
          let regexResult;
          regexResult = aheadReg.exec(line);
          result.ahead = regexResult && +regexResult[1] || 0;
          regexResult = behindReg.exec(line);
          result.behind = regexResult && +regexResult[1] || 0;
          regexResult = currentReg.exec(line);
          result.current = regexResult && regexResult[1];
          regexResult = trackingReg.exec(line);
          result.tracking = regexResult && regexResult[1];
          regexResult = onEmptyBranchReg.exec(line);
          result.current = regexResult && regexResult[1] || result.current;
          result.detached = /\(no branch\)/.test(line);
        }
      ]
    ]);
    parseStatusSummary = function(text) {
      const lines = text.split(NULL);
      const status = new StatusSummary();
      for (let i = 0, l = lines.length; i < l; ) {
        let line = lines[i++].trim();
        if (!line) {
          continue;
        }
        if (line.charAt(0) === "R") {
          line += NULL + (lines[i++] || "");
        }
        splitLine(status, line);
      }
      return status;
    };
  }
});
function statusTask(customArgs) {
  const commands = [
    "status",
    "--porcelain",
    "-b",
    "-u",
    "--null",
    ...customArgs.filter((arg) => !ignoredOptions.includes(arg))
  ];
  return {
    format: "utf-8",
    commands,
    parser(text) {
      return parseStatusSummary(text);
    }
  };
}
var ignoredOptions;
var init_status = __esm({
  "src/lib/tasks/status.ts"() {
    "use strict";
    init_StatusSummary();
    ignoredOptions = ["--null", "-z"];
  }
});
function versionResponse(major = 0, minor = 0, patch = 0, agent = "", installed = true) {
  return Object.defineProperty(
    {
      major,
      minor,
      patch,
      agent,
      installed
    },
    "toString",
    {
      value() {
        return `${this.major}.${this.minor}.${this.patch}`;
      },
      configurable: false,
      enumerable: false
    }
  );
}
function notInstalledResponse() {
  return versionResponse(0, 0, 0, "", false);
}
function version_default() {
  return {
    version() {
      return this._runTask({
        commands: ["--version"],
        format: "utf-8",
        parser: versionParser,
        onError(result, error, done, fail) {
          if (result.exitCode === -2) {
            return done(Buffer.from(NOT_INSTALLED));
          }
          fail(error);
        }
      });
    }
  };
}
function versionParser(stdOut) {
  if (stdOut === NOT_INSTALLED) {
    return notInstalledResponse();
  }
  return parseStringResponse(versionResponse(0, 0, 0, stdOut), parsers7, stdOut);
}
var NOT_INSTALLED;
var parsers7;
var init_version = __esm({
  "src/lib/tasks/version.ts"() {
    "use strict";
    init_utils();
    NOT_INSTALLED = "installed=false";
    parsers7 = [
      new LineParser(
        /version (\d+)\.(\d+)\.(\d+)(?:\s*\((.+)\))?/,
        (result, [major, minor, patch, agent = ""]) => {
          Object.assign(
            result,
            versionResponse(asNumber(major), asNumber(minor), asNumber(patch), agent)
          );
        }
      ),
      new LineParser(
        /version (\d+)\.(\d+)\.(\D+)(.+)?$/,
        (result, [major, minor, patch, agent = ""]) => {
          Object.assign(result, versionResponse(asNumber(major), asNumber(minor), patch, agent));
        }
      )
    ];
  }
});
var simple_git_api_exports = {};
__export2(simple_git_api_exports, {
  SimpleGitApi: () => SimpleGitApi
});
var SimpleGitApi;
var init_simple_git_api = __esm({
  "src/lib/simple-git-api.ts"() {
    "use strict";
    init_task_callback();
    init_change_working_directory();
    init_checkout();
    init_count_objects();
    init_commit();
    init_config();
    init_first_commit();
    init_grep();
    init_hash_object();
    init_init();
    init_log();
    init_merge();
    init_push();
    init_show();
    init_status();
    init_task();
    init_version();
    init_utils();
    SimpleGitApi = class {
      constructor(_executor) {
        this._executor = _executor;
      }
      _runTask(task, then) {
        const chain = this._executor.chain();
        const promise = chain.push(task);
        if (then) {
          taskCallback(task, promise, then);
        }
        return Object.create(this, {
          then: { value: promise.then.bind(promise) },
          catch: { value: promise.catch.bind(promise) },
          _executor: { value: chain }
        });
      }
      add(files) {
        return this._runTask(
          straightThroughStringTask(["add", ...asArray(files)]),
          trailingFunctionArgument(arguments)
        );
      }
      cwd(directory) {
        const next = trailingFunctionArgument(arguments);
        if (typeof directory === "string") {
          return this._runTask(changeWorkingDirectoryTask(directory, this._executor), next);
        }
        if (typeof (directory == null ? void 0 : directory.path) === "string") {
          return this._runTask(
            changeWorkingDirectoryTask(
              directory.path,
              directory.root && this._executor || void 0
            ),
            next
          );
        }
        return this._runTask(
          configurationErrorTask("Git.cwd: workingDirectory must be supplied as a string"),
          next
        );
      }
      hashObject(path, write) {
        return this._runTask(
          hashObjectTask(path, write === true),
          trailingFunctionArgument(arguments)
        );
      }
      init(bare) {
        return this._runTask(
          initTask(bare === true, this._executor.cwd, getTrailingOptions(arguments)),
          trailingFunctionArgument(arguments)
        );
      }
      merge() {
        return this._runTask(
          mergeTask(getTrailingOptions(arguments)),
          trailingFunctionArgument(arguments)
        );
      }
      mergeFromTo(remote, branch) {
        if (!(filterString(remote) && filterString(branch))) {
          return this._runTask(
            configurationErrorTask(
              `Git.mergeFromTo requires that the 'remote' and 'branch' arguments are supplied as strings`
            )
          );
        }
        return this._runTask(
          mergeTask([remote, branch, ...getTrailingOptions(arguments)]),
          trailingFunctionArgument(arguments, false)
        );
      }
      outputHandler(handler) {
        this._executor.outputHandler = handler;
        return this;
      }
      push() {
        const task = pushTask(
          {
            remote: filterType(arguments[0], filterString),
            branch: filterType(arguments[1], filterString)
          },
          getTrailingOptions(arguments)
        );
        return this._runTask(task, trailingFunctionArgument(arguments));
      }
      stash() {
        return this._runTask(
          straightThroughStringTask(["stash", ...getTrailingOptions(arguments)]),
          trailingFunctionArgument(arguments)
        );
      }
      status() {
        return this._runTask(
          statusTask(getTrailingOptions(arguments)),
          trailingFunctionArgument(arguments)
        );
      }
    };
    Object.assign(
      SimpleGitApi.prototype,
      checkout_default(),
      commit_default(),
      config_default(),
      count_objects_default(),
      first_commit_default(),
      grep_default(),
      log_default(),
      show_default(),
      version_default()
    );
  }
});
var scheduler_exports = {};
__export2(scheduler_exports, {
  Scheduler: () => Scheduler
});
var createScheduledTask;
var Scheduler;
var init_scheduler = __esm({
  "src/lib/runners/scheduler.ts"() {
    "use strict";
    init_utils();
    init_git_logger();
    createScheduledTask = (() => {
      let id = 0;
      return () => {
        id++;
        const { promise, done } = (0, import_promise_deferred.createDeferred)();
        return {
          promise,
          done,
          id
        };
      };
    })();
    Scheduler = class {
      constructor(concurrency = 2) {
        this.concurrency = concurrency;
        this.logger = createLogger("", "scheduler");
        this.pending = [];
        this.running = [];
        this.logger(`Constructed, concurrency=%s`, concurrency);
      }
      schedule() {
        if (!this.pending.length || this.running.length >= this.concurrency) {
          this.logger(
            `Schedule attempt ignored, pending=%s running=%s concurrency=%s`,
            this.pending.length,
            this.running.length,
            this.concurrency
          );
          return;
        }
        const task = append(this.running, this.pending.shift());
        this.logger(`Attempting id=%s`, task.id);
        task.done(() => {
          this.logger(`Completing id=`, task.id);
          remove(this.running, task);
          this.schedule();
        });
      }
      next() {
        const { promise, id } = append(this.pending, createScheduledTask());
        this.logger(`Scheduling id=%s`, id);
        this.schedule();
        return promise;
      }
    };
  }
});
var apply_patch_exports = {};
__export2(apply_patch_exports, {
  applyPatchTask: () => applyPatchTask
});
function applyPatchTask(patches, customArgs) {
  return straightThroughStringTask(["apply", ...customArgs, ...patches]);
}
var init_apply_patch = __esm({
  "src/lib/tasks/apply-patch.ts"() {
    "use strict";
    init_task();
  }
});
function branchDeletionSuccess(branch, hash) {
  return {
    branch,
    hash,
    success: true
  };
}
function branchDeletionFailure(branch) {
  return {
    branch,
    hash: null,
    success: false
  };
}
var BranchDeletionBatch;
var init_BranchDeleteSummary = __esm({
  "src/lib/responses/BranchDeleteSummary.ts"() {
    "use strict";
    BranchDeletionBatch = class {
      constructor() {
        this.all = [];
        this.branches = {};
        this.errors = [];
      }
      get success() {
        return !this.errors.length;
      }
    };
  }
});
function hasBranchDeletionError(data, processExitCode) {
  return processExitCode === 1 && deleteErrorRegex.test(data);
}
var deleteSuccessRegex;
var deleteErrorRegex;
var parsers8;
var parseBranchDeletions;
var init_parse_branch_delete = __esm({
  "src/lib/parsers/parse-branch-delete.ts"() {
    "use strict";
    init_BranchDeleteSummary();
    init_utils();
    deleteSuccessRegex = /(\S+)\s+\(\S+\s([^)]+)\)/;
    deleteErrorRegex = /^error[^']+'([^']+)'/m;
    parsers8 = [
      new LineParser(deleteSuccessRegex, (result, [branch, hash]) => {
        const deletion = branchDeletionSuccess(branch, hash);
        result.all.push(deletion);
        result.branches[branch] = deletion;
      }),
      new LineParser(deleteErrorRegex, (result, [branch]) => {
        const deletion = branchDeletionFailure(branch);
        result.errors.push(deletion);
        result.all.push(deletion);
        result.branches[branch] = deletion;
      })
    ];
    parseBranchDeletions = (stdOut, stdErr) => {
      return parseStringResponse(new BranchDeletionBatch(), parsers8, [stdOut, stdErr]);
    };
  }
});
var BranchSummaryResult;
var init_BranchSummary = __esm({
  "src/lib/responses/BranchSummary.ts"() {
    "use strict";
    BranchSummaryResult = class {
      constructor() {
        this.all = [];
        this.branches = {};
        this.current = "";
        this.detached = false;
      }
      push(status, detached, name, commit, label) {
        if (status === "*") {
          this.detached = detached;
          this.current = name;
        }
        this.all.push(name);
        this.branches[name] = {
          current: status === "*",
          linkedWorkTree: status === "+",
          name,
          commit,
          label
        };
      }
    };
  }
});
function branchStatus(input) {
  return input ? input.charAt(0) : "";
}
function parseBranchSummary(stdOut) {
  return parseStringResponse(new BranchSummaryResult(), parsers9, stdOut);
}
var parsers9;
var init_parse_branch = __esm({
  "src/lib/parsers/parse-branch.ts"() {
    "use strict";
    init_BranchSummary();
    init_utils();
    parsers9 = [
      new LineParser(
        /^([*+]\s)?\((?:HEAD )?detached (?:from|at) (\S+)\)\s+([a-z0-9]+)\s(.*)$/,
        (result, [current, name, commit, label]) => {
          result.push(branchStatus(current), true, name, commit, label);
        }
      ),
      new LineParser(
        new RegExp("^([*+]\\s)?(\\S+)\\s+([a-z0-9]+)\\s?(.*)$", "s"),
        (result, [current, name, commit, label]) => {
          result.push(branchStatus(current), false, name, commit, label);
        }
      )
    ];
  }
});
var branch_exports = {};
__export2(branch_exports, {
  branchLocalTask: () => branchLocalTask,
  branchTask: () => branchTask,
  containsDeleteBranchCommand: () => containsDeleteBranchCommand,
  deleteBranchTask: () => deleteBranchTask,
  deleteBranchesTask: () => deleteBranchesTask
});
function containsDeleteBranchCommand(commands) {
  const deleteCommands = ["-d", "-D", "--delete"];
  return commands.some((command) => deleteCommands.includes(command));
}
function branchTask(customArgs) {
  const isDelete = containsDeleteBranchCommand(customArgs);
  const commands = ["branch", ...customArgs];
  if (commands.length === 1) {
    commands.push("-a");
  }
  if (!commands.includes("-v")) {
    commands.splice(1, 0, "-v");
  }
  return {
    format: "utf-8",
    commands,
    parser(stdOut, stdErr) {
      if (isDelete) {
        return parseBranchDeletions(stdOut, stdErr).all[0];
      }
      return parseBranchSummary(stdOut);
    }
  };
}
function branchLocalTask() {
  const parser4 = parseBranchSummary;
  return {
    format: "utf-8",
    commands: ["branch", "-v"],
    parser: parser4
  };
}
function deleteBranchesTask(branches, forceDelete = false) {
  return {
    format: "utf-8",
    commands: ["branch", "-v", forceDelete ? "-D" : "-d", ...branches],
    parser(stdOut, stdErr) {
      return parseBranchDeletions(stdOut, stdErr);
    },
    onError({ exitCode, stdOut }, error, done, fail) {
      if (!hasBranchDeletionError(String(error), exitCode)) {
        return fail(error);
      }
      done(stdOut);
    }
  };
}
function deleteBranchTask(branch, forceDelete = false) {
  const task = {
    format: "utf-8",
    commands: ["branch", "-v", forceDelete ? "-D" : "-d", branch],
    parser(stdOut, stdErr) {
      return parseBranchDeletions(stdOut, stdErr).branches[branch];
    },
    onError({ exitCode, stdErr, stdOut }, error, _, fail) {
      if (!hasBranchDeletionError(String(error), exitCode)) {
        return fail(error);
      }
      throw new GitResponseError(
        task.parser(bufferToString(stdOut), bufferToString(stdErr)),
        String(error)
      );
    }
  };
  return task;
}
var init_branch = __esm({
  "src/lib/tasks/branch.ts"() {
    "use strict";
    init_git_response_error();
    init_parse_branch_delete();
    init_parse_branch();
    init_utils();
  }
});
var parseCheckIgnore;
var init_CheckIgnore = __esm({
  "src/lib/responses/CheckIgnore.ts"() {
    "use strict";
    parseCheckIgnore = (text) => {
      return text.split(/\n/g).map((line) => line.trim()).filter((file) => !!file);
    };
  }
});
var check_ignore_exports = {};
__export2(check_ignore_exports, {
  checkIgnoreTask: () => checkIgnoreTask
});
function checkIgnoreTask(paths) {
  return {
    commands: ["check-ignore", ...paths],
    format: "utf-8",
    parser: parseCheckIgnore
  };
}
var init_check_ignore = __esm({
  "src/lib/tasks/check-ignore.ts"() {
    "use strict";
    init_CheckIgnore();
  }
});
var clone_exports = {};
__export2(clone_exports, {
  cloneMirrorTask: () => cloneMirrorTask,
  cloneTask: () => cloneTask
});
function disallowedCommand(command) {
  return /^--upload-pack(=|$)/.test(command);
}
function cloneTask(repo, directory, customArgs) {
  const commands = ["clone", ...customArgs];
  filterString(repo) && commands.push(repo);
  filterString(directory) && commands.push(directory);
  const banned = commands.find(disallowedCommand);
  if (banned) {
    return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);
  }
  return straightThroughStringTask(commands);
}
function cloneMirrorTask(repo, directory, customArgs) {
  append(customArgs, "--mirror");
  return cloneTask(repo, directory, customArgs);
}
var init_clone = __esm({
  "src/lib/tasks/clone.ts"() {
    "use strict";
    init_task();
    init_utils();
  }
});
function parseFetchResult(stdOut, stdErr) {
  const result = {
    raw: stdOut,
    remote: null,
    branches: [],
    tags: [],
    updated: [],
    deleted: []
  };
  return parseStringResponse(result, parsers10, [stdOut, stdErr]);
}
var parsers10;
var init_parse_fetch = __esm({
  "src/lib/parsers/parse-fetch.ts"() {
    "use strict";
    init_utils();
    parsers10 = [
      new LineParser(/From (.+)$/, (result, [remote]) => {
        result.remote = remote;
      }),
      new LineParser(/\* \[new branch]\s+(\S+)\s*-> (.+)$/, (result, [name, tracking]) => {
        result.branches.push({
          name,
          tracking
        });
      }),
      new LineParser(/\* \[new tag]\s+(\S+)\s*-> (.+)$/, (result, [name, tracking]) => {
        result.tags.push({
          name,
          tracking
        });
      }),
      new LineParser(/- \[deleted]\s+\S+\s*-> (.+)$/, (result, [tracking]) => {
        result.deleted.push({
          tracking
        });
      }),
      new LineParser(
        /\s*([^.]+)\.\.(\S+)\s+(\S+)\s*-> (.+)$/,
        (result, [from, to, name, tracking]) => {
          result.updated.push({
            name,
            tracking,
            to,
            from
          });
        }
      )
    ];
  }
});
var fetch_exports = {};
__export2(fetch_exports, {
  fetchTask: () => fetchTask
});
function disallowedCommand2(command) {
  return /^--upload-pack(=|$)/.test(command);
}
function fetchTask(remote, branch, customArgs) {
  const commands = ["fetch", ...customArgs];
  if (remote && branch) {
    commands.push(remote, branch);
  }
  const banned = commands.find(disallowedCommand2);
  if (banned) {
    return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);
  }
  return {
    commands,
    format: "utf-8",
    parser: parseFetchResult
  };
}
var init_fetch = __esm({
  "src/lib/tasks/fetch.ts"() {
    "use strict";
    init_parse_fetch();
    init_task();
  }
});
function parseMoveResult(stdOut) {
  return parseStringResponse({ moves: [] }, parsers11, stdOut);
}
var parsers11;
var init_parse_move = __esm({
  "src/lib/parsers/parse-move.ts"() {
    "use strict";
    init_utils();
    parsers11 = [
      new LineParser(/^Renaming (.+) to (.+)$/, (result, [from, to]) => {
        result.moves.push({ from, to });
      })
    ];
  }
});
var move_exports = {};
__export2(move_exports, {
  moveTask: () => moveTask
});
function moveTask(from, to) {
  return {
    commands: ["mv", "-v", ...asArray(from), to],
    format: "utf-8",
    parser: parseMoveResult
  };
}
var init_move = __esm({
  "src/lib/tasks/move.ts"() {
    "use strict";
    init_parse_move();
    init_utils();
  }
});
var pull_exports = {};
__export2(pull_exports, {
  pullTask: () => pullTask
});
function pullTask(remote, branch, customArgs) {
  const commands = ["pull", ...customArgs];
  if (remote && branch) {
    commands.splice(1, 0, remote, branch);
  }
  return {
    commands,
    format: "utf-8",
    parser(stdOut, stdErr) {
      return parsePullResult(stdOut, stdErr);
    },
    onError(result, _error, _done, fail) {
      const pullError = parsePullErrorResult(
        bufferToString(result.stdOut),
        bufferToString(result.stdErr)
      );
      if (pullError) {
        return fail(new GitResponseError(pullError));
      }
      fail(_error);
    }
  };
}
var init_pull = __esm({
  "src/lib/tasks/pull.ts"() {
    "use strict";
    init_git_response_error();
    init_parse_pull();
    init_utils();
  }
});
function parseGetRemotes(text) {
  const remotes = {};
  forEach(text, ([name]) => remotes[name] = { name });
  return Object.values(remotes);
}
function parseGetRemotesVerbose(text) {
  const remotes = {};
  forEach(text, ([name, url, purpose]) => {
    if (!remotes.hasOwnProperty(name)) {
      remotes[name] = {
        name,
        refs: { fetch: "", push: "" }
      };
    }
    if (purpose && url) {
      remotes[name].refs[purpose.replace(/[^a-z]/g, "")] = url;
    }
  });
  return Object.values(remotes);
}
function forEach(text, handler) {
  forEachLineWithContent(text, (line) => handler(line.split(/\s+/)));
}
var init_GetRemoteSummary = __esm({
  "src/lib/responses/GetRemoteSummary.ts"() {
    "use strict";
    init_utils();
  }
});
var remote_exports = {};
__export2(remote_exports, {
  addRemoteTask: () => addRemoteTask,
  getRemotesTask: () => getRemotesTask,
  listRemotesTask: () => listRemotesTask,
  remoteTask: () => remoteTask,
  removeRemoteTask: () => removeRemoteTask
});
function addRemoteTask(remoteName, remoteRepo, customArgs) {
  return straightThroughStringTask(["remote", "add", ...customArgs, remoteName, remoteRepo]);
}
function getRemotesTask(verbose) {
  const commands = ["remote"];
  if (verbose) {
    commands.push("-v");
  }
  return {
    commands,
    format: "utf-8",
    parser: verbose ? parseGetRemotesVerbose : parseGetRemotes
  };
}
function listRemotesTask(customArgs) {
  const commands = [...customArgs];
  if (commands[0] !== "ls-remote") {
    commands.unshift("ls-remote");
  }
  return straightThroughStringTask(commands);
}
function remoteTask(customArgs) {
  const commands = [...customArgs];
  if (commands[0] !== "remote") {
    commands.unshift("remote");
  }
  return straightThroughStringTask(commands);
}
function removeRemoteTask(remoteName) {
  return straightThroughStringTask(["remote", "remove", remoteName]);
}
var init_remote = __esm({
  "src/lib/tasks/remote.ts"() {
    "use strict";
    init_GetRemoteSummary();
    init_task();
  }
});
var stash_list_exports = {};
__export2(stash_list_exports, {
  stashListTask: () => stashListTask
});
function stashListTask(opt = {}, customArgs) {
  const options = parseLogOptions(opt);
  const commands = ["stash", "list", ...options.commands, ...customArgs];
  const parser4 = createListLogSummaryParser(
    options.splitter,
    options.fields,
    logFormatFromCommand(commands)
  );
  return validateLogFormatConfig(commands) || {
    commands,
    format: "utf-8",
    parser: parser4
  };
}
var init_stash_list = __esm({
  "src/lib/tasks/stash-list.ts"() {
    "use strict";
    init_log_format();
    init_parse_list_log_summary();
    init_diff();
    init_log();
  }
});
var sub_module_exports = {};
__export2(sub_module_exports, {
  addSubModuleTask: () => addSubModuleTask,
  initSubModuleTask: () => initSubModuleTask,
  subModuleTask: () => subModuleTask,
  updateSubModuleTask: () => updateSubModuleTask
});
function addSubModuleTask(repo, path) {
  return subModuleTask(["add", repo, path]);
}
function initSubModuleTask(customArgs) {
  return subModuleTask(["init", ...customArgs]);
}
function subModuleTask(customArgs) {
  const commands = [...customArgs];
  if (commands[0] !== "submodule") {
    commands.unshift("submodule");
  }
  return straightThroughStringTask(commands);
}
function updateSubModuleTask(customArgs) {
  return subModuleTask(["update", ...customArgs]);
}
var init_sub_module = __esm({
  "src/lib/tasks/sub-module.ts"() {
    "use strict";
    init_task();
  }
});
function singleSorted(a, b) {
  const aIsNum = isNaN(a);
  const bIsNum = isNaN(b);
  if (aIsNum !== bIsNum) {
    return aIsNum ? 1 : -1;
  }
  return aIsNum ? sorted(a, b) : 0;
}
function sorted(a, b) {
  return a === b ? 0 : a > b ? 1 : -1;
}
function trimmed(input) {
  return input.trim();
}
function toNumber(input) {
  if (typeof input === "string") {
    return parseInt(input.replace(/^\D+/g, ""), 10) || 0;
  }
  return 0;
}
var TagList;
var parseTagList;
var init_TagList = __esm({
  "src/lib/responses/TagList.ts"() {
    "use strict";
    TagList = class {
      constructor(all, latest) {
        this.all = all;
        this.latest = latest;
      }
    };
    parseTagList = function(data, customSort = false) {
      const tags = data.split("\n").map(trimmed).filter(Boolean);
      if (!customSort) {
        tags.sort(function(tagA, tagB) {
          const partsA = tagA.split(".");
          const partsB = tagB.split(".");
          if (partsA.length === 1 || partsB.length === 1) {
            return singleSorted(toNumber(partsA[0]), toNumber(partsB[0]));
          }
          for (let i = 0, l = Math.max(partsA.length, partsB.length); i < l; i++) {
            const diff = sorted(toNumber(partsA[i]), toNumber(partsB[i]));
            if (diff) {
              return diff;
            }
          }
          return 0;
        });
      }
      const latest = customSort ? tags[0] : [...tags].reverse().find((tag) => tag.indexOf(".") >= 0);
      return new TagList(tags, latest);
    };
  }
});
var tag_exports = {};
__export2(tag_exports, {
  addAnnotatedTagTask: () => addAnnotatedTagTask,
  addTagTask: () => addTagTask,
  tagListTask: () => tagListTask
});
function tagListTask(customArgs = []) {
  const hasCustomSort = customArgs.some((option) => /^--sort=/.test(option));
  return {
    format: "utf-8",
    commands: ["tag", "-l", ...customArgs],
    parser(text) {
      return parseTagList(text, hasCustomSort);
    }
  };
}
function addTagTask(name) {
  return {
    format: "utf-8",
    commands: ["tag", name],
    parser() {
      return { name };
    }
  };
}
function addAnnotatedTagTask(name, tagMessage) {
  return {
    format: "utf-8",
    commands: ["tag", "-a", "-m", tagMessage, name],
    parser() {
      return { name };
    }
  };
}
var init_tag = __esm({
  "src/lib/tasks/tag.ts"() {
    "use strict";
    init_TagList();
  }
});
var require_git = __commonJS2({
  "src/git.js"(exports, module2) {
    "use strict";
    var { GitExecutor: GitExecutor2 } = (init_git_executor(), __toCommonJS2(git_executor_exports));
    var { SimpleGitApi: SimpleGitApi2 } = (init_simple_git_api(), __toCommonJS2(simple_git_api_exports));
    var { Scheduler: Scheduler2 } = (init_scheduler(), __toCommonJS2(scheduler_exports));
    var { configurationErrorTask: configurationErrorTask2 } = (init_task(), __toCommonJS2(task_exports));
    var {
      asArray: asArray2,
      filterArray: filterArray2,
      filterPrimitives: filterPrimitives2,
      filterString: filterString2,
      filterStringOrStringArray: filterStringOrStringArray2,
      filterType: filterType2,
      getTrailingOptions: getTrailingOptions2,
      trailingFunctionArgument: trailingFunctionArgument2,
      trailingOptionsArgument: trailingOptionsArgument2
    } = (init_utils(), __toCommonJS2(utils_exports));
    var { applyPatchTask: applyPatchTask2 } = (init_apply_patch(), __toCommonJS2(apply_patch_exports));
    var {
      branchTask: branchTask2,
      branchLocalTask: branchLocalTask2,
      deleteBranchesTask: deleteBranchesTask2,
      deleteBranchTask: deleteBranchTask2
    } = (init_branch(), __toCommonJS2(branch_exports));
    var { checkIgnoreTask: checkIgnoreTask2 } = (init_check_ignore(), __toCommonJS2(check_ignore_exports));
    var { checkIsRepoTask: checkIsRepoTask2 } = (init_check_is_repo(), __toCommonJS2(check_is_repo_exports));
    var { cloneTask: cloneTask2, cloneMirrorTask: cloneMirrorTask2 } = (init_clone(), __toCommonJS2(clone_exports));
    var { cleanWithOptionsTask: cleanWithOptionsTask2, isCleanOptionsArray: isCleanOptionsArray2 } = (init_clean(), __toCommonJS2(clean_exports));
    var { diffSummaryTask: diffSummaryTask2 } = (init_diff(), __toCommonJS2(diff_exports));
    var { fetchTask: fetchTask2 } = (init_fetch(), __toCommonJS2(fetch_exports));
    var { moveTask: moveTask2 } = (init_move(), __toCommonJS2(move_exports));
    var { pullTask: pullTask2 } = (init_pull(), __toCommonJS2(pull_exports));
    var { pushTagsTask: pushTagsTask2 } = (init_push(), __toCommonJS2(push_exports));
    var {
      addRemoteTask: addRemoteTask2,
      getRemotesTask: getRemotesTask2,
      listRemotesTask: listRemotesTask2,
      remoteTask: remoteTask2,
      removeRemoteTask: removeRemoteTask2
    } = (init_remote(), __toCommonJS2(remote_exports));
    var { getResetMode: getResetMode2, resetTask: resetTask2 } = (init_reset(), __toCommonJS2(reset_exports));
    var { stashListTask: stashListTask2 } = (init_stash_list(), __toCommonJS2(stash_list_exports));
    var {
      addSubModuleTask: addSubModuleTask2,
      initSubModuleTask: initSubModuleTask2,
      subModuleTask: subModuleTask2,
      updateSubModuleTask: updateSubModuleTask2
    } = (init_sub_module(), __toCommonJS2(sub_module_exports));
    var { addAnnotatedTagTask: addAnnotatedTagTask2, addTagTask: addTagTask2, tagListTask: tagListTask2 } = (init_tag(), __toCommonJS2(tag_exports));
    var { straightThroughBufferTask: straightThroughBufferTask2, straightThroughStringTask: straightThroughStringTask2 } = (init_task(), __toCommonJS2(task_exports));
    function Git2(options, plugins) {
      this._plugins = plugins;
      this._executor = new GitExecutor2(
        options.baseDir,
        new Scheduler2(options.maxConcurrentProcesses),
        plugins
      );
      this._trimmed = options.trimmed;
    }
    (Git2.prototype = Object.create(SimpleGitApi2.prototype)).constructor = Git2;
    Git2.prototype.customBinary = function(command) {
      this._plugins.reconfigure("binary", command);
      return this;
    };
    Git2.prototype.env = function(name, value) {
      if (arguments.length === 1 && typeof name === "object") {
        this._executor.env = name;
      } else {
        (this._executor.env = this._executor.env || {})[name] = value;
      }
      return this;
    };
    Git2.prototype.stashList = function(options) {
      return this._runTask(
        stashListTask2(
          trailingOptionsArgument2(arguments) || {},
          filterArray2(options) && options || []
        ),
        trailingFunctionArgument2(arguments)
      );
    };
    function createCloneTask(api, task, repoPath, localPath) {
      if (typeof repoPath !== "string") {
        return configurationErrorTask2(`git.${api}() requires a string 'repoPath'`);
      }
      return task(repoPath, filterType2(localPath, filterString2), getTrailingOptions2(arguments));
    }
    Git2.prototype.clone = function() {
      return this._runTask(
        createCloneTask("clone", cloneTask2, ...arguments),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.mirror = function() {
      return this._runTask(
        createCloneTask("mirror", cloneMirrorTask2, ...arguments),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.mv = function(from, to) {
      return this._runTask(moveTask2(from, to), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.checkoutLatestTag = function(then) {
      var git = this;
      return this.pull(function() {
        git.tags(function(err, tags) {
          git.checkout(tags.latest, then);
        });
      });
    };
    Git2.prototype.pull = function(remote, branch, options, then) {
      return this._runTask(
        pullTask2(
          filterType2(remote, filterString2),
          filterType2(branch, filterString2),
          getTrailingOptions2(arguments)
        ),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.fetch = function(remote, branch) {
      return this._runTask(
        fetchTask2(
          filterType2(remote, filterString2),
          filterType2(branch, filterString2),
          getTrailingOptions2(arguments)
        ),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.silent = function(silence) {
      console.warn(
        "simple-git deprecation notice: git.silent: logging should be configured using the `debug` library / `DEBUG` environment variable, this will be an error in version 3"
      );
      return this;
    };
    Git2.prototype.tags = function(options, then) {
      return this._runTask(
        tagListTask2(getTrailingOptions2(arguments)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.rebase = function() {
      return this._runTask(
        straightThroughStringTask2(["rebase", ...getTrailingOptions2(arguments)]),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.reset = function(mode) {
      return this._runTask(
        resetTask2(getResetMode2(mode), getTrailingOptions2(arguments)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.revert = function(commit) {
      const next = trailingFunctionArgument2(arguments);
      if (typeof commit !== "string") {
        return this._runTask(configurationErrorTask2("Commit must be a string"), next);
      }
      return this._runTask(
        straightThroughStringTask2(["revert", ...getTrailingOptions2(arguments, 0, true), commit]),
        next
      );
    };
    Git2.prototype.addTag = function(name) {
      const task = typeof name === "string" ? addTagTask2(name) : configurationErrorTask2("Git.addTag requires a tag name");
      return this._runTask(task, trailingFunctionArgument2(arguments));
    };
    Git2.prototype.addAnnotatedTag = function(tagName, tagMessage) {
      return this._runTask(
        addAnnotatedTagTask2(tagName, tagMessage),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.deleteLocalBranch = function(branchName, forceDelete, then) {
      return this._runTask(
        deleteBranchTask2(branchName, typeof forceDelete === "boolean" ? forceDelete : false),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.deleteLocalBranches = function(branchNames, forceDelete, then) {
      return this._runTask(
        deleteBranchesTask2(branchNames, typeof forceDelete === "boolean" ? forceDelete : false),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.branch = function(options, then) {
      return this._runTask(
        branchTask2(getTrailingOptions2(arguments)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.branchLocal = function(then) {
      return this._runTask(branchLocalTask2(), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.raw = function(commands) {
      const createRestCommands = !Array.isArray(commands);
      const command = [].slice.call(createRestCommands ? arguments : commands, 0);
      for (let i = 0; i < command.length && createRestCommands; i++) {
        if (!filterPrimitives2(command[i])) {
          command.splice(i, command.length - i);
          break;
        }
      }
      command.push(...getTrailingOptions2(arguments, 0, true));
      var next = trailingFunctionArgument2(arguments);
      if (!command.length) {
        return this._runTask(
          configurationErrorTask2("Raw: must supply one or more command to execute"),
          next
        );
      }
      return this._runTask(straightThroughStringTask2(command, this._trimmed), next);
    };
    Git2.prototype.submoduleAdd = function(repo, path, then) {
      return this._runTask(addSubModuleTask2(repo, path), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.submoduleUpdate = function(args, then) {
      return this._runTask(
        updateSubModuleTask2(getTrailingOptions2(arguments, true)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.submoduleInit = function(args, then) {
      return this._runTask(
        initSubModuleTask2(getTrailingOptions2(arguments, true)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.subModule = function(options, then) {
      return this._runTask(
        subModuleTask2(getTrailingOptions2(arguments)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.listRemote = function() {
      return this._runTask(
        listRemotesTask2(getTrailingOptions2(arguments)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.addRemote = function(remoteName, remoteRepo, then) {
      return this._runTask(
        addRemoteTask2(remoteName, remoteRepo, getTrailingOptions2(arguments)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.removeRemote = function(remoteName, then) {
      return this._runTask(removeRemoteTask2(remoteName), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.getRemotes = function(verbose, then) {
      return this._runTask(getRemotesTask2(verbose === true), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.remote = function(options, then) {
      return this._runTask(
        remoteTask2(getTrailingOptions2(arguments)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.tag = function(options, then) {
      const command = getTrailingOptions2(arguments);
      if (command[0] !== "tag") {
        command.unshift("tag");
      }
      return this._runTask(straightThroughStringTask2(command), trailingFunctionArgument2(arguments));
    };
    Git2.prototype.updateServerInfo = function(then) {
      return this._runTask(
        straightThroughStringTask2(["update-server-info"]),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.pushTags = function(remote, then) {
      const task = pushTagsTask2(
        { remote: filterType2(remote, filterString2) },
        getTrailingOptions2(arguments)
      );
      return this._runTask(task, trailingFunctionArgument2(arguments));
    };
    Git2.prototype.rm = function(files) {
      return this._runTask(
        straightThroughStringTask2(["rm", "-f", ...asArray2(files)]),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.rmKeepLocal = function(files) {
      return this._runTask(
        straightThroughStringTask2(["rm", "--cached", ...asArray2(files)]),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.catFile = function(options, then) {
      return this._catFile("utf-8", arguments);
    };
    Git2.prototype.binaryCatFile = function() {
      return this._catFile("buffer", arguments);
    };
    Git2.prototype._catFile = function(format, args) {
      var handler = trailingFunctionArgument2(args);
      var command = ["cat-file"];
      var options = args[0];
      if (typeof options === "string") {
        return this._runTask(
          configurationErrorTask2("Git.catFile: options must be supplied as an array of strings"),
          handler
        );
      }
      if (Array.isArray(options)) {
        command.push.apply(command, options);
      }
      const task = format === "buffer" ? straightThroughBufferTask2(command) : straightThroughStringTask2(command);
      return this._runTask(task, handler);
    };
    Git2.prototype.diff = function(options, then) {
      const task = filterString2(options) ? configurationErrorTask2(
        "git.diff: supplying options as a single string is no longer supported, switch to an array of strings"
      ) : straightThroughStringTask2(["diff", ...getTrailingOptions2(arguments)]);
      return this._runTask(task, trailingFunctionArgument2(arguments));
    };
    Git2.prototype.diffSummary = function() {
      return this._runTask(
        diffSummaryTask2(getTrailingOptions2(arguments, 1)),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.applyPatch = function(patches) {
      const task = !filterStringOrStringArray2(patches) ? configurationErrorTask2(
        `git.applyPatch requires one or more string patches as the first argument`
      ) : applyPatchTask2(asArray2(patches), getTrailingOptions2([].slice.call(arguments, 1)));
      return this._runTask(task, trailingFunctionArgument2(arguments));
    };
    Git2.prototype.revparse = function() {
      const commands = ["rev-parse", ...getTrailingOptions2(arguments, true)];
      return this._runTask(
        straightThroughStringTask2(commands, true),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.clean = function(mode, options, then) {
      const usingCleanOptionsArray = isCleanOptionsArray2(mode);
      const cleanMode = usingCleanOptionsArray && mode.join("") || filterType2(mode, filterString2) || "";
      const customArgs = getTrailingOptions2([].slice.call(arguments, usingCleanOptionsArray ? 1 : 0));
      return this._runTask(
        cleanWithOptionsTask2(cleanMode, customArgs),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.exec = function(then) {
      const task = {
        commands: [],
        format: "utf-8",
        parser() {
          if (typeof then === "function") {
            then();
          }
        }
      };
      return this._runTask(task);
    };
    Git2.prototype.clearQueue = function() {
      return this;
    };
    Git2.prototype.checkIgnore = function(pathnames, then) {
      return this._runTask(
        checkIgnoreTask2(asArray2(filterType2(pathnames, filterStringOrStringArray2, []))),
        trailingFunctionArgument2(arguments)
      );
    };
    Git2.prototype.checkIsRepo = function(checkType, then) {
      return this._runTask(
        checkIsRepoTask2(filterType2(checkType, filterString2)),
        trailingFunctionArgument2(arguments)
      );
    };
    module2.exports = Git2;
  }
});
init_pathspec();
init_git_error();
var GitConstructError = class extends GitError {
  constructor(config, message) {
    super(void 0, message);
    this.config = config;
  }
};
init_git_error();
init_git_error();
var GitPluginError = class extends GitError {
  constructor(task, plugin, message) {
    super(task, message);
    this.task = task;
    this.plugin = plugin;
    Object.setPrototypeOf(this, new.target.prototype);
  }
};
init_git_response_error();
init_task_configuration_error();
init_check_is_repo();
init_clean();
init_config();
init_diff_name_status();
init_grep();
init_reset();
function abortPlugin(signal) {
  if (!signal) {
    return;
  }
  const onSpawnAfter = {
    type: "spawn.after",
    action(_data, context) {
      function kill() {
        context.kill(new GitPluginError(void 0, "abort", "Abort signal received"));
      }
      signal.addEventListener("abort", kill);
      context.spawned.on("close", () => signal.removeEventListener("abort", kill));
    }
  };
  const onSpawnBefore = {
    type: "spawn.before",
    action(_data, context) {
      if (signal.aborted) {
        context.kill(new GitPluginError(void 0, "abort", "Abort already signaled"));
      }
    }
  };
  return [onSpawnBefore, onSpawnAfter];
}
function isConfigSwitch(arg) {
  return typeof arg === "string" && arg.trim().toLowerCase() === "-c";
}
function preventProtocolOverride(arg, next) {
  if (!isConfigSwitch(arg)) {
    return;
  }
  if (!/^\s*protocol(.[a-z]+)?.allow/.test(next)) {
    return;
  }
  throw new GitPluginError(
    void 0,
    "unsafe",
    "Configuring protocol.allow is not permitted without enabling allowUnsafeExtProtocol"
  );
}
function preventUploadPack(arg, method) {
  if (/^\s*--(upload|receive)-pack/.test(arg)) {
    throw new GitPluginError(
      void 0,
      "unsafe",
      `Use of --upload-pack or --receive-pack is not permitted without enabling allowUnsafePack`
    );
  }
  if (method === "clone" && /^\s*-u\b/.test(arg)) {
    throw new GitPluginError(
      void 0,
      "unsafe",
      `Use of clone with option -u is not permitted without enabling allowUnsafePack`
    );
  }
  if (method === "push" && /^\s*--exec\b/.test(arg)) {
    throw new GitPluginError(
      void 0,
      "unsafe",
      `Use of push with option --exec is not permitted without enabling allowUnsafePack`
    );
  }
}
function blockUnsafeOperationsPlugin({
  allowUnsafeProtocolOverride = false,
  allowUnsafePack = false
} = {}) {
  return {
    type: "spawn.args",
    action(args, context) {
      args.forEach((current, index) => {
        const next = index < args.length ? args[index + 1] : "";
        allowUnsafeProtocolOverride || preventProtocolOverride(current, next);
        allowUnsafePack || preventUploadPack(current, context.method);
      });
      return args;
    }
  };
}
init_utils();
function commandConfigPrefixingPlugin(configuration) {
  const prefix = prefixedArray(configuration, "-c");
  return {
    type: "spawn.args",
    action(data) {
      return [...prefix, ...data];
    }
  };
}
init_utils();
var never = (0, import_promise_deferred2.deferred)().promise;
function completionDetectionPlugin({
  onClose = true,
  onExit = 50
} = {}) {
  function createEvents() {
    let exitCode = -1;
    const events = {
      close: (0, import_promise_deferred2.deferred)(),
      closeTimeout: (0, import_promise_deferred2.deferred)(),
      exit: (0, import_promise_deferred2.deferred)(),
      exitTimeout: (0, import_promise_deferred2.deferred)()
    };
    const result = Promise.race([
      onClose === false ? never : events.closeTimeout.promise,
      onExit === false ? never : events.exitTimeout.promise
    ]);
    configureTimeout(onClose, events.close, events.closeTimeout);
    configureTimeout(onExit, events.exit, events.exitTimeout);
    return {
      close(code) {
        exitCode = code;
        events.close.done();
      },
      exit(code) {
        exitCode = code;
        events.exit.done();
      },
      get exitCode() {
        return exitCode;
      },
      result
    };
  }
  function configureTimeout(flag, event, timeout) {
    if (flag === false) {
      return;
    }
    (flag === true ? event.promise : event.promise.then(() => delay(flag))).then(timeout.done);
  }
  return {
    type: "spawn.after",
    action(_0, _1) {
      return __async(this, arguments, function* (_data, { spawned, close }) {
        var _a3, _b;
        const events = createEvents();
        let deferClose = true;
        let quickClose = () => void (deferClose = false);
        (_a3 = spawned.stdout) == null ? void 0 : _a3.on("data", quickClose);
        (_b = spawned.stderr) == null ? void 0 : _b.on("data", quickClose);
        spawned.on("error", quickClose);
        spawned.on("close", (code) => events.close(code));
        spawned.on("exit", (code) => events.exit(code));
        try {
          yield events.result;
          if (deferClose) {
            yield delay(50);
          }
          close(events.exitCode);
        } catch (err) {
          close(events.exitCode, err);
        }
      });
    }
  };
}
init_utils();
var WRONG_NUMBER_ERR = `Invalid value supplied for custom binary, requires a single string or an array containing either one or two strings`;
var WRONG_CHARS_ERR = `Invalid value supplied for custom binary, restricted characters must be removed or supply the unsafe.allowUnsafeCustomBinary option`;
function isBadArgument(arg) {
  return !arg || !/^([a-z]:)?([a-z0-9/.\\_-]+)$/i.test(arg);
}
function toBinaryConfig(input, allowUnsafe) {
  if (input.length < 1 || input.length > 2) {
    throw new GitPluginError(void 0, "binary", WRONG_NUMBER_ERR);
  }
  const isBad = input.some(isBadArgument);
  if (isBad) {
    if (allowUnsafe) {
      console.warn(WRONG_CHARS_ERR);
    } else {
      throw new GitPluginError(void 0, "binary", WRONG_CHARS_ERR);
    }
  }
  const [binary, prefix] = input;
  return {
    binary,
    prefix
  };
}
function customBinaryPlugin(plugins, input = ["git"], allowUnsafe = false) {
  let config = toBinaryConfig(asArray(input), allowUnsafe);
  plugins.on("binary", (input2) => {
    config = toBinaryConfig(asArray(input2), allowUnsafe);
  });
  plugins.append("spawn.binary", () => {
    return config.binary;
  });
  plugins.append("spawn.args", (data) => {
    return config.prefix ? [config.prefix, ...data] : data;
  });
}
init_git_error();
function isTaskError(result) {
  return !!(result.exitCode && result.stdErr.length);
}
function getErrorMessage(result) {
  return Buffer.concat([...result.stdOut, ...result.stdErr]);
}
function errorDetectionHandler(overwrite = false, isError = isTaskError, errorMessage = getErrorMessage) {
  return (error, result) => {
    if (!overwrite && error || !isError(result)) {
      return error;
    }
    return errorMessage(result);
  };
}
function errorDetectionPlugin(config) {
  return {
    type: "task.error",
    action(data, context) {
      const error = config(data.error, {
        stdErr: context.stdErr,
        stdOut: context.stdOut,
        exitCode: context.exitCode
      });
      if (Buffer.isBuffer(error)) {
        return { error: new GitError(void 0, error.toString("utf-8")) };
      }
      return {
        error
      };
    }
  };
}
init_utils();
var PluginStore = class {
  constructor() {
    this.plugins = /* @__PURE__ */ new Set();
    this.events = new import_node_events.EventEmitter();
  }
  on(type, listener) {
    this.events.on(type, listener);
  }
  reconfigure(type, data) {
    this.events.emit(type, data);
  }
  append(type, action) {
    const plugin = append(this.plugins, { type, action });
    return () => this.plugins.delete(plugin);
  }
  add(plugin) {
    const plugins = [];
    asArray(plugin).forEach((plugin2) => plugin2 && this.plugins.add(append(plugins, plugin2)));
    return () => {
      plugins.forEach((plugin2) => this.plugins.delete(plugin2));
    };
  }
  exec(type, data, context) {
    let output = data;
    const contextual = Object.freeze(Object.create(context));
    for (const plugin of this.plugins) {
      if (plugin.type === type) {
        output = plugin.action(output, contextual);
      }
    }
    return output;
  }
};
init_utils();
function progressMonitorPlugin(progress) {
  const progressCommand = "--progress";
  const progressMethods = ["checkout", "clone", "fetch", "pull", "push"];
  const onProgress = {
    type: "spawn.after",
    action(_data, context) {
      var _a2;
      if (!context.commands.includes(progressCommand)) {
        return;
      }
      (_a2 = context.spawned.stderr) == null ? void 0 : _a2.on("data", (chunk) => {
        const message = /^([\s\S]+?):\s*(\d+)% \((\d+)\/(\d+)\)/.exec(chunk.toString("utf8"));
        if (!message) {
          return;
        }
        progress({
          method: context.method,
          stage: progressEventStage(message[1]),
          progress: asNumber(message[2]),
          processed: asNumber(message[3]),
          total: asNumber(message[4])
        });
      });
    }
  };
  const onArgs = {
    type: "spawn.args",
    action(args, context) {
      if (!progressMethods.includes(context.method)) {
        return args;
      }
      return including(args, progressCommand);
    }
  };
  return [onArgs, onProgress];
}
function progressEventStage(input) {
  return String(input.toLowerCase().split(" ", 1)) || "unknown";
}
init_utils();
function spawnOptionsPlugin(spawnOptions) {
  const options = pick(spawnOptions, ["uid", "gid"]);
  return {
    type: "spawn.options",
    action(data) {
      return __spreadValues(__spreadValues({}, options), data);
    }
  };
}
function timeoutPlugin({
  block,
  stdErr = true,
  stdOut = true
}) {
  if (block > 0) {
    return {
      type: "spawn.after",
      action(_data, context) {
        var _a2, _b;
        let timeout;
        function wait() {
          timeout && clearTimeout(timeout);
          timeout = setTimeout(kill, block);
        }
        function stop() {
          var _a3, _b2;
          (_a3 = context.spawned.stdout) == null ? void 0 : _a3.off("data", wait);
          (_b2 = context.spawned.stderr) == null ? void 0 : _b2.off("data", wait);
          context.spawned.off("exit", stop);
          context.spawned.off("close", stop);
          timeout && clearTimeout(timeout);
        }
        function kill() {
          stop();
          context.kill(new GitPluginError(void 0, "timeout", `block timeout reached`));
        }
        stdOut && ((_a2 = context.spawned.stdout) == null ? void 0 : _a2.on("data", wait));
        stdErr && ((_b = context.spawned.stderr) == null ? void 0 : _b.on("data", wait));
        context.spawned.on("exit", stop);
        context.spawned.on("close", stop);
        wait();
      }
    };
  }
}
init_pathspec();
function suffixPathsPlugin() {
  return {
    type: "spawn.args",
    action(data) {
      const prefix = [];
      let suffix;
      function append2(args) {
        (suffix = suffix || []).push(...args);
      }
      for (let i = 0; i < data.length; i++) {
        const param = data[i];
        if (isPathSpec(param)) {
          append2(toPaths(param));
          continue;
        }
        if (param === "--") {
          append2(
            data.slice(i + 1).flatMap((item) => isPathSpec(item) && toPaths(item) || item)
          );
          break;
        }
        prefix.push(param);
      }
      return !suffix ? prefix : [...prefix, "--", ...suffix.map(String)];
    }
  };
}
init_utils();
var Git = require_git();
function gitInstanceFactory(baseDir, options) {
  var _a2;
  const plugins = new PluginStore();
  const config = createInstanceConfig(
    baseDir && (typeof baseDir === "string" ? { baseDir } : baseDir) || {},
    options
  );
  if (!folderExists(config.baseDir)) {
    throw new GitConstructError(
      config,
      `Cannot use simple-git on a directory that does not exist`
    );
  }
  if (Array.isArray(config.config)) {
    plugins.add(commandConfigPrefixingPlugin(config.config));
  }
  plugins.add(blockUnsafeOperationsPlugin(config.unsafe));
  plugins.add(suffixPathsPlugin());
  plugins.add(completionDetectionPlugin(config.completion));
  config.abort && plugins.add(abortPlugin(config.abort));
  config.progress && plugins.add(progressMonitorPlugin(config.progress));
  config.timeout && plugins.add(timeoutPlugin(config.timeout));
  config.spawnOptions && plugins.add(spawnOptionsPlugin(config.spawnOptions));
  plugins.add(errorDetectionPlugin(errorDetectionHandler(true)));
  config.errors && plugins.add(errorDetectionPlugin(config.errors));
  customBinaryPlugin(plugins, config.binary, (_a2 = config.unsafe) == null ? void 0 : _a2.allowUnsafeCustomBinary);
  return new Git(config, plugins);
}
init_git_response_error();
var esm_default = gitInstanceFactory;

// main.ts
var DEFAULT_SETTINGS = {
  commitInterval: 15,
  // Default to 15 minutes
  repoUrl: "",
  authMethod: "ssh",
  autoSync: true,
  lastSync: "Never",
  commitMessage: "Vault auto-sync: {{date}}"
  // Customizable commit message with placeholder
};
var GitSyncPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.git = null;
    // For window.setInterval
    this.isSyncing = false;
    // Updated to handle TAbstractFile
    this.handleFileActivity = (file) => {
      if (!this.isSyncing) {
        this.updateStatusBar("Changes detected");
      }
      console.log(
        `Git Sync: File activity detected - ${file.path} (${file instanceof import_obsidian.TFile ? "file" : "folder"})`
      );
    };
  }
  // To prevent concurrent sync operations
  async onload() {
    console.log("Loading Git Sync plugin");
    await this.loadSettings();
    this.statusBarItemEl = this.addStatusBarItem();
    this.updateStatusBar("Idle");
    this.addSettingTab(new GitSyncSettingTab(this.app, this));
    this.initializeGit();
    if (this.settings.autoSync && this.git) {
      this.startAutoSync();
    }
    this.addCommand({
      id: "git-sync-now",
      name: "Sync with Remote",
      callback: () => {
        if (this.git) {
          this.syncVault();
        } else {
          new import_obsidian.Notice(
            "Git Sync: Repository not initialized or path not found. Check settings."
          );
          this.updateStatusBar("Error: Git not init");
        }
      }
    });
    this.registerEvent(this.app.vault.on("modify", this.handleFileActivity));
    this.registerEvent(this.app.vault.on("delete", this.handleFileActivity));
    this.registerEvent(this.app.vault.on("rename", this.handleFileActivity));
    if (this.settings.autoSync && this.settings.repoUrl) {
      console.log("Git Sync: Attempting initial sync on load.");
      this.syncVault().catch((error) => {
        console.error("Git Sync: Initial sync failed", error);
        new import_obsidian.Notice("Git Sync: Initial sync failed. Check console for details.");
        this.updateStatusBar("Initial Sync Failed");
      });
    }
  }
  onunload() {
    console.log("Unloading Git Sync plugin");
    this.stopAutoSync();
  }
  initializeGit() {
    const adapter = this.app.vault.adapter;
    if (adapter instanceof import_obsidian.FileSystemAdapter) {
      const basePath = adapter.getBasePath();
      console.log(`Git Sync: Initializing Git in ${basePath}`);
      this.git = esm_default({
        baseDir: basePath,
        binary: "git",
        // Ensure this points to user's git executable if not in PATH
        maxConcurrentProcesses: 6
      });
      this.git.version().then(
        (v) => console.log(
          `Git Sync: Git version ${v.major}.${v.minor}.${v.patch} initialized.`
        )
      ).catch((err) => {
        console.error(
          "Git Sync: Failed to initialize Git. Is Git installed and in PATH?",
          err
        );
        new import_obsidian.Notice(
          "Git Sync: Failed to initialize Git. Ensure Git is installed and in your system's PATH."
        );
        this.git = null;
        this.updateStatusBar("Error: Git init failed");
      });
    } else {
      console.error(
        "Git Sync: Vault is not on a local filesystem. Git Sync disabled."
      );
      new import_obsidian.Notice(
        "Git Sync: Vault must be on a local filesystem for Git Sync to work."
      );
      this.updateStatusBar("Error: Not local vault");
      this.git = null;
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  // --- Sync Logic ---
  async syncVault() {
    if (this.isSyncing) {
      new import_obsidian.Notice("Git Sync: Sync already in progress.");
      console.log("Git Sync: Sync already in progress, skipping.");
      return;
    }
    if (!this.git) {
      new import_obsidian.Notice(
        "Git Sync: Git is not initialized. Check plugin settings and console."
      );
      this.updateStatusBar("Error: Git not ready");
      this.initializeGit();
      if (!this.git)
        return;
    }
    if (!this.settings.repoUrl) {
      this.updateStatusBar("Error: Repo URL not set");
      new import_obsidian.Notice("Git Sync: Repository URL is not configured in settings.");
      return;
    }
    this.isSyncing = true;
    this.updateStatusBar("Syncing...");
    console.log("Git Sync: Starting vault synchronization.");
    try {
      console.log("Git Sync: Pulling from remote...");
      await this.git.pull({ "--rebase": "true", "--autostash": "true" }).catch(async (pullError) => {
        var _a2;
        if (pullError.message.includes("CONFLICT")) {
          console.warn(
            "Git Sync: Merge conflict after pull. Attempting to abort rebase."
          );
          new import_obsidian.Notice(
            "Git Sync: Merge conflict detected during pull. Please resolve manually."
          );
          try {
            await ((_a2 = this.git) == null ? void 0 : _a2.rebase({ "--abort": null }));
            new import_obsidian.Notice(
              "Git Sync: Rebase aborted. Please resolve conflicts and sync manually."
            );
          } catch (abortError) {
            console.error("Git Sync: Could not abort rebase.", abortError);
            new import_obsidian.Notice(
              "Git Sync: Critical! Could not abort rebase. Manual Git intervention required."
            );
          }
          throw new Error("Merge conflict during pull, rebase aborted.");
        }
        throw pullError;
      });
      console.log("Git Sync: Pull successful.");
      console.log("Git Sync: Adding files to staging...");
      await this.git.add("./*");
      const status = await this.git.status();
      const filesToCommit = status.files.filter(
        (file) => file.working_dir !== " " && file.working_dir !== "?"
      );
      if (filesToCommit.length > 0) {
        console.log(`Git Sync: Committing ${filesToCommit.length} changes.`);
        const commitMessage = this.settings.commitMessage.replace(
          "{{date}}",
          (0, import_obsidian.moment)().format("YYYY-MM-DD HH:mm:ss")
        );
        await this.git.commit(commitMessage);
        console.log("Git Sync: Commit successful.");
        console.log("Git Sync: Pushing to remote...");
        await this.git.push();
        console.log("Git Sync: Push successful.");
        this.settings.lastSync = (0, import_obsidian.moment)().format("YYYY-MM-DD HH:mm:ss");
        await this.saveSettings();
        this.updateStatusBar("Synced");
        new import_obsidian.Notice("Git Sync: Vault successfully synced with remote.");
      } else {
        this.settings.lastSync = (0, import_obsidian.moment)().format("YYYY-MM-DD HH:mm:ss");
        await this.saveSettings();
        this.updateStatusBar("No local changes");
        console.log("Git Sync: No local changes to commit.");
        new import_obsidian.Notice(
          "Git Sync: No local changes to commit. Vault is up-to-date with remote."
        );
      }
    } catch (error) {
      console.error("Git Sync: Synchronization error", error);
      this.handleSyncError(error);
    } finally {
      this.isSyncing = false;
      console.log("Git Sync: Synchronization attempt finished.");
    }
  }
  handleSyncError(error) {
    let errorMessage = "Git Sync: An unknown error occurred.";
    if (error.message) {
      if (error.message.includes("CONFLICT") || error.git && error.git.failed && error.git.message.includes("conflict")) {
        errorMessage = "Git Sync: Merge conflict detected. Please resolve it manually in your Git client.";
        this.updateStatusBar("Conflict!");
      } else if (error.message.includes("Host key verification failed") || error.message.includes("Permission denied")) {
        errorMessage = "Git Sync: Authentication failed. Check SSH keys or HTTPS credentials.";
        this.updateStatusBar("Auth Error");
      } else if (error.message.includes("not a git repository")) {
        errorMessage = "Git Sync: Vault is not a Git repository or .git folder is missing.";
        this.updateStatusBar("Not a repo");
      } else if (error.message.includes("Could not read from remote repository")) {
        errorMessage = "Git Sync: Cannot connect to remote. Check repository URL and network.";
        this.updateStatusBar("Remote Error");
      } else {
        errorMessage = `Git Sync: Error - ${error.message.substring(0, 100)}...`;
        this.updateStatusBar("Sync Error");
      }
    }
    new import_obsidian.Notice(errorMessage, 1e4);
    console.error("Git Sync Detailed Error:", error);
  }
  // --- Automation ---
  startAutoSync() {
    if (this.syncInterval)
      return;
    if (!this.git) {
      console.log("Git Sync: Auto Sync cannot start, Git not initialized.");
      return;
    }
    const intervalMillis = this.settings.commitInterval * 60 * 1e3;
    if (intervalMillis <= 0) {
      console.log(
        "Git Sync: Auto Sync interval is zero or negative, not starting."
      );
      return;
    }
    console.log(
      `Git Sync: Starting auto-sync every ${this.settings.commitInterval} minutes.`
    );
    this.syncInterval = window.setInterval(() => {
      console.log("Git Sync: Auto-sync triggered by interval.");
      this.syncVault();
    }, intervalMillis);
  }
  stopAutoSync() {
    if (this.syncInterval) {
      window.clearInterval(this.syncInterval);
      this.syncInterval = null;
      console.log("Git Sync: Auto-sync stopped.");
    }
  }
  // --- UI ---
  updateStatusBar(text) {
    if (this.statusBarItemEl) {
      this.statusBarItemEl.setText(`Git Sync: ${text}`);
    }
  }
};
var GitSyncSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Git Sync Settings" });
    containerEl.createEl("h3", { text: "General" });
    new import_obsidian.Setting(containerEl).setName("Enable Auto Sync").setDesc("Automatically sync your vault at the defined interval.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.autoSync).onChange(async (value) => {
        this.plugin.settings.autoSync = value;
        await this.plugin.saveSettings();
        if (value && this.plugin.git) {
          this.plugin.startAutoSync();
        } else {
          this.plugin.stopAutoSync();
        }
        this.display();
      })
    );
    if (this.plugin.settings.autoSync) {
      new import_obsidian.Setting(containerEl).setName("Sync Interval (minutes)").setDesc(
        "How often to automatically commit and push changes. Minimum 1 minute."
      ).addText(
        (text) => text.setPlaceholder("15").setValue(String(this.plugin.settings.commitInterval)).onChange(async (value) => {
          let numValue = Number(value);
          if (isNaN(numValue) || numValue < 1) {
            numValue = 1;
            new import_obsidian.Notice("Sync interval must be at least 1 minute.");
          }
          this.plugin.settings.commitInterval = numValue;
          await this.plugin.saveSettings();
          if (this.plugin.settings.autoSync) {
            this.plugin.stopAutoSync();
            this.plugin.startAutoSync();
          }
        })
      );
    }
    containerEl.createEl("h3", { text: "Repository" });
    new import_obsidian.Setting(containerEl).setName("Repository URL").setDesc(
      "The HTTPS or SSH URL of your remote Git repository (e.g., https://github.com/user/repo.git or git@github.com:user/repo.git)."
    ).addText(
      (text) => text.setPlaceholder("https://github.com/user/repo.git").setValue(this.plugin.settings.repoUrl).onChange(async (value) => {
        this.plugin.settings.repoUrl = value.trim();
        await this.plugin.saveSettings();
        this.plugin.initializeGit();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Commit Message").setDesc(
      "Customize the commit message. Use {{date}} for the current timestamp."
    ).addText(
      (text) => text.setPlaceholder(DEFAULT_SETTINGS.commitMessage).setValue(this.plugin.settings.commitMessage).onChange(async (value) => {
        this.plugin.settings.commitMessage = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Authentication Method").setDesc(
      "Git will typically use SSH for git@ URLs and HTTPS for https:// URLs. Ensure your Git client is configured."
    ).addDropdown(
      (dropdown) => dropdown.addOption("ssh", "SSH (git@example.com:...)").addOption("https", "HTTPS (https://example.com/...)").setValue(this.plugin.settings.authMethod).onChange(async (value) => {
        this.plugin.settings.authMethod = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Status & Actions" });
    const statusEl = containerEl.createEl("p", {
      text: `Last Sync: ${this.plugin.settings.lastSync}`
    });
    this.plugin.onExternalSettingsChange = () => {
      statusEl.setText(`Last Sync: ${this.plugin.settings.lastSync}`);
    };
    new import_obsidian.Setting(containerEl).setName("Manual Sync").setDesc("Trigger a synchronization cycle manually.").addButton(
      (button) => button.setButtonText("Sync Now").setCta().onClick(async () => {
        button.setDisabled(true);
        button.setButtonText("Syncing...");
        if (this.plugin.git) {
          await this.plugin.syncVault();
        } else {
          new import_obsidian.Notice(
            "Git Sync: Repository not initialized. Check settings."
          );
          this.plugin.updateStatusBar("Error: Git not init");
        }
        button.setDisabled(false);
        button.setButtonText("Sync Now");
        statusEl.setText(`Last Sync: ${this.plugin.settings.lastSync}`);
      })
    );
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzIiwgIm5vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsICJub2RlX21vZHVsZXMvaGFzLWZsYWcvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL3N1cHBvcnRzLWNvbG9yL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvbm9kZS5qcyIsICJub2RlX21vZHVsZXMvZGVidWcvc3JjL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9Aa3dzaXRlcy9maWxlLWV4aXN0cy9zcmMvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL0Brd3NpdGVzL2ZpbGUtZXhpc3RzL2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9Aa3dzaXRlcy9wcm9taXNlLWRlZmVycmVkL3NyYy9pbmRleC50cyIsICJtYWluLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvYXJncy9wYXRoc3BlYy50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL2Vycm9ycy9naXQtZXJyb3IudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9lcnJvcnMvZ2l0LXJlc3BvbnNlLWVycm9yLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvZXJyb3JzL3Rhc2stY29uZmlndXJhdGlvbi1lcnJvci50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3V0aWxzL3V0aWwudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi91dGlscy9hcmd1bWVudC1maWx0ZXJzLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdXRpbHMvZXhpdC1jb2Rlcy50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3V0aWxzL2dpdC1vdXRwdXQtc3RyZWFtcy50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3V0aWxzL2xpbmUtcGFyc2VyLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdXRpbHMvc2ltcGxlLWdpdC1vcHRpb25zLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdXRpbHMvdGFzay1vcHRpb25zLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdXRpbHMvdGFzay1wYXJzZXIudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi91dGlscy9pbmRleC50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL2NoZWNrLWlzLXJlcG8udHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9yZXNwb25zZXMvQ2xlYW5TdW1tYXJ5LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3MvdGFzay50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL2NsZWFuLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcmVzcG9uc2VzL0NvbmZpZ0xpc3QudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9jb25maWcudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9kaWZmLW5hbWUtc3RhdHVzLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3MvZ3JlcC50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL3Jlc2V0LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvZ2l0LWxvZ2dlci50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3J1bm5lcnMvdGFza3MtcGVuZGluZy1xdWV1ZS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3J1bm5lcnMvZ2l0LWV4ZWN1dG9yLWNoYWluLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcnVubmVycy9naXQtZXhlY3V0b3IudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrLWNhbGxiYWNrLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3MvY2hhbmdlLXdvcmtpbmctZGlyZWN0b3J5LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3MvY2hlY2tvdXQudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9jb3VudC1vYmplY3RzLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcGFyc2Vycy9wYXJzZS1jb21taXQudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9jb21taXQudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9maXJzdC1jb21taXQudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9oYXNoLW9iamVjdC50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Jlc3BvbnNlcy9Jbml0U3VtbWFyeS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL2luaXQudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9hcmdzL2xvZy1mb3JtYXQudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9yZXNwb25zZXMvRGlmZlN1bW1hcnkudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9wYXJzZXJzL3BhcnNlLWRpZmYtc3VtbWFyeS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BhcnNlcnMvcGFyc2UtbGlzdC1sb2ctc3VtbWFyeS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL2RpZmYudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9sb2cudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9yZXNwb25zZXMvTWVyZ2VTdW1tYXJ5LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcmVzcG9uc2VzL1B1bGxTdW1tYXJ5LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcGFyc2Vycy9wYXJzZS1yZW1vdGUtb2JqZWN0cy50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BhcnNlcnMvcGFyc2UtcmVtb3RlLW1lc3NhZ2VzLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcGFyc2Vycy9wYXJzZS1wdWxsLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcGFyc2Vycy9wYXJzZS1tZXJnZS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL21lcmdlLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcGFyc2Vycy9wYXJzZS1wdXNoLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3MvcHVzaC50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL3Nob3cudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9yZXNwb25zZXMvRmlsZVN0YXR1c1N1bW1hcnkudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9yZXNwb25zZXMvU3RhdHVzU3VtbWFyeS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL3N0YXR1cy50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL3ZlcnNpb24udHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9zaW1wbGUtZ2l0LWFwaS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3J1bm5lcnMvc2NoZWR1bGVyLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3MvYXBwbHktcGF0Y2gudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9yZXNwb25zZXMvQnJhbmNoRGVsZXRlU3VtbWFyeS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BhcnNlcnMvcGFyc2UtYnJhbmNoLWRlbGV0ZS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Jlc3BvbnNlcy9CcmFuY2hTdW1tYXJ5LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcGFyc2Vycy9wYXJzZS1icmFuY2gudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9icmFuY2gudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9yZXNwb25zZXMvQ2hlY2tJZ25vcmUudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9jaGVjay1pZ25vcmUudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9jbG9uZS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BhcnNlcnMvcGFyc2UtZmV0Y2gudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9mZXRjaC50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BhcnNlcnMvcGFyc2UtbW92ZS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Rhc2tzL21vdmUudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9wdWxsLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcmVzcG9uc2VzL0dldFJlbW90ZVN1bW1hcnkudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9yZW1vdGUudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi90YXNrcy9zdGFzaC1saXN0LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3Mvc3ViLW1vZHVsZS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3Jlc3BvbnNlcy9UYWdMaXN0LnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvdGFza3MvdGFnLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9naXQuanMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9hcGkudHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9lcnJvcnMvZ2l0LWNvbnN0cnVjdC1lcnJvci50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL2Vycm9ycy9naXQtcGx1Z2luLWVycm9yLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcGx1Z2lucy9hYm9ydC1wbHVnaW4udHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9wbHVnaW5zL2Jsb2NrLXVuc2FmZS1vcGVyYXRpb25zLXBsdWdpbi50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BsdWdpbnMvY29tbWFuZC1jb25maWctcHJlZml4aW5nLXBsdWdpbi50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BsdWdpbnMvY29tcGxldGlvbi1kZXRlY3Rpb24ucGx1Z2luLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcGx1Z2lucy9jdXN0b20tYmluYXJ5LnBsdWdpbi50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BsdWdpbnMvZXJyb3ItZGV0ZWN0aW9uLnBsdWdpbi50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BsdWdpbnMvcGx1Z2luLXN0b3JlLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9saWIvcGx1Z2lucy9wcm9ncmVzcy1tb25pdG9yLXBsdWdpbi50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3BsdWdpbnMvc3Bhd24tb3B0aW9ucy1wbHVnaW4udHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9wbHVnaW5zL3RpbW91dC1wbHVnaW4udHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9wbHVnaW5zL3N1ZmZpeC1wYXRocy5wbHVnaW4udHMiLCAibm9kZV9tb2R1bGVzL3NpbXBsZS1naXQvc3JjL2xpYi9naXQtZmFjdG9yeS50cyIsICJub2RlX21vZHVsZXMvc2ltcGxlLWdpdC9zcmMvbGliL3J1bm5lcnMvcHJvbWlzZS13cmFwcGVkLnRzIiwgIm5vZGVfbW9kdWxlcy9zaW1wbGUtZ2l0L3NyYy9lc20ubWpzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHcgPSBkICogNztcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbCkpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnd2Vla3MnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgIGNhc2UgJ3cnOlxuICAgICAgcmV0dXJuIG4gKiB3O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCAnbWludXRlJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICB9XG4gIHJldHVybiBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcbiAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArICcgJyArIG5hbWUgKyAoaXNQbHVyYWwgPyAncycgOiAnJyk7XG59XG4iLCAiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKi9cblxuZnVuY3Rpb24gc2V0dXAoZW52KSB7XG5cdGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmRlZmF1bHQgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuY29lcmNlID0gY29lcmNlO1xuXHRjcmVhdGVEZWJ1Zy5kaXNhYmxlID0gZGlzYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlID0gZW5hYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGVkID0gZW5hYmxlZDtcblx0Y3JlYXRlRGVidWcuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXHRjcmVhdGVEZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcblxuXHRPYmplY3Qua2V5cyhlbnYpLmZvckVhY2goa2V5ID0+IHtcblx0XHRjcmVhdGVEZWJ1Z1trZXldID0gZW52W2tleV07XG5cdH0pO1xuXG5cdC8qKlxuXHQqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuXHQqL1xuXG5cdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0LyoqXG5cdCogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuXHQqXG5cdCogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuXHQqL1xuXHRjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzID0ge307XG5cblx0LyoqXG5cdCogU2VsZWN0cyBhIGNvbG9yIGZvciBhIGRlYnVnIG5hbWVzcGFjZVxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgVGhlIG5hbWVzcGFjZSBzdHJpbmcgZm9yIHRoZSBkZWJ1ZyBpbnN0YW5jZSB0byBiZSBjb2xvcmVkXG5cdCogQHJldHVybiB7TnVtYmVyfFN0cmluZ30gQW4gQU5TSSBjb2xvciBjb2RlIGZvciB0aGUgZ2l2ZW4gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuXHRcdGxldCBoYXNoID0gMDtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXNwYWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcblx0XHRcdGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNyZWF0ZURlYnVnLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGNyZWF0ZURlYnVnLmNvbG9ycy5sZW5ndGhdO1xuXHR9XG5cdGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yID0gc2VsZWN0Q29sb3I7XG5cblx0LyoqXG5cdCogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQHJldHVybiB7RnVuY3Rpb259XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cdFx0bGV0IHByZXZUaW1lO1xuXHRcdGxldCBlbmFibGVPdmVycmlkZSA9IG51bGw7XG5cdFx0bGV0IG5hbWVzcGFjZXNDYWNoZTtcblx0XHRsZXQgZW5hYmxlZENhY2hlO1xuXG5cdFx0ZnVuY3Rpb24gZGVidWcoLi4uYXJncykge1xuXHRcdFx0Ly8gRGlzYWJsZWQ/XG5cdFx0XHRpZiAoIWRlYnVnLmVuYWJsZWQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzZWxmID0gZGVidWc7XG5cblx0XHRcdC8vIFNldCBgZGlmZmAgdGltZXN0YW1wXG5cdFx0XHRjb25zdCBjdXJyID0gTnVtYmVyKG5ldyBEYXRlKCkpO1xuXHRcdFx0Y29uc3QgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuXHRcdFx0c2VsZi5kaWZmID0gbXM7XG5cdFx0XHRzZWxmLnByZXYgPSBwcmV2VGltZTtcblx0XHRcdHNlbGYuY3VyciA9IGN1cnI7XG5cdFx0XHRwcmV2VGltZSA9IGN1cnI7XG5cblx0XHRcdGFyZ3NbMF0gPSBjcmVhdGVEZWJ1Zy5jb2VyY2UoYXJnc1swXSk7XG5cblx0XHRcdGlmICh0eXBlb2YgYXJnc1swXSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0Ly8gQW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cblx0XHRcdFx0YXJncy51bnNoaWZ0KCclTycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuXHRcdFx0bGV0IGluZGV4ID0gMDtcblx0XHRcdGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCAobWF0Y2gsIGZvcm1hdCkgPT4ge1xuXHRcdFx0XHQvLyBJZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG5cdFx0XHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0XHRcdHJldHVybiAnJSc7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0Y29uc3QgZm9ybWF0dGVyID0gY3JlYXRlRGVidWcuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXHRcdFx0XHRpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdGNvbnN0IHZhbCA9IGFyZ3NbaW5kZXhdO1xuXHRcdFx0XHRcdG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuXHRcdFx0XHRcdC8vIE5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcblx0XHRcdFx0XHRhcmdzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRcdFx0aW5kZXgtLTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcblx0XHRcdGNyZWF0ZURlYnVnLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuXHRcdFx0Y29uc3QgbG9nRm4gPSBzZWxmLmxvZyB8fCBjcmVhdGVEZWJ1Zy5sb2c7XG5cdFx0XHRsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcblx0XHR9XG5cblx0XHRkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cdFx0ZGVidWcudXNlQ29sb3JzID0gY3JlYXRlRGVidWcudXNlQ29sb3JzKCk7XG5cdFx0ZGVidWcuY29sb3IgPSBjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuXHRcdGRlYnVnLmV4dGVuZCA9IGV4dGVuZDtcblx0XHRkZWJ1Zy5kZXN0cm95ID0gY3JlYXRlRGVidWcuZGVzdHJveTsgLy8gWFhYIFRlbXBvcmFyeS4gV2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVidWcsICdlbmFibGVkJywge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG5cdFx0XHRnZXQ6ICgpID0+IHtcblx0XHRcdFx0aWYgKGVuYWJsZU92ZXJyaWRlICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVuYWJsZU92ZXJyaWRlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChuYW1lc3BhY2VzQ2FjaGUgIT09IGNyZWF0ZURlYnVnLm5hbWVzcGFjZXMpIHtcblx0XHRcdFx0XHRuYW1lc3BhY2VzQ2FjaGUgPSBjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzO1xuXHRcdFx0XHRcdGVuYWJsZWRDYWNoZSA9IGNyZWF0ZURlYnVnLmVuYWJsZWQobmFtZXNwYWNlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbmFibGVkQ2FjaGU7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiB2ID0+IHtcblx0XHRcdFx0ZW5hYmxlT3ZlcnJpZGUgPSB2O1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gRW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcblx0XHRpZiAodHlwZW9mIGNyZWF0ZURlYnVnLmluaXQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGNyZWF0ZURlYnVnLmluaXQoZGVidWcpO1xuXHRcdH1cblxuXHRcdHJldHVybiBkZWJ1Zztcblx0fVxuXG5cdGZ1bmN0aW9uIGV4dGVuZChuYW1lc3BhY2UsIGRlbGltaXRlcikge1xuXHRcdGNvbnN0IG5ld0RlYnVnID0gY3JlYXRlRGVidWcodGhpcy5uYW1lc3BhY2UgKyAodHlwZW9mIGRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnOicgOiBkZWxpbWl0ZXIpICsgbmFtZXNwYWNlKTtcblx0XHRuZXdEZWJ1Zy5sb2cgPSB0aGlzLmxvZztcblx0XHRyZXR1cm4gbmV3RGVidWc7XG5cdH1cblxuXHQvKipcblx0KiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG5cdCogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcblx0XHRjcmVhdGVEZWJ1Zy5zYXZlKG5hbWVzcGFjZXMpO1xuXHRcdGNyZWF0ZURlYnVnLm5hbWVzcGFjZXMgPSBuYW1lc3BhY2VzO1xuXG5cdFx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0XHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdFx0Y29uc3Qgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKVxuXHRcdFx0LnRyaW0oKVxuXHRcdFx0LnJlcGxhY2UoL1xccysvZywgJywnKVxuXHRcdFx0LnNwbGl0KCcsJylcblx0XHRcdC5maWx0ZXIoQm9vbGVhbik7XG5cblx0XHRmb3IgKGNvbnN0IG5zIG9mIHNwbGl0KSB7XG5cdFx0XHRpZiAobnNbMF0gPT09ICctJykge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5za2lwcy5wdXNoKG5zLnNsaWNlKDEpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLm5hbWVzLnB1c2gobnMpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgdGhlIGdpdmVuIHN0cmluZyBtYXRjaGVzIGEgbmFtZXNwYWNlIHRlbXBsYXRlLCBob25vcmluZ1xuXHQgKiBhc3Rlcmlza3MgYXMgd2lsZGNhcmRzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc2VhcmNoXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0ZW1wbGF0ZVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0ZnVuY3Rpb24gbWF0Y2hlc1RlbXBsYXRlKHNlYXJjaCwgdGVtcGxhdGUpIHtcblx0XHRsZXQgc2VhcmNoSW5kZXggPSAwO1xuXHRcdGxldCB0ZW1wbGF0ZUluZGV4ID0gMDtcblx0XHRsZXQgc3RhckluZGV4ID0gLTE7XG5cdFx0bGV0IG1hdGNoSW5kZXggPSAwO1xuXG5cdFx0d2hpbGUgKHNlYXJjaEluZGV4IDwgc2VhcmNoLmxlbmd0aCkge1xuXHRcdFx0aWYgKHRlbXBsYXRlSW5kZXggPCB0ZW1wbGF0ZS5sZW5ndGggJiYgKHRlbXBsYXRlW3RlbXBsYXRlSW5kZXhdID09PSBzZWFyY2hbc2VhcmNoSW5kZXhdIHx8IHRlbXBsYXRlW3RlbXBsYXRlSW5kZXhdID09PSAnKicpKSB7XG5cdFx0XHRcdC8vIE1hdGNoIGNoYXJhY3RlciBvciBwcm9jZWVkIHdpdGggd2lsZGNhcmRcblx0XHRcdFx0aWYgKHRlbXBsYXRlW3RlbXBsYXRlSW5kZXhdID09PSAnKicpIHtcblx0XHRcdFx0XHRzdGFySW5kZXggPSB0ZW1wbGF0ZUluZGV4O1xuXHRcdFx0XHRcdG1hdGNoSW5kZXggPSBzZWFyY2hJbmRleDtcblx0XHRcdFx0XHR0ZW1wbGF0ZUluZGV4Kys7IC8vIFNraXAgdGhlICcqJ1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNlYXJjaEluZGV4Kys7XG5cdFx0XHRcdFx0dGVtcGxhdGVJbmRleCsrO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHN0YXJJbmRleCAhPT0gLTEpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZWdhdGVkLWNvbmRpdGlvblxuXHRcdFx0XHQvLyBCYWNrdHJhY2sgdG8gdGhlIGxhc3QgJyonIGFuZCB0cnkgdG8gbWF0Y2ggbW9yZSBjaGFyYWN0ZXJzXG5cdFx0XHRcdHRlbXBsYXRlSW5kZXggPSBzdGFySW5kZXggKyAxO1xuXHRcdFx0XHRtYXRjaEluZGV4Kys7XG5cdFx0XHRcdHNlYXJjaEluZGV4ID0gbWF0Y2hJbmRleDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTsgLy8gTm8gbWF0Y2hcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBIYW5kbGUgdHJhaWxpbmcgJyonIGluIHRlbXBsYXRlXG5cdFx0d2hpbGUgKHRlbXBsYXRlSW5kZXggPCB0ZW1wbGF0ZS5sZW5ndGggJiYgdGVtcGxhdGVbdGVtcGxhdGVJbmRleF0gPT09ICcqJykge1xuXHRcdFx0dGVtcGxhdGVJbmRleCsrO1xuXHRcdH1cblxuXHRcdHJldHVybiB0ZW1wbGF0ZUluZGV4ID09PSB0ZW1wbGF0ZS5sZW5ndGg7XG5cdH1cblxuXHQvKipcblx0KiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cblx0KlxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGRpc2FibGUoKSB7XG5cdFx0Y29uc3QgbmFtZXNwYWNlcyA9IFtcblx0XHRcdC4uLmNyZWF0ZURlYnVnLm5hbWVzLFxuXHRcdFx0Li4uY3JlYXRlRGVidWcuc2tpcHMubWFwKG5hbWVzcGFjZSA9PiAnLScgKyBuYW1lc3BhY2UpXG5cdFx0XS5qb2luKCcsJyk7XG5cdFx0Y3JlYXRlRGVidWcuZW5hYmxlKCcnKTtcblx0XHRyZXR1cm4gbmFtZXNwYWNlcztcblx0fVxuXG5cdC8qKlxuXHQqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG5cdCogQHJldHVybiB7Qm9vbGVhbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcblx0XHRmb3IgKGNvbnN0IHNraXAgb2YgY3JlYXRlRGVidWcuc2tpcHMpIHtcblx0XHRcdGlmIChtYXRjaGVzVGVtcGxhdGUobmFtZSwgc2tpcCkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoY29uc3QgbnMgb2YgY3JlYXRlRGVidWcubmFtZXMpIHtcblx0XHRcdGlmIChtYXRjaGVzVGVtcGxhdGUobmFtZSwgbnMpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQqIENvZXJjZSBgdmFsYC5cblx0KlxuXHQqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuXHQqIEByZXR1cm4ge01peGVkfVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBjb2VyY2UodmFsKSB7XG5cdFx0aWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdFx0XHRyZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG5cblx0LyoqXG5cdCogWFhYIERPIE5PVCBVU0UuIFRoaXMgaXMgYSB0ZW1wb3Jhcnkgc3R1YiBmdW5jdGlvbi5cblx0KiBYWFggSXQgV0lMTCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5cdCovXG5cdGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG5cdFx0Y29uc29sZS53YXJuKCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJyk7XG5cdH1cblxuXHRjcmVhdGVEZWJ1Zy5lbmFibGUoY3JlYXRlRGVidWcubG9hZCgpKTtcblxuXHRyZXR1cm4gY3JlYXRlRGVidWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0dXA7XG4iLCAiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gbG9jYWxzdG9yYWdlKCk7XG5leHBvcnRzLmRlc3Ryb3kgPSAoKCkgPT4ge1xuXHRsZXQgd2FybmVkID0gZmFsc2U7XG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRpZiAoIXdhcm5lZCkge1xuXHRcdFx0d2FybmVkID0gdHJ1ZTtcblx0XHRcdGNvbnNvbGUud2FybignSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLicpO1xuXHRcdH1cblx0fTtcbn0pKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuXHQnIzAwMDBDQycsXG5cdCcjMDAwMEZGJyxcblx0JyMwMDMzQ0MnLFxuXHQnIzAwMzNGRicsXG5cdCcjMDA2NkNDJyxcblx0JyMwMDY2RkYnLFxuXHQnIzAwOTlDQycsXG5cdCcjMDA5OUZGJyxcblx0JyMwMENDMDAnLFxuXHQnIzAwQ0MzMycsXG5cdCcjMDBDQzY2Jyxcblx0JyMwMENDOTknLFxuXHQnIzAwQ0NDQycsXG5cdCcjMDBDQ0ZGJyxcblx0JyMzMzAwQ0MnLFxuXHQnIzMzMDBGRicsXG5cdCcjMzMzM0NDJyxcblx0JyMzMzMzRkYnLFxuXHQnIzMzNjZDQycsXG5cdCcjMzM2NkZGJyxcblx0JyMzMzk5Q0MnLFxuXHQnIzMzOTlGRicsXG5cdCcjMzNDQzAwJyxcblx0JyMzM0NDMzMnLFxuXHQnIzMzQ0M2NicsXG5cdCcjMzNDQzk5Jyxcblx0JyMzM0NDQ0MnLFxuXHQnIzMzQ0NGRicsXG5cdCcjNjYwMENDJyxcblx0JyM2NjAwRkYnLFxuXHQnIzY2MzNDQycsXG5cdCcjNjYzM0ZGJyxcblx0JyM2NkNDMDAnLFxuXHQnIzY2Q0MzMycsXG5cdCcjOTkwMENDJyxcblx0JyM5OTAwRkYnLFxuXHQnIzk5MzNDQycsXG5cdCcjOTkzM0ZGJyxcblx0JyM5OUNDMDAnLFxuXHQnIzk5Q0MzMycsXG5cdCcjQ0MwMDAwJyxcblx0JyNDQzAwMzMnLFxuXHQnI0NDMDA2NicsXG5cdCcjQ0MwMDk5Jyxcblx0JyNDQzAwQ0MnLFxuXHQnI0NDMDBGRicsXG5cdCcjQ0MzMzAwJyxcblx0JyNDQzMzMzMnLFxuXHQnI0NDMzM2NicsXG5cdCcjQ0MzMzk5Jyxcblx0JyNDQzMzQ0MnLFxuXHQnI0NDMzNGRicsXG5cdCcjQ0M2NjAwJyxcblx0JyNDQzY2MzMnLFxuXHQnI0NDOTkwMCcsXG5cdCcjQ0M5OTMzJyxcblx0JyNDQ0NDMDAnLFxuXHQnI0NDQ0MzMycsXG5cdCcjRkYwMDAwJyxcblx0JyNGRjAwMzMnLFxuXHQnI0ZGMDA2NicsXG5cdCcjRkYwMDk5Jyxcblx0JyNGRjAwQ0MnLFxuXHQnI0ZGMDBGRicsXG5cdCcjRkYzMzAwJyxcblx0JyNGRjMzMzMnLFxuXHQnI0ZGMzM2NicsXG5cdCcjRkYzMzk5Jyxcblx0JyNGRjMzQ0MnLFxuXHQnI0ZGMzNGRicsXG5cdCcjRkY2NjAwJyxcblx0JyNGRjY2MzMnLFxuXHQnI0ZGOTkwMCcsXG5cdCcjRkY5OTMzJyxcblx0JyNGRkNDMDAnLFxuXHQnI0ZGQ0MzMydcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcblx0Ly8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuXHQvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuXHQvLyBleHBsaWNpdGx5XG5cdGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiAod2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCB3aW5kb3cucHJvY2Vzcy5fX253anMpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXG5cdGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGVkZ2V8dHJpZGVudClcXC8oXFxkKykvKSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGxldCBtO1xuXG5cdC8vIElzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG5cdC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXR1cm4tYXNzaWduXG5cdHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxuXHRcdC8vIElzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcblx0XHQodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgKHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkpKSB8fFxuXHRcdC8vIElzIGZpcmVmb3ggPj0gdjMxP1xuXHRcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIChtID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykpICYmIHBhcnNlSW50KG1bMV0sIDEwKSA+PSAzMSkgfHxcblx0XHQvLyBEb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcblx0YXJnc1swXSA9ICh0aGlzLnVzZUNvbG9ycyA/ICclYycgOiAnJykgK1xuXHRcdHRoaXMubmFtZXNwYWNlICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnICVjJyA6ICcgJykgK1xuXHRcdGFyZ3NbMF0gK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICclYyAnIDogJyAnKSArXG5cdFx0JysnICsgbW9kdWxlLmV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuXHRpZiAoIXRoaXMudXNlQ29sb3JzKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Y29uc3QgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG5cdGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpO1xuXG5cdC8vIFRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG5cdC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cblx0Ly8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG5cdGxldCBpbmRleCA9IDA7XG5cdGxldCBsYXN0QyA9IDA7XG5cdGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBtYXRjaCA9PiB7XG5cdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGluZGV4Kys7XG5cdFx0aWYgKG1hdGNoID09PSAnJWMnKSB7XG5cdFx0XHQvLyBXZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcblx0XHRcdC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG5cdFx0XHRsYXN0QyA9IGluZGV4O1xuXHRcdH1cblx0fSk7XG5cblx0YXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUuZGVidWcoKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKiBJZiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGF2YWlsYWJsZSwgZmFsbHMgYmFja1xuICogdG8gYGNvbnNvbGUubG9nYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5leHBvcnRzLmxvZyA9IGNvbnNvbGUuZGVidWcgfHwgY29uc29sZS5sb2cgfHwgKCgpID0+IHt9KTtcblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuXHR0cnkge1xuXHRcdGlmIChuYW1lc3BhY2VzKSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2Uuc2V0SXRlbSgnZGVidWcnLCBuYW1lc3BhY2VzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBsb2FkKCkge1xuXHRsZXQgcjtcblx0dHJ5IHtcblx0XHRyID0gZXhwb3J0cy5zdG9yYWdlLmdldEl0ZW0oJ2RlYnVnJykgfHwgZXhwb3J0cy5zdG9yYWdlLmdldEl0ZW0oJ0RFQlVHJykgO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxuXG5cdC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcblx0aWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG5cdFx0ciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuXHR9XG5cblx0cmV0dXJuIHI7XG59XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuXHR0cnkge1xuXHRcdC8vIFRWTUxLaXQgKEFwcGxlIFRWIEpTIFJ1bnRpbWUpIGRvZXMgbm90IGhhdmUgYSB3aW5kb3cgb2JqZWN0LCBqdXN0IGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHRcblx0XHQvLyBUaGUgQnJvd3NlciBhbHNvIGhhcyBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0LlxuXHRcdHJldHVybiBsb2NhbFN0b3JhZ2U7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcblxuY29uc3Qge2Zvcm1hdHRlcnN9ID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uICh2KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnJvci5tZXNzYWdlO1xuXHR9XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSAoZmxhZywgYXJndiA9IHByb2Nlc3MuYXJndikgPT4ge1xuXHRjb25zdCBwcmVmaXggPSBmbGFnLnN0YXJ0c1dpdGgoJy0nKSA/ICcnIDogKGZsYWcubGVuZ3RoID09PSAxID8gJy0nIDogJy0tJyk7XG5cdGNvbnN0IHBvc2l0aW9uID0gYXJndi5pbmRleE9mKHByZWZpeCArIGZsYWcpO1xuXHRjb25zdCB0ZXJtaW5hdG9yUG9zaXRpb24gPSBhcmd2LmluZGV4T2YoJy0tJyk7XG5cdHJldHVybiBwb3NpdGlvbiAhPT0gLTEgJiYgKHRlcm1pbmF0b3JQb3NpdGlvbiA9PT0gLTEgfHwgcG9zaXRpb24gPCB0ZXJtaW5hdG9yUG9zaXRpb24pO1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5jb25zdCB0dHkgPSByZXF1aXJlKCd0dHknKTtcbmNvbnN0IGhhc0ZsYWcgPSByZXF1aXJlKCdoYXMtZmxhZycpO1xuXG5jb25zdCB7ZW52fSA9IHByb2Nlc3M7XG5cbmxldCBmb3JjZUNvbG9yO1xuaWYgKGhhc0ZsYWcoJ25vLWNvbG9yJykgfHxcblx0aGFzRmxhZygnbm8tY29sb3JzJykgfHxcblx0aGFzRmxhZygnY29sb3I9ZmFsc2UnKSB8fFxuXHRoYXNGbGFnKCdjb2xvcj1uZXZlcicpKSB7XG5cdGZvcmNlQ29sb3IgPSAwO1xufSBlbHNlIGlmIChoYXNGbGFnKCdjb2xvcicpIHx8XG5cdGhhc0ZsYWcoJ2NvbG9ycycpIHx8XG5cdGhhc0ZsYWcoJ2NvbG9yPXRydWUnKSB8fFxuXHRoYXNGbGFnKCdjb2xvcj1hbHdheXMnKSkge1xuXHRmb3JjZUNvbG9yID0gMTtcbn1cblxuaWYgKCdGT1JDRV9DT0xPUicgaW4gZW52KSB7XG5cdGlmIChlbnYuRk9SQ0VfQ09MT1IgPT09ICd0cnVlJykge1xuXHRcdGZvcmNlQ29sb3IgPSAxO1xuXHR9IGVsc2UgaWYgKGVudi5GT1JDRV9DT0xPUiA9PT0gJ2ZhbHNlJykge1xuXHRcdGZvcmNlQ29sb3IgPSAwO1xuXHR9IGVsc2Uge1xuXHRcdGZvcmNlQ29sb3IgPSBlbnYuRk9SQ0VfQ09MT1IubGVuZ3RoID09PSAwID8gMSA6IE1hdGgubWluKHBhcnNlSW50KGVudi5GT1JDRV9DT0xPUiwgMTApLCAzKTtcblx0fVxufVxuXG5mdW5jdGlvbiB0cmFuc2xhdGVMZXZlbChsZXZlbCkge1xuXHRpZiAobGV2ZWwgPT09IDApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGxldmVsLFxuXHRcdGhhc0Jhc2ljOiB0cnVlLFxuXHRcdGhhczI1NjogbGV2ZWwgPj0gMixcblx0XHRoYXMxNm06IGxldmVsID49IDNcblx0fTtcbn1cblxuZnVuY3Rpb24gc3VwcG9ydHNDb2xvcihoYXZlU3RyZWFtLCBzdHJlYW1Jc1RUWSkge1xuXHRpZiAoZm9yY2VDb2xvciA9PT0gMCkge1xuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0aWYgKGhhc0ZsYWcoJ2NvbG9yPTE2bScpIHx8XG5cdFx0aGFzRmxhZygnY29sb3I9ZnVsbCcpIHx8XG5cdFx0aGFzRmxhZygnY29sb3I9dHJ1ZWNvbG9yJykpIHtcblx0XHRyZXR1cm4gMztcblx0fVxuXG5cdGlmIChoYXNGbGFnKCdjb2xvcj0yNTYnKSkge1xuXHRcdHJldHVybiAyO1xuXHR9XG5cblx0aWYgKGhhdmVTdHJlYW0gJiYgIXN0cmVhbUlzVFRZICYmIGZvcmNlQ29sb3IgPT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0Y29uc3QgbWluID0gZm9yY2VDb2xvciB8fCAwO1xuXG5cdGlmIChlbnYuVEVSTSA9PT0gJ2R1bWInKSB7XG5cdFx0cmV0dXJuIG1pbjtcblx0fVxuXG5cdGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG5cdFx0Ly8gV2luZG93cyAxMCBidWlsZCAxMDU4NiBpcyB0aGUgZmlyc3QgV2luZG93cyByZWxlYXNlIHRoYXQgc3VwcG9ydHMgMjU2IGNvbG9ycy5cblx0XHQvLyBXaW5kb3dzIDEwIGJ1aWxkIDE0OTMxIGlzIHRoZSBmaXJzdCByZWxlYXNlIHRoYXQgc3VwcG9ydHMgMTZtL1RydWVDb2xvci5cblx0XHRjb25zdCBvc1JlbGVhc2UgPSBvcy5yZWxlYXNlKCkuc3BsaXQoJy4nKTtcblx0XHRpZiAoXG5cdFx0XHROdW1iZXIob3NSZWxlYXNlWzBdKSA+PSAxMCAmJlxuXHRcdFx0TnVtYmVyKG9zUmVsZWFzZVsyXSkgPj0gMTA1ODZcblx0XHQpIHtcblx0XHRcdHJldHVybiBOdW1iZXIob3NSZWxlYXNlWzJdKSA+PSAxNDkzMSA/IDMgOiAyO1xuXHRcdH1cblxuXHRcdHJldHVybiAxO1xuXHR9XG5cblx0aWYgKCdDSScgaW4gZW52KSB7XG5cdFx0aWYgKFsnVFJBVklTJywgJ0NJUkNMRUNJJywgJ0FQUFZFWU9SJywgJ0dJVExBQl9DSScsICdHSVRIVUJfQUNUSU9OUycsICdCVUlMREtJVEUnXS5zb21lKHNpZ24gPT4gc2lnbiBpbiBlbnYpIHx8IGVudi5DSV9OQU1FID09PSAnY29kZXNoaXAnKSB7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWluO1xuXHR9XG5cblx0aWYgKCdURUFNQ0lUWV9WRVJTSU9OJyBpbiBlbnYpIHtcblx0XHRyZXR1cm4gL14oOVxcLigwKlsxLTldXFxkKilcXC58XFxkezIsfVxcLikvLnRlc3QoZW52LlRFQU1DSVRZX1ZFUlNJT04pID8gMSA6IDA7XG5cdH1cblxuXHRpZiAoZW52LkNPTE9SVEVSTSA9PT0gJ3RydWVjb2xvcicpIHtcblx0XHRyZXR1cm4gMztcblx0fVxuXG5cdGlmICgnVEVSTV9QUk9HUkFNJyBpbiBlbnYpIHtcblx0XHRjb25zdCB2ZXJzaW9uID0gcGFyc2VJbnQoKGVudi5URVJNX1BST0dSQU1fVkVSU0lPTiB8fCAnJykuc3BsaXQoJy4nKVswXSwgMTApO1xuXG5cdFx0c3dpdGNoIChlbnYuVEVSTV9QUk9HUkFNKSB7XG5cdFx0XHRjYXNlICdpVGVybS5hcHAnOlxuXHRcdFx0XHRyZXR1cm4gdmVyc2lvbiA+PSAzID8gMyA6IDI7XG5cdFx0XHRjYXNlICdBcHBsZV9UZXJtaW5hbCc6XG5cdFx0XHRcdHJldHVybiAyO1xuXHRcdFx0Ly8gTm8gZGVmYXVsdFxuXHRcdH1cblx0fVxuXG5cdGlmICgvLTI1Nihjb2xvcik/JC9pLnRlc3QoZW52LlRFUk0pKSB7XG5cdFx0cmV0dXJuIDI7XG5cdH1cblxuXHRpZiAoL15zY3JlZW58Xnh0ZXJtfF52dDEwMHxednQyMjB8XnJ4dnR8Y29sb3J8YW5zaXxjeWd3aW58bGludXgvaS50ZXN0KGVudi5URVJNKSkge1xuXHRcdHJldHVybiAxO1xuXHR9XG5cblx0aWYgKCdDT0xPUlRFUk0nIGluIGVudikge1xuXHRcdHJldHVybiAxO1xuXHR9XG5cblx0cmV0dXJuIG1pbjtcbn1cblxuZnVuY3Rpb24gZ2V0U3VwcG9ydExldmVsKHN0cmVhbSkge1xuXHRjb25zdCBsZXZlbCA9IHN1cHBvcnRzQ29sb3Ioc3RyZWFtLCBzdHJlYW0gJiYgc3RyZWFtLmlzVFRZKTtcblx0cmV0dXJuIHRyYW5zbGF0ZUxldmVsKGxldmVsKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdHN1cHBvcnRzQ29sb3I6IGdldFN1cHBvcnRMZXZlbCxcblx0c3Rkb3V0OiB0cmFuc2xhdGVMZXZlbChzdXBwb3J0c0NvbG9yKHRydWUsIHR0eS5pc2F0dHkoMSkpKSxcblx0c3RkZXJyOiB0cmFuc2xhdGVMZXZlbChzdXBwb3J0c0NvbG9yKHRydWUsIHR0eS5pc2F0dHkoMikpKVxufTtcbiIsICIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgdHR5ID0gcmVxdWlyZSgndHR5Jyk7XG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIE5vZGUuanMgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICovXG5cbmV4cG9ydHMuaW5pdCA9IGluaXQ7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5kZXN0cm95ID0gdXRpbC5kZXByZWNhdGUoXG5cdCgpID0+IHt9LFxuXHQnSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLidcbik7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gWzYsIDIsIDMsIDQsIDUsIDFdO1xuXG50cnkge1xuXHQvLyBPcHRpb25hbCBkZXBlbmRlbmN5IChhcyBpbiwgZG9lc24ndCBuZWVkIHRvIGJlIGluc3RhbGxlZCwgTk9UIGxpa2Ugb3B0aW9uYWxEZXBlbmRlbmNpZXMgaW4gcGFja2FnZS5qc29uKVxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG5cdGNvbnN0IHN1cHBvcnRzQ29sb3IgPSByZXF1aXJlKCdzdXBwb3J0cy1jb2xvcicpO1xuXG5cdGlmIChzdXBwb3J0c0NvbG9yICYmIChzdXBwb3J0c0NvbG9yLnN0ZGVyciB8fCBzdXBwb3J0c0NvbG9yKS5sZXZlbCA+PSAyKSB7XG5cdFx0ZXhwb3J0cy5jb2xvcnMgPSBbXG5cdFx0XHQyMCxcblx0XHRcdDIxLFxuXHRcdFx0MjYsXG5cdFx0XHQyNyxcblx0XHRcdDMyLFxuXHRcdFx0MzMsXG5cdFx0XHQzOCxcblx0XHRcdDM5LFxuXHRcdFx0NDAsXG5cdFx0XHQ0MSxcblx0XHRcdDQyLFxuXHRcdFx0NDMsXG5cdFx0XHQ0NCxcblx0XHRcdDQ1LFxuXHRcdFx0NTYsXG5cdFx0XHQ1Nyxcblx0XHRcdDYyLFxuXHRcdFx0NjMsXG5cdFx0XHQ2OCxcblx0XHRcdDY5LFxuXHRcdFx0NzQsXG5cdFx0XHQ3NSxcblx0XHRcdDc2LFxuXHRcdFx0NzcsXG5cdFx0XHQ3OCxcblx0XHRcdDc5LFxuXHRcdFx0ODAsXG5cdFx0XHQ4MSxcblx0XHRcdDkyLFxuXHRcdFx0OTMsXG5cdFx0XHQ5OCxcblx0XHRcdDk5LFxuXHRcdFx0MTEyLFxuXHRcdFx0MTEzLFxuXHRcdFx0MTI4LFxuXHRcdFx0MTI5LFxuXHRcdFx0MTM0LFxuXHRcdFx0MTM1LFxuXHRcdFx0MTQ4LFxuXHRcdFx0MTQ5LFxuXHRcdFx0MTYwLFxuXHRcdFx0MTYxLFxuXHRcdFx0MTYyLFxuXHRcdFx0MTYzLFxuXHRcdFx0MTY0LFxuXHRcdFx0MTY1LFxuXHRcdFx0MTY2LFxuXHRcdFx0MTY3LFxuXHRcdFx0MTY4LFxuXHRcdFx0MTY5LFxuXHRcdFx0MTcwLFxuXHRcdFx0MTcxLFxuXHRcdFx0MTcyLFxuXHRcdFx0MTczLFxuXHRcdFx0MTc4LFxuXHRcdFx0MTc5LFxuXHRcdFx0MTg0LFxuXHRcdFx0MTg1LFxuXHRcdFx0MTk2LFxuXHRcdFx0MTk3LFxuXHRcdFx0MTk4LFxuXHRcdFx0MTk5LFxuXHRcdFx0MjAwLFxuXHRcdFx0MjAxLFxuXHRcdFx0MjAyLFxuXHRcdFx0MjAzLFxuXHRcdFx0MjA0LFxuXHRcdFx0MjA1LFxuXHRcdFx0MjA2LFxuXHRcdFx0MjA3LFxuXHRcdFx0MjA4LFxuXHRcdFx0MjA5LFxuXHRcdFx0MjE0LFxuXHRcdFx0MjE1LFxuXHRcdFx0MjIwLFxuXHRcdFx0MjIxXG5cdFx0XTtcblx0fVxufSBjYXRjaCAoZXJyb3IpIHtcblx0Ly8gU3dhbGxvdyAtIHdlIG9ubHkgY2FyZSBpZiBgc3VwcG9ydHMtY29sb3JgIGlzIGF2YWlsYWJsZTsgaXQgZG9lc24ndCBoYXZlIHRvIGJlLlxufVxuXG4vKipcbiAqIEJ1aWxkIHVwIHRoZSBkZWZhdWx0IGBpbnNwZWN0T3B0c2Agb2JqZWN0IGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqXG4gKiAgICQgREVCVUdfQ09MT1JTPW5vIERFQlVHX0RFUFRIPTEwIERFQlVHX1NIT1dfSElEREVOPWVuYWJsZWQgbm9kZSBzY3JpcHQuanNcbiAqL1xuXG5leHBvcnRzLmluc3BlY3RPcHRzID0gT2JqZWN0LmtleXMocHJvY2Vzcy5lbnYpLmZpbHRlcihrZXkgPT4ge1xuXHRyZXR1cm4gL15kZWJ1Z18vaS50ZXN0KGtleSk7XG59KS5yZWR1Y2UoKG9iaiwga2V5KSA9PiB7XG5cdC8vIENhbWVsLWNhc2Vcblx0Y29uc3QgcHJvcCA9IGtleVxuXHRcdC5zdWJzdHJpbmcoNilcblx0XHQudG9Mb3dlckNhc2UoKVxuXHRcdC5yZXBsYWNlKC9fKFthLXpdKS9nLCAoXywgaykgPT4ge1xuXHRcdFx0cmV0dXJuIGsudG9VcHBlckNhc2UoKTtcblx0XHR9KTtcblxuXHQvLyBDb2VyY2Ugc3RyaW5nIHZhbHVlIGludG8gSlMgdmFsdWVcblx0bGV0IHZhbCA9IHByb2Nlc3MuZW52W2tleV07XG5cdGlmICgvXih5ZXN8b258dHJ1ZXxlbmFibGVkKSQvaS50ZXN0KHZhbCkpIHtcblx0XHR2YWwgPSB0cnVlO1xuXHR9IGVsc2UgaWYgKC9eKG5vfG9mZnxmYWxzZXxkaXNhYmxlZCkkL2kudGVzdCh2YWwpKSB7XG5cdFx0dmFsID0gZmFsc2U7XG5cdH0gZWxzZSBpZiAodmFsID09PSAnbnVsbCcpIHtcblx0XHR2YWwgPSBudWxsO1xuXHR9IGVsc2Uge1xuXHRcdHZhbCA9IE51bWJlcih2YWwpO1xuXHR9XG5cblx0b2JqW3Byb3BdID0gdmFsO1xuXHRyZXR1cm4gb2JqO1xufSwge30pO1xuXG4vKipcbiAqIElzIHN0ZG91dCBhIFRUWT8gQ29sb3JlZCBvdXRwdXQgaXMgZW5hYmxlZCB3aGVuIGB0cnVlYC5cbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG5cdHJldHVybiAnY29sb3JzJyBpbiBleHBvcnRzLmluc3BlY3RPcHRzID9cblx0XHRCb29sZWFuKGV4cG9ydHMuaW5zcGVjdE9wdHMuY29sb3JzKSA6XG5cdFx0dHR5LmlzYXR0eShwcm9jZXNzLnN0ZGVyci5mZCk7XG59XG5cbi8qKlxuICogQWRkcyBBTlNJIGNvbG9yIGVzY2FwZSBjb2RlcyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG5cdGNvbnN0IHtuYW1lc3BhY2U6IG5hbWUsIHVzZUNvbG9yc30gPSB0aGlzO1xuXG5cdGlmICh1c2VDb2xvcnMpIHtcblx0XHRjb25zdCBjID0gdGhpcy5jb2xvcjtcblx0XHRjb25zdCBjb2xvckNvZGUgPSAnXFx1MDAxQlszJyArIChjIDwgOCA/IGMgOiAnODs1OycgKyBjKTtcblx0XHRjb25zdCBwcmVmaXggPSBgICAke2NvbG9yQ29kZX07MW0ke25hbWV9IFxcdTAwMUJbMG1gO1xuXG5cdFx0YXJnc1swXSA9IHByZWZpeCArIGFyZ3NbMF0uc3BsaXQoJ1xcbicpLmpvaW4oJ1xcbicgKyBwcmVmaXgpO1xuXHRcdGFyZ3MucHVzaChjb2xvckNvZGUgKyAnbSsnICsgbW9kdWxlLmV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKSArICdcXHUwMDFCWzBtJyk7XG5cdH0gZWxzZSB7XG5cdFx0YXJnc1swXSA9IGdldERhdGUoKSArIG5hbWUgKyAnICcgKyBhcmdzWzBdO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGdldERhdGUoKSB7XG5cdGlmIChleHBvcnRzLmluc3BlY3RPcHRzLmhpZGVEYXRlKSB7XG5cdFx0cmV0dXJuICcnO1xuXHR9XG5cdHJldHVybiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgKyAnICc7XG59XG5cbi8qKlxuICogSW52b2tlcyBgdXRpbC5mb3JtYXRXaXRoT3B0aW9ucygpYCB3aXRoIHRoZSBzcGVjaWZpZWQgYXJndW1lbnRzIGFuZCB3cml0ZXMgdG8gc3RkZXJyLlxuICovXG5cbmZ1bmN0aW9uIGxvZyguLi5hcmdzKSB7XG5cdHJldHVybiBwcm9jZXNzLnN0ZGVyci53cml0ZSh1dGlsLmZvcm1hdFdpdGhPcHRpb25zKGV4cG9ydHMuaW5zcGVjdE9wdHMsIC4uLmFyZ3MpICsgJ1xcbicpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG5cdGlmIChuYW1lc3BhY2VzKSB7XG5cdFx0cHJvY2Vzcy5lbnYuREVCVUcgPSBuYW1lc3BhY2VzO1xuXHR9IGVsc2Uge1xuXHRcdC8vIElmIHlvdSBzZXQgYSBwcm9jZXNzLmVudiBmaWVsZCB0byBudWxsIG9yIHVuZGVmaW5lZCwgaXQgZ2V0cyBjYXN0IHRvIHRoZVxuXHRcdC8vIHN0cmluZyAnbnVsbCcgb3IgJ3VuZGVmaW5lZCcuIEp1c3QgZGVsZXRlIGluc3RlYWQuXG5cdFx0ZGVsZXRlIHByb2Nlc3MuZW52LkRFQlVHO1xuXHR9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcblx0cmV0dXJuIHByb2Nlc3MuZW52LkRFQlVHO1xufVxuXG4vKipcbiAqIEluaXQgbG9naWMgZm9yIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuICpcbiAqIENyZWF0ZSBhIG5ldyBgaW5zcGVjdE9wdHNgIG9iamVjdCBpbiBjYXNlIGB1c2VDb2xvcnNgIGlzIHNldFxuICogZGlmZmVyZW50bHkgZm9yIGEgcGFydGljdWxhciBgZGVidWdgIGluc3RhbmNlLlxuICovXG5cbmZ1bmN0aW9uIGluaXQoZGVidWcpIHtcblx0ZGVidWcuaW5zcGVjdE9wdHMgPSB7fTtcblxuXHRjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZXhwb3J0cy5pbnNwZWN0T3B0cyk7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdGRlYnVnLmluc3BlY3RPcHRzW2tleXNbaV1dID0gZXhwb3J0cy5pbnNwZWN0T3B0c1trZXlzW2ldXTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29tbW9uJykoZXhwb3J0cyk7XG5cbmNvbnN0IHtmb3JtYXR0ZXJzfSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKipcbiAqIE1hcCAlbyB0byBgdXRpbC5pbnNwZWN0KClgLCBhbGwgb24gYSBzaW5nbGUgbGluZS5cbiAqL1xuXG5mb3JtYXR0ZXJzLm8gPSBmdW5jdGlvbiAodikge1xuXHR0aGlzLmluc3BlY3RPcHRzLmNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXHRyZXR1cm4gdXRpbC5pbnNwZWN0KHYsIHRoaXMuaW5zcGVjdE9wdHMpXG5cdFx0LnNwbGl0KCdcXG4nKVxuXHRcdC5tYXAoc3RyID0+IHN0ci50cmltKCkpXG5cdFx0LmpvaW4oJyAnKTtcbn07XG5cbi8qKlxuICogTWFwICVPIHRvIGB1dGlsLmluc3BlY3QoKWAsIGFsbG93aW5nIG11bHRpcGxlIGxpbmVzIGlmIG5lZWRlZC5cbiAqL1xuXG5mb3JtYXR0ZXJzLk8gPSBmdW5jdGlvbiAodikge1xuXHR0aGlzLmluc3BlY3RPcHRzLmNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXHRyZXR1cm4gdXRpbC5pbnNwZWN0KHYsIHRoaXMuaW5zcGVjdE9wdHMpO1xufTtcbiIsICIvKipcbiAqIERldGVjdCBFbGVjdHJvbiByZW5kZXJlciAvIG53anMgcHJvY2Vzcywgd2hpY2ggaXMgbm9kZSwgYnV0IHdlIHNob3VsZFxuICogdHJlYXQgYXMgYSBicm93c2VyLlxuICovXG5cbmlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInIHx8IHByb2Nlc3MuYnJvd3NlciA9PT0gdHJ1ZSB8fCBwcm9jZXNzLl9fbndqcykge1xuXHRtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vYnJvd3Nlci5qcycpO1xufSBlbHNlIHtcblx0bW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL25vZGUuanMnKTtcbn1cbiIsIG51bGwsIG51bGwsIG51bGwsICJpbXBvcnQge1xuICBBcHAsXG4gIFBsdWdpbixcbiAgUGx1Z2luU2V0dGluZ1RhYixcbiAgU2V0dGluZyxcbiAgVEZpbGUsXG4gIG1vbWVudCxcbiAgRmlsZVN5c3RlbUFkYXB0ZXIsXG4gIFRBYnN0cmFjdEZpbGUsXG4gIE5vdGljZSxcbn0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgc2ltcGxlR2l0LCB7IFNpbXBsZUdpdCwgU3RhdHVzUmVzdWx0IH0gZnJvbSBcInNpbXBsZS1naXRcIjtcblxuLy8gU2V0dGluZ3MgSW50ZXJmYWNlXG5pbnRlcmZhY2UgR2l0U3luY1NldHRpbmdzIHtcbiAgY29tbWl0SW50ZXJ2YWw6IG51bWJlcjsgLy8gaW4gbWludXRlc1xuICByZXBvVXJsOiBzdHJpbmc7XG4gIGF1dGhNZXRob2Q6IFwic3NoXCIgfCBcImh0dHBzXCI7IC8vIEFzc3VtaW5nIHRoZXNlIGFyZSB0aGUgcHJpbWFyeSBtZXRob2RzIHlvdSdsbCBzdXBwb3J0IGluaXRpYWxseVxuICBhdXRvU3luYzogYm9vbGVhbjtcbiAgbGFzdFN5bmM6IHN0cmluZztcbiAgY29tbWl0TWVzc2FnZTogc3RyaW5nO1xufVxuXG4vLyBEZWZhdWx0IFNldHRpbmdzXG5jb25zdCBERUZBVUxUX1NFVFRJTkdTOiBHaXRTeW5jU2V0dGluZ3MgPSB7XG4gIGNvbW1pdEludGVydmFsOiAxNSwgLy8gRGVmYXVsdCB0byAxNSBtaW51dGVzXG4gIHJlcG9Vcmw6IFwiXCIsXG4gIGF1dGhNZXRob2Q6IFwic3NoXCIsXG4gIGF1dG9TeW5jOiB0cnVlLFxuICBsYXN0U3luYzogXCJOZXZlclwiLFxuICBjb21taXRNZXNzYWdlOiBcIlZhdWx0IGF1dG8tc3luYzoge3tkYXRlfX1cIiwgLy8gQ3VzdG9taXphYmxlIGNvbW1pdCBtZXNzYWdlIHdpdGggcGxhY2Vob2xkZXJcbn07XG5cbi8vIE1haW4gUGx1Z2luIENsYXNzXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHaXRTeW5jUGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcbiAgc2V0dGluZ3M6IEdpdFN5bmNTZXR0aW5ncztcbiAgZ2l0OiBTaW1wbGVHaXQgfCBudWxsID0gbnVsbDsgLy8gSW5pdGlhbGl6ZSBhcyBudWxsLCBzZXQgdXAgd2hlbiBwYXRoIGlzIGNvbmZpcm1lZFxuICBzdGF0dXNCYXJJdGVtRWw6IEhUTUxFbGVtZW50O1xuICBzeW5jSW50ZXJ2YWw6IGFueTsgLy8gRm9yIHdpbmRvdy5zZXRJbnRlcnZhbFxuICBpc1N5bmNpbmc6IGJvb2xlYW4gPSBmYWxzZTsgLy8gVG8gcHJldmVudCBjb25jdXJyZW50IHN5bmMgb3BlcmF0aW9uc1xuXG4gIGFzeW5jIG9ubG9hZCgpIHtcbiAgICBjb25zb2xlLmxvZyhcIkxvYWRpbmcgR2l0IFN5bmMgcGx1Z2luXCIpO1xuICAgIGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XG5cbiAgICB0aGlzLnN0YXR1c0Jhckl0ZW1FbCA9IHRoaXMuYWRkU3RhdHVzQmFySXRlbSgpO1xuICAgIHRoaXMudXBkYXRlU3RhdHVzQmFyKFwiSWRsZVwiKTtcblxuICAgIHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgR2l0U3luY1NldHRpbmdUYWIodGhpcy5hcHAsIHRoaXMpKTtcblxuICAgIC8vIEluaXRpYWxpemUgR2l0IGluc3RhbmNlXG4gICAgdGhpcy5pbml0aWFsaXplR2l0KCk7XG5cbiAgICBpZiAodGhpcy5zZXR0aW5ncy5hdXRvU3luYyAmJiB0aGlzLmdpdCkge1xuICAgICAgdGhpcy5zdGFydEF1dG9TeW5jKCk7XG4gICAgfVxuXG4gICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgIGlkOiBcImdpdC1zeW5jLW5vd1wiLFxuICAgICAgbmFtZTogXCJTeW5jIHdpdGggUmVtb3RlXCIsXG4gICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5naXQpIHtcbiAgICAgICAgICB0aGlzLnN5bmNWYXVsdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ldyBOb3RpY2UoXG4gICAgICAgICAgICBcIkdpdCBTeW5jOiBSZXBvc2l0b3J5IG5vdCBpbml0aWFsaXplZCBvciBwYXRoIG5vdCBmb3VuZC4gQ2hlY2sgc2V0dGluZ3MuXCIsXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXR1c0JhcihcIkVycm9yOiBHaXQgbm90IGluaXRcIik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICAvLyBMaXN0ZW4gZm9yIHZhdWx0IG1vZGlmaWNhdGlvbnNcbiAgICB0aGlzLnJlZ2lzdGVyRXZlbnQodGhpcy5hcHAudmF1bHQub24oXCJtb2RpZnlcIiwgdGhpcy5oYW5kbGVGaWxlQWN0aXZpdHkpKTtcbiAgICB0aGlzLnJlZ2lzdGVyRXZlbnQodGhpcy5hcHAudmF1bHQub24oXCJkZWxldGVcIiwgdGhpcy5oYW5kbGVGaWxlQWN0aXZpdHkpKTtcbiAgICB0aGlzLnJlZ2lzdGVyRXZlbnQodGhpcy5hcHAudmF1bHQub24oXCJyZW5hbWVcIiwgdGhpcy5oYW5kbGVGaWxlQWN0aXZpdHkpKTtcblxuICAgIC8vIEF0dGVtcHQgdG8gc3luYyBvbiBzdGFydHVwIGlmIGF1dG9TeW5jIGlzIGVuYWJsZWRcbiAgICBpZiAodGhpcy5zZXR0aW5ncy5hdXRvU3luYyAmJiB0aGlzLnNldHRpbmdzLnJlcG9VcmwpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiR2l0IFN5bmM6IEF0dGVtcHRpbmcgaW5pdGlhbCBzeW5jIG9uIGxvYWQuXCIpO1xuICAgICAgdGhpcy5zeW5jVmF1bHQoKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkdpdCBTeW5jOiBJbml0aWFsIHN5bmMgZmFpbGVkXCIsIGVycm9yKTtcbiAgICAgICAgbmV3IE5vdGljZShcIkdpdCBTeW5jOiBJbml0aWFsIHN5bmMgZmFpbGVkLiBDaGVjayBjb25zb2xlIGZvciBkZXRhaWxzLlwiKTtcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0dXNCYXIoXCJJbml0aWFsIFN5bmMgRmFpbGVkXCIpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgb251bmxvYWQoKSB7XG4gICAgY29uc29sZS5sb2coXCJVbmxvYWRpbmcgR2l0IFN5bmMgcGx1Z2luXCIpO1xuICAgIHRoaXMuc3RvcEF1dG9TeW5jKCk7XG4gIH1cblxuICBpbml0aWFsaXplR2l0KCkge1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLmFwcC52YXVsdC5hZGFwdGVyO1xuICAgIGlmIChhZGFwdGVyIGluc3RhbmNlb2YgRmlsZVN5c3RlbUFkYXB0ZXIpIHtcbiAgICAgIGNvbnN0IGJhc2VQYXRoID0gYWRhcHRlci5nZXRCYXNlUGF0aCgpO1xuICAgICAgY29uc29sZS5sb2coYEdpdCBTeW5jOiBJbml0aWFsaXppbmcgR2l0IGluICR7YmFzZVBhdGh9YCk7XG4gICAgICB0aGlzLmdpdCA9IHNpbXBsZUdpdCh7XG4gICAgICAgIGJhc2VEaXI6IGJhc2VQYXRoLFxuICAgICAgICBiaW5hcnk6IFwiZ2l0XCIsIC8vIEVuc3VyZSB0aGlzIHBvaW50cyB0byB1c2VyJ3MgZ2l0IGV4ZWN1dGFibGUgaWYgbm90IGluIFBBVEhcbiAgICAgICAgbWF4Q29uY3VycmVudFByb2Nlc3NlczogNixcbiAgICAgIH0pO1xuICAgICAgLy8gVmVyaWZ5IGdpdCBpcyB3b3JraW5nXG4gICAgICB0aGlzLmdpdFxuICAgICAgICAudmVyc2lvbigpXG4gICAgICAgIC50aGVuKCh2KSA9PlxuICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgYEdpdCBTeW5jOiBHaXQgdmVyc2lvbiAke3YubWFqb3J9LiR7di5taW5vcn0uJHt2LnBhdGNofSBpbml0aWFsaXplZC5gLFxuICAgICAgICAgICksXG4gICAgICAgIClcbiAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJHaXQgU3luYzogRmFpbGVkIHRvIGluaXRpYWxpemUgR2l0LiBJcyBHaXQgaW5zdGFsbGVkIGFuZCBpbiBQQVRIP1wiLFxuICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICk7XG4gICAgICAgICAgbmV3IE5vdGljZShcbiAgICAgICAgICAgIFwiR2l0IFN5bmM6IEZhaWxlZCB0byBpbml0aWFsaXplIEdpdC4gRW5zdXJlIEdpdCBpcyBpbnN0YWxsZWQgYW5kIGluIHlvdXIgc3lzdGVtJ3MgUEFUSC5cIixcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuZ2l0ID0gbnVsbDsgLy8gTnVsbGlmeSBnaXQgaWYgaW5pdGlhbGl6YXRpb24gZmFpbHNcbiAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXR1c0JhcihcIkVycm9yOiBHaXQgaW5pdCBmYWlsZWRcIik7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBcIkdpdCBTeW5jOiBWYXVsdCBpcyBub3Qgb24gYSBsb2NhbCBmaWxlc3lzdGVtLiBHaXQgU3luYyBkaXNhYmxlZC5cIixcbiAgICAgICk7XG4gICAgICBuZXcgTm90aWNlKFxuICAgICAgICBcIkdpdCBTeW5jOiBWYXVsdCBtdXN0IGJlIG9uIGEgbG9jYWwgZmlsZXN5c3RlbSBmb3IgR2l0IFN5bmMgdG8gd29yay5cIixcbiAgICAgICk7XG4gICAgICB0aGlzLnVwZGF0ZVN0YXR1c0JhcihcIkVycm9yOiBOb3QgbG9jYWwgdmF1bHRcIik7XG4gICAgICB0aGlzLmdpdCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgbG9hZFNldHRpbmdzKCkge1xuICAgIHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xuICB9XG5cbiAgYXN5bmMgc2F2ZVNldHRpbmdzKCkge1xuICAgIGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XG4gIH1cblxuICAvLyAtLS0gU3luYyBMb2dpYyAtLS1cbiAgYXN5bmMgc3luY1ZhdWx0KCkge1xuICAgIGlmICh0aGlzLmlzU3luY2luZykge1xuICAgICAgbmV3IE5vdGljZShcIkdpdCBTeW5jOiBTeW5jIGFscmVhZHkgaW4gcHJvZ3Jlc3MuXCIpO1xuICAgICAgY29uc29sZS5sb2coXCJHaXQgU3luYzogU3luYyBhbHJlYWR5IGluIHByb2dyZXNzLCBza2lwcGluZy5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5naXQpIHtcbiAgICAgIG5ldyBOb3RpY2UoXG4gICAgICAgIFwiR2l0IFN5bmM6IEdpdCBpcyBub3QgaW5pdGlhbGl6ZWQuIENoZWNrIHBsdWdpbiBzZXR0aW5ncyBhbmQgY29uc29sZS5cIixcbiAgICAgICk7XG4gICAgICB0aGlzLnVwZGF0ZVN0YXR1c0JhcihcIkVycm9yOiBHaXQgbm90IHJlYWR5XCIpO1xuICAgICAgdGhpcy5pbml0aWFsaXplR2l0KCk7IC8vIEF0dGVtcHQgdG8gcmUtaW5pdGlhbGl6ZVxuICAgICAgaWYgKCF0aGlzLmdpdCkgcmV0dXJuOyAvLyBJZiBzdGlsbCBub3QgaW5pdGlhbGl6ZWQsIGV4aXRcbiAgICB9XG4gICAgaWYgKCF0aGlzLnNldHRpbmdzLnJlcG9VcmwpIHtcbiAgICAgIHRoaXMudXBkYXRlU3RhdHVzQmFyKFwiRXJyb3I6IFJlcG8gVVJMIG5vdCBzZXRcIik7XG4gICAgICBuZXcgTm90aWNlKFwiR2l0IFN5bmM6IFJlcG9zaXRvcnkgVVJMIGlzIG5vdCBjb25maWd1cmVkIGluIHNldHRpbmdzLlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmlzU3luY2luZyA9IHRydWU7XG4gICAgdGhpcy51cGRhdGVTdGF0dXNCYXIoXCJTeW5jaW5nLi4uXCIpO1xuICAgIGNvbnNvbGUubG9nKFwiR2l0IFN5bmM6IFN0YXJ0aW5nIHZhdWx0IHN5bmNocm9uaXphdGlvbi5cIik7XG5cbiAgICB0cnkge1xuICAgICAgLy8gMS4gRmV0Y2ggY2hhbmdlcyBmcm9tIHJlbW90ZSB0byBjaGVjayBmb3IgcmVtb3RlIHVwZGF0ZXNcbiAgICAgIC8vIFRoaXMgaGVscHMgaW4gdW5kZXJzdGFuZGluZyBpZiBhIHB1bGwgaXMgbmVlZGVkIGJlZm9yZSBjb21taXR0aW5nLlxuICAgICAgLy8gRm9yIHNpbXBsaWNpdHkgaW4gdGhpcyBleGFtcGxlLCB3ZSdsbCBwdWxsIGRpcmVjdGx5LlxuICAgICAgLy8gTW9yZSBhZHZhbmNlZDogYGdpdCBmZXRjaGAgdGhlbiBgZ2l0IHN0YXR1c2AgdG8gc2VlIGlmIHJlbW90ZSBpcyBhaGVhZC5cbiAgICAgIGNvbnNvbGUubG9nKFwiR2l0IFN5bmM6IFB1bGxpbmcgZnJvbSByZW1vdGUuLi5cIik7XG4gICAgICBhd2FpdCB0aGlzLmdpdFxuICAgICAgICAucHVsbCh7IFwiLS1yZWJhc2VcIjogXCJ0cnVlXCIsIFwiLS1hdXRvc3Rhc2hcIjogXCJ0cnVlXCIgfSlcbiAgICAgICAgLmNhdGNoKGFzeW5jIChwdWxsRXJyb3IpID0+IHtcbiAgICAgICAgICAvLyBIYW5kbGUgY29tbW9uIHB1bGwgZXJyb3JzLCBlLmcuLCBjb25mbGljdHMgYWZ0ZXIgcmViYXNlXG4gICAgICAgICAgaWYgKHB1bGxFcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwiQ09ORkxJQ1RcIikpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgXCJHaXQgU3luYzogTWVyZ2UgY29uZmxpY3QgYWZ0ZXIgcHVsbC4gQXR0ZW1wdGluZyB0byBhYm9ydCByZWJhc2UuXCIsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbmV3IE5vdGljZShcbiAgICAgICAgICAgICAgXCJHaXQgU3luYzogTWVyZ2UgY29uZmxpY3QgZGV0ZWN0ZWQgZHVyaW5nIHB1bGwuIFBsZWFzZSByZXNvbHZlIG1hbnVhbGx5LlwiLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gYWJvcnQgdGhlIHJlYmFzZSB0byBsZWF2ZSB0aGUgd29ya2luZyBkaXJlY3RvcnkgY2xlYW4gZm9yIG1hbnVhbCByZXNvbHV0aW9uXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBhd2FpdCB0aGlzLmdpdD8ucmViYXNlKHsgXCItLWFib3J0XCI6IG51bGwgfSk7XG4gICAgICAgICAgICAgIG5ldyBOb3RpY2UoXG4gICAgICAgICAgICAgICAgXCJHaXQgU3luYzogUmViYXNlIGFib3J0ZWQuIFBsZWFzZSByZXNvbHZlIGNvbmZsaWN0cyBhbmQgc3luYyBtYW51YWxseS5cIixcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGFib3J0RXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkdpdCBTeW5jOiBDb3VsZCBub3QgYWJvcnQgcmViYXNlLlwiLCBhYm9ydEVycm9yKTtcbiAgICAgICAgICAgICAgbmV3IE5vdGljZShcbiAgICAgICAgICAgICAgICBcIkdpdCBTeW5jOiBDcml0aWNhbCEgQ291bGQgbm90IGFib3J0IHJlYmFzZS4gTWFudWFsIEdpdCBpbnRlcnZlbnRpb24gcmVxdWlyZWQuXCIsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXJnZSBjb25mbGljdCBkdXJpbmcgcHVsbCwgcmViYXNlIGFib3J0ZWQuXCIpOyAvLyBQcm9wYWdhdGUgZXJyb3JcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gSWYgbm90IGEgY29uZmxpY3QsIG9yIGlmIGFib3J0IGZhaWxlZCwgcmUtdGhyb3dcbiAgICAgICAgICB0aHJvdyBwdWxsRXJyb3I7XG4gICAgICAgIH0pO1xuICAgICAgY29uc29sZS5sb2coXCJHaXQgU3luYzogUHVsbCBzdWNjZXNzZnVsLlwiKTtcblxuICAgICAgLy8gMi4gQWRkIGFsbCBjaGFuZ2VzIChuZXcsIG1vZGlmaWVkLCBkZWxldGVkIGZpbGVzKVxuICAgICAgY29uc29sZS5sb2coXCJHaXQgU3luYzogQWRkaW5nIGZpbGVzIHRvIHN0YWdpbmcuLi5cIik7XG4gICAgICBhd2FpdCB0aGlzLmdpdC5hZGQoXCIuLypcIik7IC8vIFN0YWdlcyBhbGwgY2hhbmdlcyBpbiB0aGUgdmF1bHQgZGlyZWN0b3J5XG5cbiAgICAgIC8vIDMuIENoZWNrIHN0YXR1cyB0byBzZWUgaWYgdGhlcmUncyBhbnl0aGluZyB0byBjb21taXRcbiAgICAgIGNvbnN0IHN0YXR1czogU3RhdHVzUmVzdWx0ID0gYXdhaXQgdGhpcy5naXQuc3RhdHVzKCk7XG4gICAgICBjb25zdCBmaWxlc1RvQ29tbWl0ID0gc3RhdHVzLmZpbGVzLmZpbHRlcihcbiAgICAgICAgKGZpbGUpID0+IGZpbGUud29ya2luZ19kaXIgIT09IFwiIFwiICYmIGZpbGUud29ya2luZ19kaXIgIT09IFwiP1wiLFxuICAgICAgKTsgLy8gRXhjbHVkZSB1bnRyYWNrZWQgdW5sZXNzIGV4cGxpY2l0bHkgaGFuZGxlZFxuXG4gICAgICBpZiAoZmlsZXNUb0NvbW1pdC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBHaXQgU3luYzogQ29tbWl0dGluZyAke2ZpbGVzVG9Db21taXQubGVuZ3RofSBjaGFuZ2VzLmApO1xuICAgICAgICBjb25zdCBjb21taXRNZXNzYWdlID0gdGhpcy5zZXR0aW5ncy5jb21taXRNZXNzYWdlLnJlcGxhY2UoXG4gICAgICAgICAgXCJ7e2RhdGV9fVwiLFxuICAgICAgICAgIG1vbWVudCgpLmZvcm1hdChcIllZWVktTU0tREQgSEg6bW06c3NcIiksXG4gICAgICAgICk7XG4gICAgICAgIGF3YWl0IHRoaXMuZ2l0LmNvbW1pdChjb21taXRNZXNzYWdlKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJHaXQgU3luYzogQ29tbWl0IHN1Y2Nlc3NmdWwuXCIpO1xuXG4gICAgICAgIC8vIDQuIFB1c2ggY2hhbmdlc1xuICAgICAgICBjb25zb2xlLmxvZyhcIkdpdCBTeW5jOiBQdXNoaW5nIHRvIHJlbW90ZS4uLlwiKTtcbiAgICAgICAgYXdhaXQgdGhpcy5naXQucHVzaCgpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIkdpdCBTeW5jOiBQdXNoIHN1Y2Nlc3NmdWwuXCIpO1xuXG4gICAgICAgIHRoaXMuc2V0dGluZ3MubGFzdFN5bmMgPSBtb21lbnQoKS5mb3JtYXQoXCJZWVlZLU1NLUREIEhIOm1tOnNzXCIpO1xuICAgICAgICBhd2FpdCB0aGlzLnNhdmVTZXR0aW5ncygpOyAvLyBTYXZlIGxhc3Qgc3luYyB0aW1lXG4gICAgICAgIHRoaXMudXBkYXRlU3RhdHVzQmFyKFwiU3luY2VkXCIpO1xuICAgICAgICBuZXcgTm90aWNlKFwiR2l0IFN5bmM6IFZhdWx0IHN1Y2Nlc3NmdWxseSBzeW5jZWQgd2l0aCByZW1vdGUuXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5sYXN0U3luYyA9IG1vbWVudCgpLmZvcm1hdChcIllZWVktTU0tREQgSEg6bW06c3NcIik7IC8vIFVwZGF0ZSBsYXN0IHN5bmMgZXZlbiBpZiBubyBsb2NhbCBjaGFuZ2VzLCBhcyBwdWxsIG1pZ2h0IGhhdmUgb2NjdXJyZWRcbiAgICAgICAgYXdhaXQgdGhpcy5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0dXNCYXIoXCJObyBsb2NhbCBjaGFuZ2VzXCIpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIkdpdCBTeW5jOiBObyBsb2NhbCBjaGFuZ2VzIHRvIGNvbW1pdC5cIik7XG4gICAgICAgIG5ldyBOb3RpY2UoXG4gICAgICAgICAgXCJHaXQgU3luYzogTm8gbG9jYWwgY2hhbmdlcyB0byBjb21taXQuIFZhdWx0IGlzIHVwLXRvLWRhdGUgd2l0aCByZW1vdGUuXCIsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkdpdCBTeW5jOiBTeW5jaHJvbml6YXRpb24gZXJyb3JcIiwgZXJyb3IpO1xuICAgICAgdGhpcy5oYW5kbGVTeW5jRXJyb3IoZXJyb3IpOyAvLyBDZW50cmFsaXplZCBlcnJvciBoYW5kbGluZ1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmlzU3luY2luZyA9IGZhbHNlO1xuICAgICAgY29uc29sZS5sb2coXCJHaXQgU3luYzogU3luY2hyb25pemF0aW9uIGF0dGVtcHQgZmluaXNoZWQuXCIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFVwZGF0ZWQgdG8gaGFuZGxlIFRBYnN0cmFjdEZpbGVcbiAgaGFuZGxlRmlsZUFjdGl2aXR5ID0gKGZpbGU6IFRBYnN0cmFjdEZpbGUpID0+IHtcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBmaWxlIG1vZGlmeSwgZGVsZXRlLCBvciByZW5hbWUuXG4gICAgLy8gSXQgY2FuIGJlIHVzZWQgdG8gdHJpZ2dlciBhIHN5bmMgb3IgdXBkYXRlIFVJLlxuICAgIC8vIEZvciBub3csIGp1c3QgaW5kaWNhdGVzIGFjdGl2aXR5LlxuICAgIGlmICghdGhpcy5pc1N5bmNpbmcpIHtcbiAgICAgIC8vIEF2b2lkIGNoYW5naW5nIHN0YXR1cyBpZiBhIHN5bmMgaXMgYWxyZWFkeSBpbiBwcm9ncmVzc1xuICAgICAgdGhpcy51cGRhdGVTdGF0dXNCYXIoXCJDaGFuZ2VzIGRldGVjdGVkXCIpO1xuICAgIH1cbiAgICBjb25zb2xlLmxvZyhcbiAgICAgIGBHaXQgU3luYzogRmlsZSBhY3Rpdml0eSBkZXRlY3RlZCAtICR7ZmlsZS5wYXRofSAoJHtmaWxlIGluc3RhbmNlb2YgVEZpbGUgPyBcImZpbGVcIiA6IFwiZm9sZGVyXCJ9KWAsXG4gICAgKTtcbiAgICAvLyBEZWJvdW5jaW5nIG9yIGRlbGF5aW5nIHN5bmMgYWZ0ZXIgYWN0aXZpdHkgY2FuIGJlIGFkZGVkIGhlcmVcbiAgICAvLyBGb3IgZXhhbXBsZSwgdHJpZ2dlciBhIHN5bmMgYWZ0ZXIgYSBzaG9ydCBwZXJpb2Qgb2YgaW5hY3Rpdml0eS5cbiAgfTtcblxuICBoYW5kbGVTeW5jRXJyb3IoZXJyb3I6IGFueSkge1xuICAgIGxldCBlcnJvck1lc3NhZ2UgPSBcIkdpdCBTeW5jOiBBbiB1bmtub3duIGVycm9yIG9jY3VycmVkLlwiO1xuICAgIGlmIChlcnJvci5tZXNzYWdlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoXCJDT05GTElDVFwiKSB8fFxuICAgICAgICAoZXJyb3IuZ2l0ICYmXG4gICAgICAgICAgZXJyb3IuZ2l0LmZhaWxlZCAmJlxuICAgICAgICAgIGVycm9yLmdpdC5tZXNzYWdlLmluY2x1ZGVzKFwiY29uZmxpY3RcIikpXG4gICAgICApIHtcbiAgICAgICAgZXJyb3JNZXNzYWdlID1cbiAgICAgICAgICBcIkdpdCBTeW5jOiBNZXJnZSBjb25mbGljdCBkZXRlY3RlZC4gUGxlYXNlIHJlc29sdmUgaXQgbWFudWFsbHkgaW4geW91ciBHaXQgY2xpZW50LlwiO1xuICAgICAgICB0aGlzLnVwZGF0ZVN0YXR1c0JhcihcIkNvbmZsaWN0IVwiKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoXCJIb3N0IGtleSB2ZXJpZmljYXRpb24gZmFpbGVkXCIpIHx8XG4gICAgICAgIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoXCJQZXJtaXNzaW9uIGRlbmllZFwiKVxuICAgICAgKSB7XG4gICAgICAgIGVycm9yTWVzc2FnZSA9XG4gICAgICAgICAgXCJHaXQgU3luYzogQXV0aGVudGljYXRpb24gZmFpbGVkLiBDaGVjayBTU0gga2V5cyBvciBIVFRQUyBjcmVkZW50aWFscy5cIjtcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0dXNCYXIoXCJBdXRoIEVycm9yXCIpO1xuICAgICAgfSBlbHNlIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwibm90IGEgZ2l0IHJlcG9zaXRvcnlcIikpIHtcbiAgICAgICAgZXJyb3JNZXNzYWdlID1cbiAgICAgICAgICBcIkdpdCBTeW5jOiBWYXVsdCBpcyBub3QgYSBHaXQgcmVwb3NpdG9yeSBvciAuZ2l0IGZvbGRlciBpcyBtaXNzaW5nLlwiO1xuICAgICAgICB0aGlzLnVwZGF0ZVN0YXR1c0JhcihcIk5vdCBhIHJlcG9cIik7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwiQ291bGQgbm90IHJlYWQgZnJvbSByZW1vdGUgcmVwb3NpdG9yeVwiKVxuICAgICAgKSB7XG4gICAgICAgIGVycm9yTWVzc2FnZSA9XG4gICAgICAgICAgXCJHaXQgU3luYzogQ2Fubm90IGNvbm5lY3QgdG8gcmVtb3RlLiBDaGVjayByZXBvc2l0b3J5IFVSTCBhbmQgbmV0d29yay5cIjtcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0dXNCYXIoXCJSZW1vdGUgRXJyb3JcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvck1lc3NhZ2UgPSBgR2l0IFN5bmM6IEVycm9yIC0gJHtlcnJvci5tZXNzYWdlLnN1YnN0cmluZygwLCAxMDApfS4uLmA7IC8vIEtlZXAgaXQgY29uY2lzZSBmb3IgTm90aWNlXG4gICAgICAgIHRoaXMudXBkYXRlU3RhdHVzQmFyKFwiU3luYyBFcnJvclwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbmV3IE5vdGljZShlcnJvck1lc3NhZ2UsIDEwMDAwKTsgLy8gU2hvdyBub3RpY2UgZm9yIDEwIHNlY29uZHNcbiAgICBjb25zb2xlLmVycm9yKFwiR2l0IFN5bmMgRGV0YWlsZWQgRXJyb3I6XCIsIGVycm9yKTsgLy8gTG9nIHRoZSBmdWxsIGVycm9yXG4gIH1cblxuICAvLyAtLS0gQXV0b21hdGlvbiAtLS1cbiAgc3RhcnRBdXRvU3luYygpIHtcbiAgICBpZiAodGhpcy5zeW5jSW50ZXJ2YWwpIHJldHVybjsgLy8gQWxyZWFkeSBydW5uaW5nXG4gICAgaWYgKCF0aGlzLmdpdCkge1xuICAgICAgY29uc29sZS5sb2coXCJHaXQgU3luYzogQXV0byBTeW5jIGNhbm5vdCBzdGFydCwgR2l0IG5vdCBpbml0aWFsaXplZC5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGludGVydmFsTWlsbGlzID0gdGhpcy5zZXR0aW5ncy5jb21taXRJbnRlcnZhbCAqIDYwICogMTAwMDtcbiAgICBpZiAoaW50ZXJ2YWxNaWxsaXMgPD0gMCkge1xuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgIFwiR2l0IFN5bmM6IEF1dG8gU3luYyBpbnRlcnZhbCBpcyB6ZXJvIG9yIG5lZ2F0aXZlLCBub3Qgc3RhcnRpbmcuXCIsXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKFxuICAgICAgYEdpdCBTeW5jOiBTdGFydGluZyBhdXRvLXN5bmMgZXZlcnkgJHt0aGlzLnNldHRpbmdzLmNvbW1pdEludGVydmFsfSBtaW51dGVzLmAsXG4gICAgKTtcbiAgICB0aGlzLnN5bmNJbnRlcnZhbCA9IHdpbmRvdy5zZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhcIkdpdCBTeW5jOiBBdXRvLXN5bmMgdHJpZ2dlcmVkIGJ5IGludGVydmFsLlwiKTtcbiAgICAgIHRoaXMuc3luY1ZhdWx0KCk7XG4gICAgfSwgaW50ZXJ2YWxNaWxsaXMpO1xuICB9XG5cbiAgc3RvcEF1dG9TeW5jKCkge1xuICAgIGlmICh0aGlzLnN5bmNJbnRlcnZhbCkge1xuICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy5zeW5jSW50ZXJ2YWwpO1xuICAgICAgdGhpcy5zeW5jSW50ZXJ2YWwgPSBudWxsO1xuICAgICAgY29uc29sZS5sb2coXCJHaXQgU3luYzogQXV0by1zeW5jIHN0b3BwZWQuXCIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIC0tLSBVSSAtLS1cbiAgdXBkYXRlU3RhdHVzQmFyKHRleHQ6IHN0cmluZykge1xuICAgIGlmICh0aGlzLnN0YXR1c0Jhckl0ZW1FbCkge1xuICAgICAgdGhpcy5zdGF0dXNCYXJJdGVtRWwuc2V0VGV4dChgR2l0IFN5bmM6ICR7dGV4dH1gKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gLS0tIFNldHRpbmdzIFRhYiAtLS1cbmNsYXNzIEdpdFN5bmNTZXR0aW5nVGFiIGV4dGVuZHMgUGx1Z2luU2V0dGluZ1RhYiB7XG4gIHBsdWdpbjogR2l0U3luY1BsdWdpbjtcblxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcGx1Z2luOiBHaXRTeW5jUGx1Z2luKSB7XG4gICAgc3VwZXIoYXBwLCBwbHVnaW4pO1xuICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xuICB9XG5cbiAgZGlzcGxheSgpOiB2b2lkIHtcbiAgICBjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuICAgIGNvbnRhaW5lckVsLmVtcHR5KCk7XG4gICAgY29udGFpbmVyRWwuY3JlYXRlRWwoXCJoMlwiLCB7IHRleHQ6IFwiR2l0IFN5bmMgU2V0dGluZ3NcIiB9KTtcblxuICAgIC8vIC0tLSBHZW5lcmFsIFNldHRpbmdzIC0tLVxuICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKFwiaDNcIiwgeyB0ZXh0OiBcIkdlbmVyYWxcIiB9KTtcbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgIC5zZXROYW1lKFwiRW5hYmxlIEF1dG8gU3luY1wiKVxuICAgICAgLnNldERlc2MoXCJBdXRvbWF0aWNhbGx5IHN5bmMgeW91ciB2YXVsdCBhdCB0aGUgZGVmaW5lZCBpbnRlcnZhbC5cIilcbiAgICAgIC5hZGRUb2dnbGUoKHRvZ2dsZSkgPT5cbiAgICAgICAgdG9nZ2xlXG4gICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmF1dG9TeW5jKVxuICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmF1dG9TeW5jID0gdmFsdWU7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB0aGlzLnBsdWdpbi5naXQpIHtcbiAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc3RhcnRBdXRvU3luYygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc3RvcEF1dG9TeW5jKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXkoKTsgLy8gUmVmcmVzaCBzZXR0aW5ncyB0YWIgdG8gc2hvdy9oaWRlIGludGVydmFsXG4gICAgICAgICAgfSksXG4gICAgICApO1xuXG4gICAgaWYgKHRoaXMucGx1Z2luLnNldHRpbmdzLmF1dG9TeW5jKSB7XG4gICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgLnNldE5hbWUoXCJTeW5jIEludGVydmFsIChtaW51dGVzKVwiKVxuICAgICAgICAuc2V0RGVzYyhcbiAgICAgICAgICBcIkhvdyBvZnRlbiB0byBhdXRvbWF0aWNhbGx5IGNvbW1pdCBhbmQgcHVzaCBjaGFuZ2VzLiBNaW5pbXVtIDEgbWludXRlLlwiLFxuICAgICAgICApXG4gICAgICAgIC5hZGRUZXh0KCh0ZXh0KSA9PlxuICAgICAgICAgIHRleHRcbiAgICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcihcIjE1XCIpXG4gICAgICAgICAgICAuc2V0VmFsdWUoU3RyaW5nKHRoaXMucGx1Z2luLnNldHRpbmdzLmNvbW1pdEludGVydmFsKSlcbiAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgbGV0IG51bVZhbHVlID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgICAgaWYgKGlzTmFOKG51bVZhbHVlKSB8fCBudW1WYWx1ZSA8IDEpIHtcbiAgICAgICAgICAgICAgICBudW1WYWx1ZSA9IDE7IC8vIEVuZm9yY2UgbWluaW11bVxuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJTeW5jIGludGVydmFsIG11c3QgYmUgYXQgbGVhc3QgMSBtaW51dGUuXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmNvbW1pdEludGVydmFsID0gbnVtVmFsdWU7XG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAvLyBSZXN0YXJ0IGF1dG8tc3luYyB3aXRoIG5ldyBpbnRlcnZhbCBpZiBpdCdzIGVuYWJsZWRcbiAgICAgICAgICAgICAgaWYgKHRoaXMucGx1Z2luLnNldHRpbmdzLmF1dG9TeW5jKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc3RvcEF1dG9TeW5jKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc3RhcnRBdXRvU3luYygpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyAtLS0gUmVwb3NpdG9yeSBTZXR0aW5ncyAtLS1cbiAgICBjb250YWluZXJFbC5jcmVhdGVFbChcImgzXCIsIHsgdGV4dDogXCJSZXBvc2l0b3J5XCIgfSk7XG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAuc2V0TmFtZShcIlJlcG9zaXRvcnkgVVJMXCIpXG4gICAgICAuc2V0RGVzYyhcbiAgICAgICAgXCJUaGUgSFRUUFMgb3IgU1NIIFVSTCBvZiB5b3VyIHJlbW90ZSBHaXQgcmVwb3NpdG9yeSAoZS5nLiwgaHR0cHM6Ly9naXRodWIuY29tL3VzZXIvcmVwby5naXQgb3IgZ2l0QGdpdGh1Yi5jb206dXNlci9yZXBvLmdpdCkuXCIsXG4gICAgICApXG4gICAgICAuYWRkVGV4dCgodGV4dCkgPT5cbiAgICAgICAgdGV4dFxuICAgICAgICAgIC5zZXRQbGFjZWhvbGRlcihcImh0dHBzOi8vZ2l0aHViLmNvbS91c2VyL3JlcG8uZ2l0XCIpXG4gICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnJlcG9VcmwpXG4gICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MucmVwb1VybCA9IHZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgLy8gUmUtaW5pdGlhbGl6ZSBnaXQgb3IgdXBkYXRlIHJlbW90ZSBpZiBuZWVkZWRcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLmluaXRpYWxpemVHaXQoKTtcbiAgICAgICAgICB9KSxcbiAgICAgICk7XG5cbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgIC5zZXROYW1lKFwiQ29tbWl0IE1lc3NhZ2VcIilcbiAgICAgIC5zZXREZXNjKFxuICAgICAgICBcIkN1c3RvbWl6ZSB0aGUgY29tbWl0IG1lc3NhZ2UuIFVzZSB7e2RhdGV9fSBmb3IgdGhlIGN1cnJlbnQgdGltZXN0YW1wLlwiLFxuICAgICAgKVxuICAgICAgLmFkZFRleHQoKHRleHQpID0+XG4gICAgICAgIHRleHRcbiAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoREVGQVVMVF9TRVRUSU5HUy5jb21taXRNZXNzYWdlKVxuICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5jb21taXRNZXNzYWdlKVxuICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmNvbW1pdE1lc3NhZ2UgPSB2YWx1ZTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgIH0pLFxuICAgICAgKTtcblxuICAgIC8vIEF1dGhlbnRpY2F0aW9uIG1ldGhvZCBpcyBvZnRlbiBpbmZlcnJlZCBieSBHaXQgZnJvbSB0aGUgVVJMIChIVFRQUyB2cyBTU0gpXG4gICAgLy8gT3IgaGFuZGxlZCBieSBjcmVkZW50aWFsIG1hbmFnZXJzIC8gU1NIIGFnZW50LiBFeHBsaWNpdGx5IHNldHRpbmcgaXQgbWlnaHQgYmUgY29tcGxleFxuICAgIC8vIGFuZCBsZXNzIHVzZXItZnJpZW5kbHkgdGhhbiBsZXR0aW5nIEdpdCBoYW5kbGUgaXQuXG4gICAgLy8gRm9yIG5vdywgcmVtb3ZpbmcgZXhwbGljaXQgYXV0aE1ldGhvZCBzZXR0aW5nIHRvIHJlbHkgb24gR2l0J3MgYnVpbHQtaW4gaGFuZGxpbmcuXG4gICAgLy8gSWYgc3BlY2lmaWMgYXV0aCBmbG93IGlzIG5lZWRlZCwgaXQgY2FuIGJlIGFkZGVkIGJhY2sgd2l0aCBtb3JlIHJvYnVzdCBsb2dpYy5cbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgIC5zZXROYW1lKFwiQXV0aGVudGljYXRpb24gTWV0aG9kXCIpXG4gICAgICAuc2V0RGVzYyhcbiAgICAgICAgXCJHaXQgd2lsbCB0eXBpY2FsbHkgdXNlIFNTSCBmb3IgZ2l0QCBVUkxzIGFuZCBIVFRQUyBmb3IgaHR0cHM6Ly8gVVJMcy4gRW5zdXJlIHlvdXIgR2l0IGNsaWVudCBpcyBjb25maWd1cmVkLlwiLFxuICAgICAgKVxuICAgICAgLmFkZERyb3Bkb3duKChkcm9wZG93bikgPT5cbiAgICAgICAgZHJvcGRvd25cbiAgICAgICAgICAuYWRkT3B0aW9uKFwic3NoXCIsIFwiU1NIIChnaXRAZXhhbXBsZS5jb206Li4uKVwiKVxuICAgICAgICAgIC5hZGRPcHRpb24oXCJodHRwc1wiLCBcIkhUVFBTIChodHRwczovL2V4YW1wbGUuY29tLy4uLilcIilcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuYXV0aE1ldGhvZClcbiAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlOiBcInNzaFwiIHwgXCJodHRwc1wiKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5hdXRoTWV0aG9kID0gdmFsdWU7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICB9KSxcbiAgICAgICk7XG5cbiAgICAvLyAtLS0gU3RhdHVzICYgQWN0aW9ucyAtLS1cbiAgICBjb250YWluZXJFbC5jcmVhdGVFbChcImgzXCIsIHsgdGV4dDogXCJTdGF0dXMgJiBBY3Rpb25zXCIgfSk7XG4gICAgY29uc3Qgc3RhdHVzRWwgPSBjb250YWluZXJFbC5jcmVhdGVFbChcInBcIiwge1xuICAgICAgdGV4dDogYExhc3QgU3luYzogJHt0aGlzLnBsdWdpbi5zZXR0aW5ncy5sYXN0U3luY31gLFxuICAgIH0pO1xuICAgIC8vIFVwZGF0ZSBsYXN0IHN5bmMgdGltZSBkeW5hbWljYWxseSBpZiBzZXR0aW5ncyBhcmUgcmUtcmVuZGVyZWRcbiAgICB0aGlzLnBsdWdpbi5vbkV4dGVybmFsU2V0dGluZ3NDaGFuZ2UgPSAoKSA9PiB7XG4gICAgICBzdGF0dXNFbC5zZXRUZXh0KGBMYXN0IFN5bmM6ICR7dGhpcy5wbHVnaW4uc2V0dGluZ3MubGFzdFN5bmN9YCk7XG4gICAgfTtcblxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgLnNldE5hbWUoXCJNYW51YWwgU3luY1wiKVxuICAgICAgLnNldERlc2MoXCJUcmlnZ2VyIGEgc3luY2hyb25pemF0aW9uIGN5Y2xlIG1hbnVhbGx5LlwiKVxuICAgICAgLmFkZEJ1dHRvbigoYnV0dG9uKSA9PlxuICAgICAgICBidXR0b25cbiAgICAgICAgICAuc2V0QnV0dG9uVGV4dChcIlN5bmMgTm93XCIpXG4gICAgICAgICAgLnNldEN0YSgpIC8vIE1ha2VzIHRoZSBidXR0b24gbW9yZSBwcm9taW5lbnRcbiAgICAgICAgICAub25DbGljayhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBidXR0b24uc2V0RGlzYWJsZWQodHJ1ZSk7XG4gICAgICAgICAgICBidXR0b24uc2V0QnV0dG9uVGV4dChcIlN5bmNpbmcuLi5cIik7XG4gICAgICAgICAgICBpZiAodGhpcy5wbHVnaW4uZ2l0KSB7XG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnN5bmNWYXVsdCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3IE5vdGljZShcbiAgICAgICAgICAgICAgICBcIkdpdCBTeW5jOiBSZXBvc2l0b3J5IG5vdCBpbml0aWFsaXplZC4gQ2hlY2sgc2V0dGluZ3MuXCIsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHRoaXMucGx1Z2luLnVwZGF0ZVN0YXR1c0JhcihcIkVycm9yOiBHaXQgbm90IGluaXRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidXR0b24uc2V0RGlzYWJsZWQoZmFsc2UpO1xuICAgICAgICAgICAgYnV0dG9uLnNldEJ1dHRvblRleHQoXCJTeW5jIE5vd1wiKTtcbiAgICAgICAgICAgIC8vIFJlZnJlc2ggbGFzdCBzeW5jIHRpbWUgb24gc2V0dGluZ3MgcGFnZVxuICAgICAgICAgICAgc3RhdHVzRWwuc2V0VGV4dChgTGFzdCBTeW5jOiAke3RoaXMucGx1Z2luLnNldHRpbmdzLmxhc3RTeW5jfWApO1xuICAgICAgICAgIH0pLFxuICAgICAgKTtcblxuICAgIC8vIC0tLSBUcm91Ymxlc2hvb3RpbmcgJiBBZHZhbmNlZCAtLS1cbiAgICAvLyBQb3RlbnRpYWxseSBhZGQ6XG4gICAgLy8gLSBCdXR0b24gdG8gb3BlbiBHaXQgbG9nXG4gICAgLy8gLSBPcHRpb24gdG8gcmUtaW5pdGlhbGl6ZSAuZ2l0ICh3aXRoIGNhdXRpb24pXG4gICAgLy8gLSBMaW5rIHRvIEdpdC9TU0ggc2V0dXAgZ3VpZGVzXG4gIH1cblxuICAvLyBIZWxwZXIgdG8gYWxsb3cgcGx1Z2luIHRvIG5vdGlmeSBzZXR0aW5ncyB0YWIgb2YgY2hhbmdlc1xuICBvblNldHRpbmdzQ2hhbmdlZD86ICgpID0+IHZvaWQ7XG59XG4iLCAiY29uc3QgY2FjaGUgPSBuZXcgV2Vha01hcDxTdHJpbmcsIHN0cmluZ1tdPigpO1xuXG5leHBvcnQgZnVuY3Rpb24gcGF0aHNwZWMoLi4ucGF0aHM6IHN0cmluZ1tdKSB7XG4gICBjb25zdCBrZXkgPSBuZXcgU3RyaW5nKHBhdGhzKTtcbiAgIGNhY2hlLnNldChrZXksIHBhdGhzKTtcblxuICAgcmV0dXJuIGtleSBhcyBzdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1BhdGhTcGVjKHBhdGg6IHN0cmluZyB8IHVua25vd24pOiBwYXRoIGlzIHN0cmluZyB7XG4gICByZXR1cm4gcGF0aCBpbnN0YW5jZW9mIFN0cmluZyAmJiBjYWNoZS5oYXMocGF0aCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b1BhdGhzKHBhdGhTcGVjOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICByZXR1cm4gY2FjaGUuZ2V0KHBhdGhTcGVjKSB8fCBbXTtcbn1cbiIsICJpbXBvcnQgdHlwZSB7IFNpbXBsZUdpdFRhc2sgfSBmcm9tICcuLi90eXBlcyc7XG5cbi8qKlxuICogVGhlIGBHaXRFcnJvcmAgaXMgdGhyb3duIHdoZW4gdGhlIHVuZGVybHlpbmcgYGdpdGAgcHJvY2VzcyB0aHJvd3MgYVxuICogZmF0YWwgZXhjZXB0aW9uIChlZyBhbiBgRU5PRU5UYCBleGNlcHRpb24gd2hlbiBhdHRlbXB0aW5nIHRvIHVzZSBhXG4gKiBub24td3JpdGFibGUgZGlyZWN0b3J5IGFzIHRoZSByb290IGZvciB5b3VyIHJlcG8pLCBhbmQgYWN0cyBhcyB0aGVcbiAqIGJhc2UgY2xhc3MgZm9yIG1vcmUgc3BlY2lmaWMgZXJyb3JzIHRocm93biBieSB0aGUgcGFyc2luZyBvZiB0aGVcbiAqIGdpdCByZXNwb25zZSBvciBlcnJvcnMgaW4gdGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIHRhc2sgYWJvdXQgdG9cbiAqIGJlIHJ1bi5cbiAqXG4gKiBXaGVuIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24sIHBlbmRpbmcgdGFza3MgaW4gdGhlIHNhbWUgaW5zdGFuY2Ugd2lsbFxuICogbm90IGJlIGV4ZWN1dGVkLiBUaGUgcmVjb21tZW5kZWQgd2F5IHRvIHJ1biBhIHNlcmllcyBvZiB0YXNrcyB0aGF0XG4gKiBjYW4gaW5kZXBlbmRlbnRseSBmYWlsIHdpdGhvdXQgbmVlZGluZyB0byBwcmV2ZW50IGZ1dHVyZSB0YXNrcyBmcm9tXG4gKiBydW5uaW5nIGlzIHRvIGNhdGNoIHRoZW0gaW5kaXZpZHVhbGx5OlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiBpbXBvcnQgeyBnaXRQLCBTaW1wbGVHaXQsIEdpdEVycm9yLCBQdWxsUmVzdWx0IH0gZnJvbSAnc2ltcGxlLWdpdCc7XG5cbiBmdW5jdGlvbiBjYXRjaFRhc2sgKGU6IEdpdEVycm9yKSB7XG4gICByZXR1cm4gZS5cbiB9XG5cbiBjb25zdCBnaXQgPSBnaXRQKHJlcG9Xb3JraW5nRGlyKTtcbiBjb25zdCBwdWxsZWQ6IFB1bGxSZXN1bHQgfCBHaXRFcnJvciA9IGF3YWl0IGdpdC5wdWxsKCkuY2F0Y2goY2F0Y2hUYXNrKTtcbiBjb25zdCBwdXNoZWQ6IHN0cmluZyB8IEdpdEVycm9yID0gYXdhaXQgZ2l0LnB1c2hUYWdzKCkuY2F0Y2goY2F0Y2hUYXNrKTtcbiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEdpdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgY29uc3RydWN0b3IoXG4gICAgICBwdWJsaWMgdGFzaz86IFNpbXBsZUdpdFRhc2s8YW55PixcbiAgICAgIG1lc3NhZ2U/OiBzdHJpbmdcbiAgICkge1xuICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgbmV3LnRhcmdldC5wcm90b3R5cGUpO1xuICAgfVxufVxuIiwgImltcG9ydCB7IEdpdEVycm9yIH0gZnJvbSAnLi9naXQtZXJyb3InO1xuXG4vKipcbiAqIFRoZSBgR2l0UmVzcG9uc2VFcnJvcmAgaXMgdGhlIHdyYXBwZXIgZm9yIGEgcGFyc2VkIHJlc3BvbnNlIHRoYXQgaXMgdHJlYXRlZCBhc1xuICogYSBmYXRhbCBlcnJvciwgZm9yIGV4YW1wbGUgYXR0ZW1wdGluZyBhIGBtZXJnZWAgY2FuIGxlYXZlIHRoZSByZXBvIGluIGEgY29ycnVwdGVkXG4gKiBzdGF0ZSB3aGVuIHRoZXJlIGFyZSBjb25mbGljdHMgc28gdGhlIHRhc2sgd2lsbCByZWplY3QgcmF0aGVyIHRoYW4gcmVzb2x2ZS5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgY2F0Y2hpbmcgdGhlIG1lcmdlIGNvbmZsaWN0IGV4Y2VwdGlvbjpcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gaW1wb3J0IHsgZ2l0UCwgU2ltcGxlR2l0LCBHaXRSZXNwb25zZUVycm9yLCBNZXJnZVN1bW1hcnkgfSBmcm9tICdzaW1wbGUtZ2l0JztcblxuIGNvbnN0IGdpdCA9IGdpdFAocmVwb1Jvb3QpO1xuIGNvbnN0IG1lcmdlT3B0aW9uczogc3RyaW5nW10gPSBbJy0tbm8tZmYnLCAnb3RoZXItYnJhbmNoJ107XG4gY29uc3QgbWVyZ2VTdW1tYXJ5OiBNZXJnZVN1bW1hcnkgPSBhd2FpdCBnaXQubWVyZ2UobWVyZ2VPcHRpb25zKVxuICAgICAgLmNhdGNoKChlOiBHaXRSZXNwb25zZUVycm9yPE1lcmdlU3VtbWFyeT4pID0+IGUuZ2l0KTtcblxuIGlmIChtZXJnZVN1bW1hcnkuZmFpbGVkKSB7XG4gICAvLyBkZWFsIHdpdGggdGhlIGVycm9yXG4gfVxuIGBgYFxuICovXG5leHBvcnQgY2xhc3MgR2l0UmVzcG9uc2VFcnJvcjxUID0gYW55PiBleHRlbmRzIEdpdEVycm9yIHtcbiAgIGNvbnN0cnVjdG9yKFxuICAgICAgLyoqXG4gICAgICAgKiBgLmdpdGAgYWNjZXNzIHRoZSBwYXJzZWQgcmVzcG9uc2UgdGhhdCBpcyB0cmVhdGVkIGFzIGJlaW5nIGFuIGVycm9yXG4gICAgICAgKi9cbiAgICAgIHB1YmxpYyByZWFkb25seSBnaXQ6IFQsXG4gICAgICBtZXNzYWdlPzogc3RyaW5nXG4gICApIHtcbiAgICAgIHN1cGVyKHVuZGVmaW5lZCwgbWVzc2FnZSB8fCBTdHJpbmcoZ2l0KSk7XG4gICB9XG59XG4iLCAiaW1wb3J0IHsgR2l0RXJyb3IgfSBmcm9tICcuL2dpdC1lcnJvcic7XG5cbi8qKlxuICogVGhlIGBUYXNrQ29uZmlndXJhdGlvbkVycm9yYCBpcyB0aHJvd24gd2hlbiBhIGNvbW1hbmQgd2FzIGluY29ycmVjdGx5XG4gKiBjb25maWd1cmVkLiBBbiBlcnJvciBvZiB0aGlzIGtpbmQgbWVhbnMgdGhhdCBubyBhdHRlbXB0IHdhcyBtYWRlIHRvXG4gKiBydW4geW91ciBjb21tYW5kIHRocm91Z2ggdGhlIHVuZGVybHlpbmcgYGdpdGAgYmluYXJ5LlxuICpcbiAqIENoZWNrIHRoZSBgLm1lc3NhZ2VgIHByb3BlcnR5IGZvciBtb3JlIGRldGFpbCBvbiB3aHkgeW91ciBjb25maWd1cmF0aW9uXG4gKiByZXN1bHRlZCBpbiBhbiBlcnJvci5cbiAqL1xuZXhwb3J0IGNsYXNzIFRhc2tDb25maWd1cmF0aW9uRXJyb3IgZXh0ZW5kcyBHaXRFcnJvciB7XG4gICBjb25zdHJ1Y3RvcihtZXNzYWdlPzogc3RyaW5nKSB7XG4gICAgICBzdXBlcih1bmRlZmluZWQsIG1lc3NhZ2UpO1xuICAgfVxufVxuIiwgImltcG9ydCB7IGV4aXN0cywgRk9MREVSIH0gZnJvbSAnQGt3c2l0ZXMvZmlsZS1leGlzdHMnO1xuaW1wb3J0IHsgTWF5YmUgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjb25zdCBOVUxMID0gJ1xcMCc7XG5cbmV4cG9ydCBjb25zdCBOT09QOiAoLi4uYXJnczogYW55W10pID0+IHZvaWQgPSAoKSA9PiB7fTtcblxuLyoqXG4gKiBSZXR1cm5zIGVpdGhlciB0aGUgc291cmNlIGFyZ3VtZW50IHdoZW4gaXQgaXMgYSBgRnVuY3Rpb25gLCBvciB0aGUgZGVmYXVsdFxuICogYE5PT1BgIGZ1bmN0aW9uIGNvbnN0YW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc0Z1bmN0aW9uPFQgZXh0ZW5kcyAoKSA9PiBhbnk+KHNvdXJjZTogVCB8IGFueSk6IFQge1xuICAgcmV0dXJuIHR5cGVvZiBzb3VyY2UgPT09ICdmdW5jdGlvbicgPyBzb3VyY2UgOiBOT09QO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgc3VwcGxpZWQgYXJndW1lbnQgaXMgYm90aCBhIGZ1bmN0aW9uLCBhbmQgaXMgbm90XG4gKiB0aGUgYE5PT1BgIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNVc2VyRnVuY3Rpb248VCBleHRlbmRzIEZ1bmN0aW9uPihzb3VyY2U6IFQgfCBhbnkpOiBzb3VyY2UgaXMgVCB7XG4gICByZXR1cm4gdHlwZW9mIHNvdXJjZSA9PT0gJ2Z1bmN0aW9uJyAmJiBzb3VyY2UgIT09IE5PT1A7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzcGxpdE9uKGlucHV0OiBzdHJpbmcsIGNoYXI6IHN0cmluZyk6IFtzdHJpbmcsIHN0cmluZ10ge1xuICAgY29uc3QgaW5kZXggPSBpbnB1dC5pbmRleE9mKGNoYXIpO1xuICAgaWYgKGluZGV4IDw9IDApIHtcbiAgICAgIHJldHVybiBbaW5wdXQsICcnXTtcbiAgIH1cblxuICAgcmV0dXJuIFtpbnB1dC5zdWJzdHIoMCwgaW5kZXgpLCBpbnB1dC5zdWJzdHIoaW5kZXggKyAxKV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaXJzdDxUIGV4dGVuZHMgYW55W10+KGlucHV0OiBULCBvZmZzZXQ/OiBudW1iZXIpOiBNYXliZTxUW251bWJlcl0+O1xuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0PFQgZXh0ZW5kcyBJQXJndW1lbnRzPihpbnB1dDogVCwgb2Zmc2V0PzogbnVtYmVyKTogTWF5YmU8dW5rbm93bj47XG5leHBvcnQgZnVuY3Rpb24gZmlyc3QoaW5wdXQ6IGFueVtdIHwgSUFyZ3VtZW50cywgb2Zmc2V0ID0gMCk6IE1heWJlPHVua25vd24+IHtcbiAgIHJldHVybiBpc0FycmF5TGlrZShpbnB1dCkgJiYgaW5wdXQubGVuZ3RoID4gb2Zmc2V0ID8gaW5wdXRbb2Zmc2V0XSA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxhc3Q8VCBleHRlbmRzIGFueVtdPihpbnB1dDogVCwgb2Zmc2V0PzogbnVtYmVyKTogTWF5YmU8VFtudW1iZXJdPjtcbmV4cG9ydCBmdW5jdGlvbiBsYXN0PFQgZXh0ZW5kcyBJQXJndW1lbnRzPihpbnB1dDogVCwgb2Zmc2V0PzogbnVtYmVyKTogTWF5YmU8dW5rbm93bj47XG5leHBvcnQgZnVuY3Rpb24gbGFzdDxUPihpbnB1dDogVCwgb2Zmc2V0PzogbnVtYmVyKTogTWF5YmU8dW5rbm93bj47XG5leHBvcnQgZnVuY3Rpb24gbGFzdChpbnB1dDogdW5rbm93biwgb2Zmc2V0ID0gMCkge1xuICAgaWYgKGlzQXJyYXlMaWtlKGlucHV0KSAmJiBpbnB1dC5sZW5ndGggPiBvZmZzZXQpIHtcbiAgICAgIHJldHVybiBpbnB1dFtpbnB1dC5sZW5ndGggLSAxIC0gb2Zmc2V0XTtcbiAgIH1cbn1cblxudHlwZSBBcnJheUxpa2U8VCA9IGFueT4gPSBUW10gfCBJQXJndW1lbnRzIHwgeyBbaW5kZXg6IG51bWJlcl06IFQ7IGxlbmd0aDogbnVtYmVyIH07XG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKGlucHV0OiBhbnkpOiBpbnB1dCBpcyBBcnJheUxpa2Uge1xuICAgcmV0dXJuICEhKGlucHV0ICYmIHR5cGVvZiBpbnB1dC5sZW5ndGggPT09ICdudW1iZXInKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvTGluZXNXaXRoQ29udGVudChpbnB1dCA9ICcnLCB0cmltbWVkID0gdHJ1ZSwgc2VwYXJhdG9yID0gJ1xcbicpOiBzdHJpbmdbXSB7XG4gICByZXR1cm4gaW5wdXQuc3BsaXQoc2VwYXJhdG9yKS5yZWR1Y2UoKG91dHB1dCwgbGluZSkgPT4ge1xuICAgICAgY29uc3QgbGluZUNvbnRlbnQgPSB0cmltbWVkID8gbGluZS50cmltKCkgOiBsaW5lO1xuICAgICAgaWYgKGxpbmVDb250ZW50KSB7XG4gICAgICAgICBvdXRwdXQucHVzaChsaW5lQ29udGVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgfSwgW10gYXMgc3RyaW5nW10pO1xufVxuXG50eXBlIExpbmVXaXRoQ29udGVudENhbGxiYWNrPFQgPSB2b2lkPiA9IChsaW5lOiBzdHJpbmcpID0+IFQ7XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JFYWNoTGluZVdpdGhDb250ZW50PFQ+KFxuICAgaW5wdXQ6IHN0cmluZyxcbiAgIGNhbGxiYWNrOiBMaW5lV2l0aENvbnRlbnRDYWxsYmFjazxUPlxuKTogVFtdIHtcbiAgIHJldHVybiB0b0xpbmVzV2l0aENvbnRlbnQoaW5wdXQsIHRydWUpLm1hcCgobGluZSkgPT4gY2FsbGJhY2sobGluZSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9sZGVyRXhpc3RzKHBhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgcmV0dXJuIGV4aXN0cyhwYXRoLCBGT0xERVIpO1xufVxuXG4vKipcbiAqIEFkZHMgYGl0ZW1gIGludG8gdGhlIGB0YXJnZXRgIGBBcnJheWAgb3IgYFNldGAgd2hlbiBpdCBpcyBub3QgYWxyZWFkeSBwcmVzZW50IGFuZCByZXR1cm5zIHRoZSBgaXRlbWAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmQ8VD4odGFyZ2V0OiBUW10gfCBTZXQ8VD4sIGl0ZW06IFQpOiB0eXBlb2YgaXRlbSB7XG4gICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICBpZiAoIXRhcmdldC5pbmNsdWRlcyhpdGVtKSkge1xuICAgICAgICAgdGFyZ2V0LnB1c2goaXRlbSk7XG4gICAgICB9XG4gICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0LmFkZChpdGVtKTtcbiAgIH1cbiAgIHJldHVybiBpdGVtO1xufVxuXG4vKipcbiAqIEFkZHMgYGl0ZW1gIGludG8gdGhlIGB0YXJnZXRgIGBBcnJheWAgd2hlbiBpdCBpcyBub3QgYWxyZWFkeSBwcmVzZW50IGFuZCByZXR1cm5zIHRoZSBgdGFyZ2V0YC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluY2x1ZGluZzxUPih0YXJnZXQ6IFRbXSwgaXRlbTogVCk6IHR5cGVvZiB0YXJnZXQge1xuICAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiAhdGFyZ2V0LmluY2x1ZGVzKGl0ZW0pKSB7XG4gICAgICB0YXJnZXQucHVzaChpdGVtKTtcbiAgIH1cblxuICAgcmV0dXJuIHRhcmdldDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZTxUPih0YXJnZXQ6IFNldDxUPiB8IFRbXSwgaXRlbTogVCk6IFQge1xuICAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgY29uc3QgaW5kZXggPSB0YXJnZXQuaW5kZXhPZihpdGVtKTtcbiAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICB0YXJnZXQuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQuZGVsZXRlKGl0ZW0pO1xuICAgfVxuICAgcmV0dXJuIGl0ZW07XG59XG5cbmV4cG9ydCBjb25zdCBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpIGFzIChcbiAgIGlucHV0OiBhbnlcbikgPT4gc3RyaW5nO1xuXG5leHBvcnQgZnVuY3Rpb24gYXNBcnJheTxUPihzb3VyY2U6IFQgfCBUW10pOiBUW10ge1xuICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoc291cmNlKSA/IHNvdXJjZSA6IFtzb3VyY2VdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNDYW1lbENhc2Uoc3RyOiBzdHJpbmcpIHtcbiAgIHJldHVybiBzdHIucmVwbGFjZSgvW1xccy1dKyguKS9nLCAoX2FsbCwgY2hyKSA9PiB7XG4gICAgICByZXR1cm4gY2hyLnRvVXBwZXJDYXNlKCk7XG4gICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzU3RyaW5nQXJyYXk8VD4oc291cmNlOiBUIHwgVFtdKTogc3RyaW5nW10ge1xuICAgcmV0dXJuIGFzQXJyYXkoc291cmNlKS5tYXAoU3RyaW5nKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzTnVtYmVyKHNvdXJjZTogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCwgb25OYU4gPSAwKSB7XG4gICBpZiAoc291cmNlID09IG51bGwpIHtcbiAgICAgIHJldHVybiBvbk5hTjtcbiAgIH1cblxuICAgY29uc3QgbnVtID0gcGFyc2VJbnQoc291cmNlLCAxMCk7XG4gICByZXR1cm4gaXNOYU4obnVtKSA/IG9uTmFOIDogbnVtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJlZml4ZWRBcnJheTxUPihpbnB1dDogVFtdLCBwcmVmaXg6IFQpOiBUW10ge1xuICAgY29uc3Qgb3V0cHV0OiBUW10gPSBbXTtcbiAgIGZvciAobGV0IGkgPSAwLCBtYXggPSBpbnB1dC5sZW5ndGg7IGkgPCBtYXg7IGkrKykge1xuICAgICAgb3V0cHV0LnB1c2gocHJlZml4LCBpbnB1dFtpXSk7XG4gICB9XG4gICByZXR1cm4gb3V0cHV0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVmZmVyVG9TdHJpbmcoaW5wdXQ6IEJ1ZmZlciB8IEJ1ZmZlcltdKTogc3RyaW5nIHtcbiAgIHJldHVybiAoQXJyYXkuaXNBcnJheShpbnB1dCkgPyBCdWZmZXIuY29uY2F0KGlucHV0KSA6IGlucHV0KS50b1N0cmluZygndXRmLTgnKTtcbn1cblxuLyoqXG4gKiBHZXQgYSBuZXcgb2JqZWN0IGZyb20gYSBzb3VyY2Ugb2JqZWN0IHdpdGggb25seSB0aGUgbGlzdGVkIHByb3BlcnRpZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwaWNrKHNvdXJjZTogUmVjb3JkPHN0cmluZywgYW55PiwgcHJvcGVydGllczogc3RyaW5nW10pIHtcbiAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAge30sXG4gICAgICAuLi5wcm9wZXJ0aWVzLm1hcCgocHJvcGVydHkpID0+IChwcm9wZXJ0eSBpbiBzb3VyY2UgPyB7IFtwcm9wZXJ0eV06IHNvdXJjZVtwcm9wZXJ0eV0gfSA6IHt9KSlcbiAgICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWxheShkdXJhdGlvbiA9IDApOiBQcm9taXNlPHZvaWQ+IHtcbiAgIHJldHVybiBuZXcgUHJvbWlzZSgoZG9uZSkgPT4gc2V0VGltZW91dChkb25lLCBkdXJhdGlvbikpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb3JWb2lkPFQ+KGlucHV0OiBUIHwgZmFsc2UpIHtcbiAgIGlmIChpbnB1dCA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICB9XG4gICByZXR1cm4gaW5wdXQ7XG59XG4iLCAiaW1wb3J0IHsgTWF5YmUsIE9wdGlvbnMsIFByaW1pdGl2ZXMgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBvYmplY3RUb1N0cmluZyB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgeyBpc1BhdGhTcGVjIH0gZnJvbSAnLi4vYXJncy9wYXRoc3BlYyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXJndW1lbnRGaWx0ZXJQcmVkaWNhdGU8VD4ge1xuICAgKGlucHV0OiBhbnkpOiBpbnB1dCBpcyBUO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyVHlwZTxULCBLPihcbiAgIGlucHV0OiBLLFxuICAgZmlsdGVyOiBBcmd1bWVudEZpbHRlclByZWRpY2F0ZTxUPlxuKTogSyBleHRlbmRzIFQgPyBUIDogdW5kZWZpbmVkO1xuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlclR5cGU8VCwgSz4oaW5wdXQ6IEssIGZpbHRlcjogQXJndW1lbnRGaWx0ZXJQcmVkaWNhdGU8VD4sIGRlZjogVCk6IFQ7XG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyVHlwZTxULCBLPihpbnB1dDogSywgZmlsdGVyOiBBcmd1bWVudEZpbHRlclByZWRpY2F0ZTxUPiwgZGVmPzogVCk6IE1heWJlPFQ+IHtcbiAgIGlmIChmaWx0ZXIoaW5wdXQpKSB7XG4gICAgICByZXR1cm4gaW5wdXQ7XG4gICB9XG4gICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBkZWYgOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBjb25zdCBmaWx0ZXJBcnJheTogQXJndW1lbnRGaWx0ZXJQcmVkaWNhdGU8QXJyYXk8YW55Pj4gPSAoaW5wdXQpOiBpbnB1dCBpcyBBcnJheTxhbnk+ID0+IHtcbiAgIHJldHVybiBBcnJheS5pc0FycmF5KGlucHV0KTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJQcmltaXRpdmVzKFxuICAgaW5wdXQ6IHVua25vd24sXG4gICBvbWl0PzogQXJyYXk8J2Jvb2xlYW4nIHwgJ3N0cmluZycgfCAnbnVtYmVyJz5cbik6IGlucHV0IGlzIFByaW1pdGl2ZXMge1xuICAgY29uc3QgdHlwZSA9IGlzUGF0aFNwZWMoaW5wdXQpID8gJ3N0cmluZycgOiB0eXBlb2YgaW5wdXQ7XG5cbiAgIHJldHVybiAoXG4gICAgICAvbnVtYmVyfHN0cmluZ3xib29sZWFuLy50ZXN0KHR5cGUpICYmXG4gICAgICAoIW9taXQgfHwgIW9taXQuaW5jbHVkZXModHlwZSBhcyAnYm9vbGVhbicgfCAnc3RyaW5nJyB8ICdudW1iZXInKSlcbiAgICk7XG59XG5cbmV4cG9ydCBjb25zdCBmaWx0ZXJTdHJpbmc6IEFyZ3VtZW50RmlsdGVyUHJlZGljYXRlPHN0cmluZz4gPSAoaW5wdXQpOiBpbnB1dCBpcyBzdHJpbmcgPT4ge1xuICAgcmV0dXJuIHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZyc7XG59O1xuXG5leHBvcnQgY29uc3QgZmlsdGVyU3RyaW5nQXJyYXk6IEFyZ3VtZW50RmlsdGVyUHJlZGljYXRlPHN0cmluZ1tdPiA9IChpbnB1dCk6IGlucHV0IGlzIHN0cmluZ1tdID0+IHtcbiAgIHJldHVybiBBcnJheS5pc0FycmF5KGlucHV0KSAmJiBpbnB1dC5ldmVyeShmaWx0ZXJTdHJpbmcpO1xufTtcblxuZXhwb3J0IGNvbnN0IGZpbHRlclN0cmluZ09yU3RyaW5nQXJyYXk6IEFyZ3VtZW50RmlsdGVyUHJlZGljYXRlPHN0cmluZyB8IHN0cmluZ1tdPiA9IChcbiAgIGlucHV0XG4pOiBpbnB1dCBpcyBzdHJpbmcgfCBzdHJpbmdbXSA9PiB7XG4gICByZXR1cm4gZmlsdGVyU3RyaW5nKGlucHV0KSB8fCAoQXJyYXkuaXNBcnJheShpbnB1dCkgJiYgaW5wdXQuZXZlcnkoZmlsdGVyU3RyaW5nKSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyUGxhaW5PYmplY3Q8VCBleHRlbmRzIE9wdGlvbnM+KGlucHV0OiBUIHwgdW5rbm93bik6IGlucHV0IGlzIFQ7XG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyUGxhaW5PYmplY3Q8VCBleHRlbmRzIE9iamVjdD4oaW5wdXQ6IFQgfCB1bmtub3duKTogaW5wdXQgaXMgVCB7XG4gICByZXR1cm4gISFpbnB1dCAmJiBvYmplY3RUb1N0cmluZyhpbnB1dCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyRnVuY3Rpb24oaW5wdXQ6IHVua25vd24pOiBpbnB1dCBpcyBGdW5jdGlvbiB7XG4gICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nO1xufVxuXG5leHBvcnQgY29uc3QgZmlsdGVySGFzTGVuZ3RoOiBBcmd1bWVudEZpbHRlclByZWRpY2F0ZTx7IGxlbmd0aDogbnVtYmVyIH0+ID0gKFxuICAgaW5wdXRcbik6IGlucHV0IGlzIHsgbGVuZ3RoOiBudW1iZXIgfSA9PiB7XG4gICBpZiAoaW5wdXQgPT0gbnVsbCB8fCAnbnVtYmVyfGJvb2xlYW58ZnVuY3Rpb24nLmluY2x1ZGVzKHR5cGVvZiBpbnB1dCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgIH1cbiAgIHJldHVybiBBcnJheS5pc0FycmF5KGlucHV0KSB8fCB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBpbnB1dC5sZW5ndGggPT09ICdudW1iZXInO1xufTtcbiIsICIvKipcbiAqIEtub3duIHByb2Nlc3MgZXhpdCBjb2RlcyB1c2VkIGJ5IHRoZSB0YXNrIHBhcnNlcnMgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYW4gZXJyb3JcbiAqIHdhcyBvbmUgdGhleSBjYW4gYXV0b21hdGljYWxseSBoYW5kbGVcbiAqL1xuZXhwb3J0IGVudW0gRXhpdENvZGVzIHtcbiAgIFNVQ0NFU1MsXG4gICBFUlJPUixcbiAgIE5PVF9GT1VORCA9IC0yLFxuICAgVU5DTEVBTiA9IDEyOCxcbn1cbiIsICJpbXBvcnQgeyBUYXNrUmVzcG9uc2VGb3JtYXQgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBHaXRPdXRwdXRTdHJlYW1zPFQgZXh0ZW5kcyBUYXNrUmVzcG9uc2VGb3JtYXQgPSBCdWZmZXI+IHtcbiAgIGNvbnN0cnVjdG9yKFxuICAgICAgcHVibGljIHJlYWRvbmx5IHN0ZE91dDogVCxcbiAgICAgIHB1YmxpYyByZWFkb25seSBzdGRFcnI6IFRcbiAgICkge31cblxuICAgYXNTdHJpbmdzKCk6IEdpdE91dHB1dFN0cmVhbXM8c3RyaW5nPiB7XG4gICAgICByZXR1cm4gbmV3IEdpdE91dHB1dFN0cmVhbXModGhpcy5zdGRPdXQudG9TdHJpbmcoJ3V0ZjgnKSwgdGhpcy5zdGRFcnIudG9TdHJpbmcoJ3V0ZjgnKSk7XG4gICB9XG59XG4iLCAiZXhwb3J0IGNsYXNzIExpbmVQYXJzZXI8VD4ge1xuICAgcHJvdGVjdGVkIG1hdGNoZXM6IHN0cmluZ1tdID0gW107XG5cbiAgIHByaXZhdGUgX3JlZ0V4cDogUmVnRXhwW107XG5cbiAgIGNvbnN0cnVjdG9yKFxuICAgICAgcmVnRXhwOiBSZWdFeHAgfCBSZWdFeHBbXSxcbiAgICAgIHVzZU1hdGNoZXM/OiAodGFyZ2V0OiBULCBtYXRjaDogc3RyaW5nW10pID0+IGJvb2xlYW4gfCB2b2lkXG4gICApIHtcbiAgICAgIHRoaXMuX3JlZ0V4cCA9IEFycmF5LmlzQXJyYXkocmVnRXhwKSA/IHJlZ0V4cCA6IFtyZWdFeHBdO1xuICAgICAgaWYgKHVzZU1hdGNoZXMpIHtcbiAgICAgICAgIHRoaXMudXNlTWF0Y2hlcyA9IHVzZU1hdGNoZXM7XG4gICAgICB9XG4gICB9XG5cbiAgIHBhcnNlID0gKGxpbmU6IChvZmZzZXQ6IG51bWJlcikgPT4gc3RyaW5nIHwgdW5kZWZpbmVkLCB0YXJnZXQ6IFQpOiBib29sZWFuID0+IHtcbiAgICAgIHRoaXMucmVzZXRNYXRjaGVzKCk7XG5cbiAgICAgIGlmICghdGhpcy5fcmVnRXhwLmV2ZXJ5KChyZWcsIGluZGV4KSA9PiB0aGlzLmFkZE1hdGNoKHJlZywgaW5kZXgsIGxpbmUoaW5kZXgpKSkpIHtcbiAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMudXNlTWF0Y2hlcyh0YXJnZXQsIHRoaXMucHJlcGFyZU1hdGNoZXMoKSkgIT09IGZhbHNlO1xuICAgfTtcblxuICAgLy8gQHRzLWlnbm9yZVxuICAgcHJvdGVjdGVkIHVzZU1hdGNoZXModGFyZ2V0OiBULCBtYXRjaDogc3RyaW5nW10pOiBib29sZWFuIHwgdm9pZCB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYExpbmVQYXJzZXI6dXNlTWF0Y2hlcyBub3QgaW1wbGVtZW50ZWRgKTtcbiAgIH1cblxuICAgcHJvdGVjdGVkIHJlc2V0TWF0Y2hlcygpIHtcbiAgICAgIHRoaXMubWF0Y2hlcy5sZW5ndGggPSAwO1xuICAgfVxuXG4gICBwcm90ZWN0ZWQgcHJlcGFyZU1hdGNoZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXRjaGVzO1xuICAgfVxuXG4gICBwcm90ZWN0ZWQgYWRkTWF0Y2gocmVnOiBSZWdFeHAsIGluZGV4OiBudW1iZXIsIGxpbmU/OiBzdHJpbmcpIHtcbiAgICAgIGNvbnN0IG1hdGNoZWQgPSBsaW5lICYmIHJlZy5leGVjKGxpbmUpO1xuICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgIHRoaXMucHVzaE1hdGNoKGluZGV4LCBtYXRjaGVkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICEhbWF0Y2hlZDtcbiAgIH1cblxuICAgcHJvdGVjdGVkIHB1c2hNYXRjaChfaW5kZXg6IG51bWJlciwgbWF0Y2hlZDogc3RyaW5nW10pIHtcbiAgICAgIHRoaXMubWF0Y2hlcy5wdXNoKC4uLm1hdGNoZWQuc2xpY2UoMSkpO1xuICAgfVxufVxuXG5leHBvcnQgY2xhc3MgUmVtb3RlTGluZVBhcnNlcjxUPiBleHRlbmRzIExpbmVQYXJzZXI8VD4ge1xuICAgcHJvdGVjdGVkIGFkZE1hdGNoKHJlZzogUmVnRXhwLCBpbmRleDogbnVtYmVyLCBsaW5lPzogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4gL15yZW1vdGU6XFxzLy50ZXN0KFN0cmluZyhsaW5lKSkgJiYgc3VwZXIuYWRkTWF0Y2gocmVnLCBpbmRleCwgbGluZSk7XG4gICB9XG5cbiAgIHByb3RlY3RlZCBwdXNoTWF0Y2goaW5kZXg6IG51bWJlciwgbWF0Y2hlZDogc3RyaW5nW10pIHtcbiAgICAgIGlmIChpbmRleCA+IDAgfHwgbWF0Y2hlZC5sZW5ndGggPiAxKSB7XG4gICAgICAgICBzdXBlci5wdXNoTWF0Y2goaW5kZXgsIG1hdGNoZWQpO1xuICAgICAgfVxuICAgfVxufVxuIiwgImltcG9ydCB7IFNpbXBsZUdpdE9wdGlvbnMgfSBmcm9tICcuLi90eXBlcyc7XG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zOiBPbWl0PFNpbXBsZUdpdE9wdGlvbnMsICdiYXNlRGlyJz4gPSB7XG4gICBiaW5hcnk6ICdnaXQnLFxuICAgbWF4Q29uY3VycmVudFByb2Nlc3NlczogNSxcbiAgIGNvbmZpZzogW10sXG4gICB0cmltbWVkOiBmYWxzZSxcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZUNvbmZpZyhcbiAgIC4uLm9wdGlvbnM6IEFycmF5PFBhcnRpYWw8U2ltcGxlR2l0T3B0aW9ucz4gfCB1bmRlZmluZWQ+XG4pOiBTaW1wbGVHaXRPcHRpb25zIHtcbiAgIGNvbnN0IGJhc2VEaXIgPSBwcm9jZXNzLmN3ZCgpO1xuICAgY29uc3QgY29uZmlnOiBTaW1wbGVHaXRPcHRpb25zID0gT2JqZWN0LmFzc2lnbihcbiAgICAgIHsgYmFzZURpciwgLi4uZGVmYXVsdE9wdGlvbnMgfSxcbiAgICAgIC4uLm9wdGlvbnMuZmlsdGVyKChvKSA9PiB0eXBlb2YgbyA9PT0gJ29iamVjdCcgJiYgbylcbiAgICk7XG5cbiAgIGNvbmZpZy5iYXNlRGlyID0gY29uZmlnLmJhc2VEaXIgfHwgYmFzZURpcjtcbiAgIGNvbmZpZy50cmltbWVkID0gY29uZmlnLnRyaW1tZWQgPT09IHRydWU7XG5cbiAgIHJldHVybiBjb25maWc7XG59XG4iLCAiaW1wb3J0IHtcbiAgIGZpbHRlckFycmF5LFxuICAgZmlsdGVyRnVuY3Rpb24sXG4gICBmaWx0ZXJQbGFpbk9iamVjdCxcbiAgIGZpbHRlclByaW1pdGl2ZXMsXG4gICBmaWx0ZXJUeXBlLFxufSBmcm9tICcuL2FyZ3VtZW50LWZpbHRlcnMnO1xuaW1wb3J0IHsgYXNGdW5jdGlvbiwgaXNVc2VyRnVuY3Rpb24sIGxhc3QgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsgTWF5YmUsIE9wdGlvbnMsIE9wdGlvbnNWYWx1ZXMgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBpc1BhdGhTcGVjIH0gZnJvbSAnLi4vYXJncy9wYXRoc3BlYyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRUYXNrT3B0aW9uczxUIGV4dGVuZHMgT3B0aW9ucyA9IE9wdGlvbnM+KFxuICAgb3B0aW9uczogTWF5YmU8VD4sXG4gICBjb21tYW5kczogc3RyaW5nW10gPSBbXVxuKTogc3RyaW5nW10ge1xuICAgaWYgKCFmaWx0ZXJQbGFpbk9iamVjdDxPcHRpb25zPihvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIGNvbW1hbmRzO1xuICAgfVxuXG4gICByZXR1cm4gT2JqZWN0LmtleXMob3B0aW9ucykucmVkdWNlKChjb21tYW5kczogc3RyaW5nW10sIGtleTogc3RyaW5nKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZTogT3B0aW9uc1ZhbHVlcyA9IG9wdGlvbnNba2V5XTtcblxuICAgICAgaWYgKGlzUGF0aFNwZWModmFsdWUpKSB7XG4gICAgICAgICBjb21tYW5kcy5wdXNoKHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoZmlsdGVyUHJpbWl0aXZlcyh2YWx1ZSwgWydib29sZWFuJ10pKSB7XG4gICAgICAgICBjb21tYW5kcy5wdXNoKGtleSArICc9JyArIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICBjb21tYW5kcy5wdXNoKGtleSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb21tYW5kcztcbiAgIH0sIGNvbW1hbmRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRyYWlsaW5nT3B0aW9ucyhcbiAgIGFyZ3M6IElBcmd1bWVudHMsXG4gICBpbml0aWFsUHJpbWl0aXZlID0gMCxcbiAgIG9iamVjdE9ubHkgPSBmYWxzZVxuKTogc3RyaW5nW10ge1xuICAgY29uc3QgY29tbWFuZDogc3RyaW5nW10gPSBbXTtcblxuICAgZm9yIChsZXQgaSA9IDAsIG1heCA9IGluaXRpYWxQcmltaXRpdmUgPCAwID8gYXJncy5sZW5ndGggOiBpbml0aWFsUHJpbWl0aXZlOyBpIDwgbWF4OyBpKyspIHtcbiAgICAgIGlmICgnc3RyaW5nfG51bWJlcicuaW5jbHVkZXModHlwZW9mIGFyZ3NbaV0pKSB7XG4gICAgICAgICBjb21tYW5kLnB1c2goU3RyaW5nKGFyZ3NbaV0pKTtcbiAgICAgIH1cbiAgIH1cblxuICAgYXBwZW5kVGFza09wdGlvbnModHJhaWxpbmdPcHRpb25zQXJndW1lbnQoYXJncyksIGNvbW1hbmQpO1xuICAgaWYgKCFvYmplY3RPbmx5KSB7XG4gICAgICBjb21tYW5kLnB1c2goLi4udHJhaWxpbmdBcnJheUFyZ3VtZW50KGFyZ3MpKTtcbiAgIH1cblxuICAgcmV0dXJuIGNvbW1hbmQ7XG59XG5cbmZ1bmN0aW9uIHRyYWlsaW5nQXJyYXlBcmd1bWVudChhcmdzOiBJQXJndW1lbnRzKSB7XG4gICBjb25zdCBoYXNUcmFpbGluZ0NhbGxiYWNrID0gdHlwZW9mIGxhc3QoYXJncykgPT09ICdmdW5jdGlvbic7XG4gICByZXR1cm4gZmlsdGVyVHlwZShsYXN0KGFyZ3MsIGhhc1RyYWlsaW5nQ2FsbGJhY2sgPyAxIDogMCksIGZpbHRlckFycmF5LCBbXSk7XG59XG5cbi8qKlxuICogR2l2ZW4gYW55IG51bWJlciBvZiBhcmd1bWVudHMsIHJldHVybnMgdGhlIHRyYWlsaW5nIG9wdGlvbnMgYXJndW1lbnQsIGlnbm9yaW5nIGEgdHJhaWxpbmcgZnVuY3Rpb24gYXJndW1lbnRcbiAqIGlmIHRoZXJlIGlzIG9uZS4gV2hlbiBub3QgZm91bmQsIHRoZSByZXR1cm4gdmFsdWUgaXMgbnVsbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYWlsaW5nT3B0aW9uc0FyZ3VtZW50KGFyZ3M6IElBcmd1bWVudHMpOiBNYXliZTxPcHRpb25zPiB7XG4gICBjb25zdCBoYXNUcmFpbGluZ0NhbGxiYWNrID0gZmlsdGVyRnVuY3Rpb24obGFzdChhcmdzKSk7XG4gICByZXR1cm4gZmlsdGVyVHlwZShsYXN0KGFyZ3MsIGhhc1RyYWlsaW5nQ2FsbGJhY2sgPyAxIDogMCksIGZpbHRlclBsYWluT2JqZWN0KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGVpdGhlciB0aGUgc291cmNlIGFyZ3VtZW50IHdoZW4gaXQgaXMgYSBgRnVuY3Rpb25gLCBvciB0aGUgZGVmYXVsdFxuICogYE5PT1BgIGZ1bmN0aW9uIGNvbnN0YW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoXG4gICBhcmdzOiB1bmtub3duW10gfCBJQXJndW1lbnRzIHwgdW5rbm93bixcbiAgIGluY2x1ZGVOb29wID0gdHJ1ZVxuKTogTWF5YmU8KC4uLmFyZ3M6IGFueVtdKSA9PiB1bmtub3duPiB7XG4gICBjb25zdCBjYWxsYmFjayA9IGFzRnVuY3Rpb24obGFzdChhcmdzKSk7XG4gICByZXR1cm4gaW5jbHVkZU5vb3AgfHwgaXNVc2VyRnVuY3Rpb24oY2FsbGJhY2spID8gY2FsbGJhY2sgOiB1bmRlZmluZWQ7XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBNYXliZUFycmF5LCBUYXNrUGFyc2VyLCBUYXNrUmVzcG9uc2VGb3JtYXQgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBHaXRPdXRwdXRTdHJlYW1zIH0gZnJvbSAnLi9naXQtb3V0cHV0LXN0cmVhbXMnO1xuaW1wb3J0IHsgTGluZVBhcnNlciB9IGZyb20gJy4vbGluZS1wYXJzZXInO1xuaW1wb3J0IHsgYXNBcnJheSwgdG9MaW5lc1dpdGhDb250ZW50IH0gZnJvbSAnLi91dGlsJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGxUYXNrUGFyc2VyPElOUFVUIGV4dGVuZHMgVGFza1Jlc3BvbnNlRm9ybWF0LCBSRVNQT05TRT4oXG4gICBwYXJzZXI6IFRhc2tQYXJzZXI8SU5QVVQsIFJFU1BPTlNFPixcbiAgIHN0cmVhbXM6IEdpdE91dHB1dFN0cmVhbXM8SU5QVVQ+XG4pIHtcbiAgIHJldHVybiBwYXJzZXIoc3RyZWFtcy5zdGRPdXQsIHN0cmVhbXMuc3RkRXJyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU3RyaW5nUmVzcG9uc2U8VD4oXG4gICByZXN1bHQ6IFQsXG4gICBwYXJzZXJzOiBMaW5lUGFyc2VyPFQ+W10sXG4gICB0ZXh0czogTWF5YmVBcnJheTxzdHJpbmc+LFxuICAgdHJpbSA9IHRydWVcbik6IFQge1xuICAgYXNBcnJheSh0ZXh0cykuZm9yRWFjaCgodGV4dCkgPT4ge1xuICAgICAgZm9yIChsZXQgbGluZXMgPSB0b0xpbmVzV2l0aENvbnRlbnQodGV4dCwgdHJpbSksIGkgPSAwLCBtYXggPSBsaW5lcy5sZW5ndGg7IGkgPCBtYXg7IGkrKykge1xuICAgICAgICAgY29uc3QgbGluZSA9IChvZmZzZXQgPSAwKSA9PiB7XG4gICAgICAgICAgICBpZiAoaSArIG9mZnNldCA+PSBtYXgpIHtcbiAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsaW5lc1tpICsgb2Zmc2V0XTtcbiAgICAgICAgIH07XG5cbiAgICAgICAgIHBhcnNlcnMuc29tZSgoeyBwYXJzZSB9KSA9PiBwYXJzZShsaW5lLCByZXN1bHQpKTtcbiAgICAgIH1cbiAgIH0pO1xuXG4gICByZXR1cm4gcmVzdWx0O1xufVxuIiwgImV4cG9ydCAqIGZyb20gJy4vYXJndW1lbnQtZmlsdGVycyc7XG5leHBvcnQgKiBmcm9tICcuL2V4aXQtY29kZXMnO1xuZXhwb3J0ICogZnJvbSAnLi9naXQtb3V0cHV0LXN0cmVhbXMnO1xuZXhwb3J0ICogZnJvbSAnLi9saW5lLXBhcnNlcic7XG5leHBvcnQgKiBmcm9tICcuL3NpbXBsZS1naXQtb3B0aW9ucyc7XG5leHBvcnQgKiBmcm9tICcuL3Rhc2stb3B0aW9ucyc7XG5leHBvcnQgKiBmcm9tICcuL3Rhc2stcGFyc2VyJztcbmV4cG9ydCAqIGZyb20gJy4vdXRpbCc7XG4iLCAiaW1wb3J0IHsgRXhpdENvZGVzIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgTWF5YmUsIFN0cmluZ1Rhc2sgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBlbnVtIENoZWNrUmVwb0FjdGlvbnMge1xuICAgQkFSRSA9ICdiYXJlJyxcbiAgIElOX1RSRUUgPSAndHJlZScsXG4gICBJU19SRVBPX1JPT1QgPSAncm9vdCcsXG59XG5cbmNvbnN0IG9uRXJyb3I6IFN0cmluZ1Rhc2s8Ym9vbGVhbj5bJ29uRXJyb3InXSA9ICh7IGV4aXRDb2RlIH0sIGVycm9yLCBkb25lLCBmYWlsKSA9PiB7XG4gICBpZiAoZXhpdENvZGUgPT09IEV4aXRDb2Rlcy5VTkNMRUFOICYmIGlzTm90UmVwb01lc3NhZ2UoZXJyb3IpKSB7XG4gICAgICByZXR1cm4gZG9uZShCdWZmZXIuZnJvbSgnZmFsc2UnKSk7XG4gICB9XG5cbiAgIGZhaWwoZXJyb3IpO1xufTtcblxuY29uc3QgcGFyc2VyOiBTdHJpbmdUYXNrPGJvb2xlYW4+WydwYXJzZXInXSA9ICh0ZXh0KSA9PiB7XG4gICByZXR1cm4gdGV4dC50cmltKCkgPT09ICd0cnVlJztcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja0lzUmVwb1Rhc2soYWN0aW9uOiBNYXliZTxDaGVja1JlcG9BY3Rpb25zPik6IFN0cmluZ1Rhc2s8Ym9vbGVhbj4ge1xuICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgIGNhc2UgQ2hlY2tSZXBvQWN0aW9ucy5CQVJFOlxuICAgICAgICAgcmV0dXJuIGNoZWNrSXNCYXJlUmVwb1Rhc2soKTtcbiAgICAgIGNhc2UgQ2hlY2tSZXBvQWN0aW9ucy5JU19SRVBPX1JPT1Q6XG4gICAgICAgICByZXR1cm4gY2hlY2tJc1JlcG9Sb290VGFzaygpO1xuICAgfVxuXG4gICBjb25zdCBjb21tYW5kcyA9IFsncmV2LXBhcnNlJywgJy0taXMtaW5zaWRlLXdvcmstdHJlZSddO1xuXG4gICByZXR1cm4ge1xuICAgICAgY29tbWFuZHMsXG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBvbkVycm9yLFxuICAgICAgcGFyc2VyLFxuICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrSXNSZXBvUm9vdFRhc2soKTogU3RyaW5nVGFzazxib29sZWFuPiB7XG4gICBjb25zdCBjb21tYW5kcyA9IFsncmV2LXBhcnNlJywgJy0tZ2l0LWRpciddO1xuXG4gICByZXR1cm4ge1xuICAgICAgY29tbWFuZHMsXG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBvbkVycm9yLFxuICAgICAgcGFyc2VyKHBhdGgpIHtcbiAgICAgICAgIHJldHVybiAvXlxcLihnaXQpPyQvLnRlc3QocGF0aC50cmltKCkpO1xuICAgICAgfSxcbiAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja0lzQmFyZVJlcG9UYXNrKCk6IFN0cmluZ1Rhc2s8Ym9vbGVhbj4ge1xuICAgY29uc3QgY29tbWFuZHMgPSBbJ3Jldi1wYXJzZScsICctLWlzLWJhcmUtcmVwb3NpdG9yeSddO1xuXG4gICByZXR1cm4ge1xuICAgICAgY29tbWFuZHMsXG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBvbkVycm9yLFxuICAgICAgcGFyc2VyLFxuICAgfTtcbn1cblxuZnVuY3Rpb24gaXNOb3RSZXBvTWVzc2FnZShlcnJvcjogRXJyb3IpOiBib29sZWFuIHtcbiAgIHJldHVybiAvKE5vdCBhIGdpdCByZXBvc2l0b3J5fEtlaW4gR2l0LVJlcG9zaXRvcnkpL2kudGVzdChTdHJpbmcoZXJyb3IpKTtcbn1cbiIsICJpbXBvcnQgeyBDbGVhblN1bW1hcnkgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IHRvTGluZXNXaXRoQ29udGVudCB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGNsYXNzIENsZWFuUmVzcG9uc2UgaW1wbGVtZW50cyBDbGVhblN1bW1hcnkge1xuICAgcHVibGljIHBhdGhzOiBzdHJpbmdbXSA9IFtdO1xuICAgcHVibGljIGZpbGVzOiBzdHJpbmdbXSA9IFtdO1xuICAgcHVibGljIGZvbGRlcnM6IHN0cmluZ1tdID0gW107XG5cbiAgIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSBkcnlSdW46IGJvb2xlYW4pIHt9XG59XG5cbmNvbnN0IHJlbW92YWxSZWdleHAgPSAvXlthLXpdK1xccyovaTtcbmNvbnN0IGRyeVJ1blJlbW92YWxSZWdleHAgPSAvXlthLXpdK1xccytbYS16XStcXHMqL2k7XG5jb25zdCBpc0ZvbGRlclJlZ2V4cCA9IC9cXC8kLztcblxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFuU3VtbWFyeVBhcnNlcihkcnlSdW46IGJvb2xlYW4sIHRleHQ6IHN0cmluZyk6IENsZWFuU3VtbWFyeSB7XG4gICBjb25zdCBzdW1tYXJ5ID0gbmV3IENsZWFuUmVzcG9uc2UoZHJ5UnVuKTtcbiAgIGNvbnN0IHJlZ2V4cCA9IGRyeVJ1biA/IGRyeVJ1blJlbW92YWxSZWdleHAgOiByZW1vdmFsUmVnZXhwO1xuXG4gICB0b0xpbmVzV2l0aENvbnRlbnQodGV4dCkuZm9yRWFjaCgobGluZSkgPT4ge1xuICAgICAgY29uc3QgcmVtb3ZlZCA9IGxpbmUucmVwbGFjZShyZWdleHAsICcnKTtcblxuICAgICAgc3VtbWFyeS5wYXRocy5wdXNoKHJlbW92ZWQpO1xuICAgICAgKGlzRm9sZGVyUmVnZXhwLnRlc3QocmVtb3ZlZCkgPyBzdW1tYXJ5LmZvbGRlcnMgOiBzdW1tYXJ5LmZpbGVzKS5wdXNoKHJlbW92ZWQpO1xuICAgfSk7XG5cbiAgIHJldHVybiBzdW1tYXJ5O1xufVxuIiwgImltcG9ydCB7IFRhc2tDb25maWd1cmF0aW9uRXJyb3IgfSBmcm9tICcuLi9lcnJvcnMvdGFzay1jb25maWd1cmF0aW9uLWVycm9yJztcbmltcG9ydCB0eXBlIHsgQnVmZmVyVGFzaywgRW1wdHlUYXNrUGFyc2VyLCBTaW1wbGVHaXRUYXNrLCBTdHJpbmdUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY29uc3QgRU1QVFlfQ09NTUFORFM6IFtdID0gW107XG5cbmV4cG9ydCB0eXBlIEVtcHR5VGFzayA9IHtcbiAgIGNvbW1hbmRzOiB0eXBlb2YgRU1QVFlfQ09NTUFORFM7XG4gICBmb3JtYXQ6ICdlbXB0eSc7XG4gICBwYXJzZXI6IEVtcHR5VGFza1BhcnNlcjtcbiAgIG9uRXJyb3I/OiB1bmRlZmluZWQ7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gYWRob2NFeGVjVGFzayhwYXJzZXI6IEVtcHR5VGFza1BhcnNlcik6IEVtcHR5VGFzayB7XG4gICByZXR1cm4ge1xuICAgICAgY29tbWFuZHM6IEVNUFRZX0NPTU1BTkRTLFxuICAgICAgZm9ybWF0OiAnZW1wdHknLFxuICAgICAgcGFyc2VyLFxuICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbmZpZ3VyYXRpb25FcnJvclRhc2soZXJyb3I6IEVycm9yIHwgc3RyaW5nKTogRW1wdHlUYXNrIHtcbiAgIHJldHVybiB7XG4gICAgICBjb21tYW5kczogRU1QVFlfQ09NTUFORFMsXG4gICAgICBmb3JtYXQ6ICdlbXB0eScsXG4gICAgICBwYXJzZXIoKSB7XG4gICAgICAgICB0aHJvdyB0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnID8gbmV3IFRhc2tDb25maWd1cmF0aW9uRXJyb3IoZXJyb3IpIDogZXJyb3I7XG4gICAgICB9LFxuICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soY29tbWFuZHM6IHN0cmluZ1tdLCB0cmltbWVkID0gZmFsc2UpOiBTdHJpbmdUYXNrPHN0cmluZz4ge1xuICAgcmV0dXJuIHtcbiAgICAgIGNvbW1hbmRzLFxuICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgcGFyc2VyKHRleHQpIHtcbiAgICAgICAgIHJldHVybiB0cmltbWVkID8gU3RyaW5nKHRleHQpLnRyaW0oKSA6IHRleHQ7XG4gICAgICB9LFxuICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cmFpZ2h0VGhyb3VnaEJ1ZmZlclRhc2soY29tbWFuZHM6IHN0cmluZ1tdKTogQnVmZmVyVGFzazxhbnk+IHtcbiAgIHJldHVybiB7XG4gICAgICBjb21tYW5kcyxcbiAgICAgIGZvcm1hdDogJ2J1ZmZlcicsXG4gICAgICBwYXJzZXIoYnVmZmVyKSB7XG4gICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgICAgfSxcbiAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0J1ZmZlclRhc2s8Uj4odGFzazogU2ltcGxlR2l0VGFzazxSPik6IHRhc2sgaXMgQnVmZmVyVGFzazxSPiB7XG4gICByZXR1cm4gdGFzay5mb3JtYXQgPT09ICdidWZmZXInO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNFbXB0eVRhc2s8Uj4odGFzazogU2ltcGxlR2l0VGFzazxSPik6IHRhc2sgaXMgRW1wdHlUYXNrIHtcbiAgIHJldHVybiB0YXNrLmZvcm1hdCA9PT0gJ2VtcHR5JyB8fCAhdGFzay5jb21tYW5kcy5sZW5ndGg7XG59XG4iLCAiaW1wb3J0IHsgQ2xlYW5TdW1tYXJ5IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBjbGVhblN1bW1hcnlQYXJzZXIgfSBmcm9tICcuLi9yZXNwb25zZXMvQ2xlYW5TdW1tYXJ5JztcbmltcG9ydCB7IE1heWJlLCBTdHJpbmdUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgYXNTdHJpbmdBcnJheSB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IGNvbmZpZ3VyYXRpb25FcnJvclRhc2sgfSBmcm9tICcuL3Rhc2snO1xuXG5leHBvcnQgY29uc3QgQ09ORklHX0VSUk9SX0lOVEVSQUNUSVZFX01PREUgPSAnR2l0IGNsZWFuIGludGVyYWN0aXZlIG1vZGUgaXMgbm90IHN1cHBvcnRlZCc7XG5leHBvcnQgY29uc3QgQ09ORklHX0VSUk9SX01PREVfUkVRVUlSRUQgPSAnR2l0IGNsZWFuIG1vZGUgcGFyYW1ldGVyIChcIm5cIiBvciBcImZcIikgaXMgcmVxdWlyZWQnO1xuZXhwb3J0IGNvbnN0IENPTkZJR19FUlJPUl9VTktOT1dOX09QVElPTiA9ICdHaXQgY2xlYW4gdW5rbm93biBvcHRpb24gZm91bmQgaW46ICc7XG5cbi8qKlxuICogQWxsIHN1cHBvcnRlZCBvcHRpb24gc3dpdGNoZXMgYXZhaWxhYmxlIGZvciB1c2UgaW4gYSBgZ2l0LmNsZWFuYCBvcGVyYXRpb25cbiAqL1xuZXhwb3J0IGVudW0gQ2xlYW5PcHRpb25zIHtcbiAgIERSWV9SVU4gPSAnbicsXG4gICBGT1JDRSA9ICdmJyxcbiAgIElHTk9SRURfSU5DTFVERUQgPSAneCcsXG4gICBJR05PUkVEX09OTFkgPSAnWCcsXG4gICBFWENMVURJTkcgPSAnZScsXG4gICBRVUlFVCA9ICdxJyxcbiAgIFJFQ1VSU0lWRSA9ICdkJyxcbn1cblxuLyoqXG4gKiBUaGUgdHdvIG1vZGVzIGBnaXQuY2xlYW5gIGNhbiBydW4gaW4gLSBvbmUgb2YgdGhlc2UgbXVzdCBiZSBzdXBwbGllZCBpbiBvcmRlclxuICogZm9yIHRoZSBjb21tYW5kIHRvIG5vdCB0aHJvdyBhIGBUYXNrQ29uZmlndXJhdGlvbkVycm9yYFxuICovXG5leHBvcnQgdHlwZSBDbGVhbk1vZGUgPSBDbGVhbk9wdGlvbnMuRk9SQ0UgfCBDbGVhbk9wdGlvbnMuRFJZX1JVTjtcblxuY29uc3QgQ2xlYW5PcHRpb25WYWx1ZXM6IFNldDxzdHJpbmc+ID0gbmV3IFNldChbXG4gICAnaScsXG4gICAuLi5hc1N0cmluZ0FycmF5KE9iamVjdC52YWx1ZXMoQ2xlYW5PcHRpb25zIGFzIGFueSkpLFxuXSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGVhbldpdGhPcHRpb25zVGFzayhtb2RlOiBDbGVhbk1vZGUgfCBzdHJpbmcsIGN1c3RvbUFyZ3M6IHN0cmluZ1tdKSB7XG4gICBjb25zdCB7IGNsZWFuTW9kZSwgb3B0aW9ucywgdmFsaWQgfSA9IGdldENsZWFuT3B0aW9ucyhtb2RlKTtcblxuICAgaWYgKCFjbGVhbk1vZGUpIHtcbiAgICAgIHJldHVybiBjb25maWd1cmF0aW9uRXJyb3JUYXNrKENPTkZJR19FUlJPUl9NT0RFX1JFUVVJUkVEKTtcbiAgIH1cblxuICAgaWYgKCF2YWxpZC5vcHRpb25zKSB7XG4gICAgICByZXR1cm4gY29uZmlndXJhdGlvbkVycm9yVGFzayhDT05GSUdfRVJST1JfVU5LTk9XTl9PUFRJT04gKyBKU09OLnN0cmluZ2lmeShtb2RlKSk7XG4gICB9XG5cbiAgIG9wdGlvbnMucHVzaCguLi5jdXN0b21BcmdzKTtcblxuICAgaWYgKG9wdGlvbnMuc29tZShpc0ludGVyYWN0aXZlTW9kZSkpIHtcbiAgICAgIHJldHVybiBjb25maWd1cmF0aW9uRXJyb3JUYXNrKENPTkZJR19FUlJPUl9JTlRFUkFDVElWRV9NT0RFKTtcbiAgIH1cblxuICAgcmV0dXJuIGNsZWFuVGFzayhjbGVhbk1vZGUsIG9wdGlvbnMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xlYW5UYXNrKG1vZGU6IENsZWFuTW9kZSwgY3VzdG9tQXJnczogc3RyaW5nW10pOiBTdHJpbmdUYXNrPENsZWFuU3VtbWFyeT4ge1xuICAgY29uc3QgY29tbWFuZHM6IHN0cmluZ1tdID0gWydjbGVhbicsIGAtJHttb2RlfWAsIC4uLmN1c3RvbUFyZ3NdO1xuXG4gICByZXR1cm4ge1xuICAgICAgY29tbWFuZHMsXG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBwYXJzZXIodGV4dDogc3RyaW5nKTogQ2xlYW5TdW1tYXJ5IHtcbiAgICAgICAgIHJldHVybiBjbGVhblN1bW1hcnlQYXJzZXIobW9kZSA9PT0gQ2xlYW5PcHRpb25zLkRSWV9SVU4sIHRleHQpO1xuICAgICAgfSxcbiAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0NsZWFuT3B0aW9uc0FycmF5KGlucHV0OiBzdHJpbmdbXSk6IGlucHV0IGlzIENsZWFuT3B0aW9uc1tdIHtcbiAgIHJldHVybiBBcnJheS5pc0FycmF5KGlucHV0KSAmJiBpbnB1dC5ldmVyeSgodGVzdCkgPT4gQ2xlYW5PcHRpb25WYWx1ZXMuaGFzKHRlc3QpKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2xlYW5PcHRpb25zKGlucHV0OiBzdHJpbmcpIHtcbiAgIGxldCBjbGVhbk1vZGU6IE1heWJlPENsZWFuTW9kZT47XG4gICBsZXQgb3B0aW9uczogc3RyaW5nW10gPSBbXTtcbiAgIGxldCB2YWxpZCA9IHsgY2xlYW5Nb2RlOiBmYWxzZSwgb3B0aW9uczogdHJ1ZSB9O1xuXG4gICBpbnB1dFxuICAgICAgLnJlcGxhY2UoL1teYS16XWkvZywgJycpXG4gICAgICAuc3BsaXQoJycpXG4gICAgICAuZm9yRWFjaCgoY2hhcikgPT4ge1xuICAgICAgICAgaWYgKGlzQ2xlYW5Nb2RlKGNoYXIpKSB7XG4gICAgICAgICAgICBjbGVhbk1vZGUgPSBjaGFyO1xuICAgICAgICAgICAgdmFsaWQuY2xlYW5Nb2RlID0gdHJ1ZTtcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWxpZC5vcHRpb25zID0gdmFsaWQub3B0aW9ucyAmJiBpc0tub3duT3B0aW9uKChvcHRpb25zW29wdGlvbnMubGVuZ3RoXSA9IGAtJHtjaGFyfWApKTtcbiAgICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICByZXR1cm4ge1xuICAgICAgY2xlYW5Nb2RlLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIHZhbGlkLFxuICAgfTtcbn1cblxuZnVuY3Rpb24gaXNDbGVhbk1vZGUoY2xlYW5Nb2RlPzogc3RyaW5nKTogY2xlYW5Nb2RlIGlzIENsZWFuTW9kZSB7XG4gICByZXR1cm4gY2xlYW5Nb2RlID09PSBDbGVhbk9wdGlvbnMuRk9SQ0UgfHwgY2xlYW5Nb2RlID09PSBDbGVhbk9wdGlvbnMuRFJZX1JVTjtcbn1cblxuZnVuY3Rpb24gaXNLbm93bk9wdGlvbihvcHRpb246IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgcmV0dXJuIC9eLVthLXpdJC9pLnRlc3Qob3B0aW9uKSAmJiBDbGVhbk9wdGlvblZhbHVlcy5oYXMob3B0aW9uLmNoYXJBdCgxKSk7XG59XG5cbmZ1bmN0aW9uIGlzSW50ZXJhY3RpdmVNb2RlKG9wdGlvbjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICBpZiAoL14tW15cXC1dLy50ZXN0KG9wdGlvbikpIHtcbiAgICAgIHJldHVybiBvcHRpb24uaW5kZXhPZignaScpID4gMDtcbiAgIH1cblxuICAgcmV0dXJuIG9wdGlvbiA9PT0gJy0taW50ZXJhY3RpdmUnO1xufVxuIiwgImltcG9ydCB7IENvbmZpZ0dldFJlc3VsdCwgQ29uZmlnTGlzdFN1bW1hcnksIENvbmZpZ1ZhbHVlcyB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgbGFzdCwgc3BsaXRPbiB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGNsYXNzIENvbmZpZ0xpc3QgaW1wbGVtZW50cyBDb25maWdMaXN0U3VtbWFyeSB7XG4gICBwdWJsaWMgZmlsZXM6IHN0cmluZ1tdID0gW107XG4gICBwdWJsaWMgdmFsdWVzOiB7IFtmaWxlTmFtZTogc3RyaW5nXTogQ29uZmlnVmFsdWVzIH0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICBwcml2YXRlIF9hbGw6IENvbmZpZ1ZhbHVlcyB8IHVuZGVmaW5lZDtcblxuICAgcHVibGljIGdldCBhbGwoKTogQ29uZmlnVmFsdWVzIHtcbiAgICAgIGlmICghdGhpcy5fYWxsKSB7XG4gICAgICAgICB0aGlzLl9hbGwgPSB0aGlzLmZpbGVzLnJlZHVjZSgoYWxsOiBDb25maWdWYWx1ZXMsIGZpbGU6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oYWxsLCB0aGlzLnZhbHVlc1tmaWxlXSk7XG4gICAgICAgICB9LCB7fSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9hbGw7XG4gICB9XG5cbiAgIHB1YmxpYyBhZGRGaWxlKGZpbGU6IHN0cmluZyk6IENvbmZpZ1ZhbHVlcyB7XG4gICAgICBpZiAoIShmaWxlIGluIHRoaXMudmFsdWVzKSkge1xuICAgICAgICAgY29uc3QgbGF0ZXN0ID0gbGFzdCh0aGlzLmZpbGVzKTtcbiAgICAgICAgIHRoaXMudmFsdWVzW2ZpbGVdID0gbGF0ZXN0ID8gT2JqZWN0LmNyZWF0ZSh0aGlzLnZhbHVlc1tsYXRlc3RdKSA6IHt9O1xuXG4gICAgICAgICB0aGlzLmZpbGVzLnB1c2goZmlsZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnZhbHVlc1tmaWxlXTtcbiAgIH1cblxuICAgcHVibGljIGFkZFZhbHVlKGZpbGU6IHN0cmluZywga2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMuYWRkRmlsZShmaWxlKTtcblxuICAgICAgaWYgKCF2YWx1ZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgdmFsdWVzW2tleV0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXNba2V5XSkpIHtcbiAgICAgICAgICh2YWx1ZXNba2V5XSBhcyBzdHJpbmdbXSkucHVzaCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgdmFsdWVzW2tleV0gPSBbdmFsdWVzW2tleV0gYXMgc3RyaW5nLCB2YWx1ZV07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2FsbCA9IHVuZGVmaW5lZDtcbiAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbmZpZ0xpc3RQYXJzZXIodGV4dDogc3RyaW5nKTogQ29uZmlnTGlzdCB7XG4gICBjb25zdCBjb25maWcgPSBuZXcgQ29uZmlnTGlzdCgpO1xuXG4gICBmb3IgKGNvbnN0IGl0ZW0gb2YgY29uZmlnUGFyc2VyKHRleHQpKSB7XG4gICAgICBjb25maWcuYWRkVmFsdWUoaXRlbS5maWxlLCBTdHJpbmcoaXRlbS5rZXkpLCBpdGVtLnZhbHVlKTtcbiAgIH1cblxuICAgcmV0dXJuIGNvbmZpZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbmZpZ0dldFBhcnNlcih0ZXh0OiBzdHJpbmcsIGtleTogc3RyaW5nKTogQ29uZmlnR2V0UmVzdWx0IHtcbiAgIGxldCB2YWx1ZTogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gICBjb25zdCB2YWx1ZXM6IHN0cmluZ1tdID0gW107XG4gICBjb25zdCBzY29wZXM6IE1hcDxzdHJpbmcsIHN0cmluZ1tdPiA9IG5ldyBNYXAoKTtcblxuICAgZm9yIChjb25zdCBpdGVtIG9mIGNvbmZpZ1BhcnNlcih0ZXh0LCBrZXkpKSB7XG4gICAgICBpZiAoaXRlbS5rZXkgIT09IGtleSkge1xuICAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlcy5wdXNoKCh2YWx1ZSA9IGl0ZW0udmFsdWUpKTtcblxuICAgICAgaWYgKCFzY29wZXMuaGFzKGl0ZW0uZmlsZSkpIHtcbiAgICAgICAgIHNjb3Blcy5zZXQoaXRlbS5maWxlLCBbXSk7XG4gICAgICB9XG5cbiAgICAgIHNjb3Blcy5nZXQoaXRlbS5maWxlKSEucHVzaCh2YWx1ZSk7XG4gICB9XG5cbiAgIHJldHVybiB7XG4gICAgICBrZXksXG4gICAgICBwYXRoczogQXJyYXkuZnJvbShzY29wZXMua2V5cygpKSxcbiAgICAgIHNjb3BlcyxcbiAgICAgIHZhbHVlLFxuICAgICAgdmFsdWVzLFxuICAgfTtcbn1cblxuZnVuY3Rpb24gY29uZmlnRmlsZVBhdGgoZmlsZVBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gICByZXR1cm4gZmlsZVBhdGgucmVwbGFjZSgvXihmaWxlKTovLCAnJyk7XG59XG5cbmZ1bmN0aW9uKiBjb25maWdQYXJzZXIodGV4dDogc3RyaW5nLCByZXF1ZXN0ZWRLZXk6IHN0cmluZyB8IG51bGwgPSBudWxsKSB7XG4gICBjb25zdCBsaW5lcyA9IHRleHQuc3BsaXQoJ1xcMCcpO1xuXG4gICBmb3IgKGxldCBpID0gMCwgbWF4ID0gbGluZXMubGVuZ3RoIC0gMTsgaSA8IG1heDsgKSB7XG4gICAgICBjb25zdCBmaWxlID0gY29uZmlnRmlsZVBhdGgobGluZXNbaSsrXSk7XG5cbiAgICAgIGxldCB2YWx1ZSA9IGxpbmVzW2krK107XG4gICAgICBsZXQga2V5ID0gcmVxdWVzdGVkS2V5O1xuXG4gICAgICBpZiAodmFsdWUuaW5jbHVkZXMoJ1xcbicpKSB7XG4gICAgICAgICBjb25zdCBsaW5lID0gc3BsaXRPbih2YWx1ZSwgJ1xcbicpO1xuICAgICAgICAga2V5ID0gbGluZVswXTtcbiAgICAgICAgIHZhbHVlID0gbGluZVsxXTtcbiAgICAgIH1cblxuICAgICAgeWllbGQgeyBmaWxlLCBrZXksIHZhbHVlIH07XG4gICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBDb25maWdHZXRSZXN1bHQsIENvbmZpZ0xpc3RTdW1tYXJ5LCBTaW1wbGVHaXQgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IGNvbmZpZ0dldFBhcnNlciwgY29uZmlnTGlzdFBhcnNlciB9IGZyb20gJy4uL3Jlc3BvbnNlcy9Db25maWdMaXN0JztcbmltcG9ydCB0eXBlIHsgU2ltcGxlR2l0QXBpIH0gZnJvbSAnLi4vc2ltcGxlLWdpdC1hcGknO1xuaW1wb3J0IHR5cGUgeyBTdHJpbmdUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50IH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgZW51bSBHaXRDb25maWdTY29wZSB7XG4gICBzeXN0ZW0gPSAnc3lzdGVtJyxcbiAgIGdsb2JhbCA9ICdnbG9iYWwnLFxuICAgbG9jYWwgPSAnbG9jYWwnLFxuICAgd29ya3RyZWUgPSAnd29ya3RyZWUnLFxufVxuXG5mdW5jdGlvbiBhc0NvbmZpZ1Njb3BlPFQgZXh0ZW5kcyBHaXRDb25maWdTY29wZSB8IHVuZGVmaW5lZD4oXG4gICBzY29wZTogR2l0Q29uZmlnU2NvcGUgfCB1bmtub3duLFxuICAgZmFsbGJhY2s6IFRcbik6IEdpdENvbmZpZ1Njb3BlIHwgVCB7XG4gICBpZiAodHlwZW9mIHNjb3BlID09PSAnc3RyaW5nJyAmJiBHaXRDb25maWdTY29wZS5oYXNPd25Qcm9wZXJ0eShzY29wZSkpIHtcbiAgICAgIHJldHVybiBzY29wZSBhcyBHaXRDb25maWdTY29wZTtcbiAgIH1cbiAgIHJldHVybiBmYWxsYmFjaztcbn1cblxuZnVuY3Rpb24gYWRkQ29uZmlnVGFzayhcbiAgIGtleTogc3RyaW5nLFxuICAgdmFsdWU6IHN0cmluZyxcbiAgIGFwcGVuZDogYm9vbGVhbixcbiAgIHNjb3BlOiBHaXRDb25maWdTY29wZVxuKTogU3RyaW5nVGFzazxzdHJpbmc+IHtcbiAgIGNvbnN0IGNvbW1hbmRzOiBzdHJpbmdbXSA9IFsnY29uZmlnJywgYC0tJHtzY29wZX1gXTtcblxuICAgaWYgKGFwcGVuZCkge1xuICAgICAgY29tbWFuZHMucHVzaCgnLS1hZGQnKTtcbiAgIH1cblxuICAgY29tbWFuZHMucHVzaChrZXksIHZhbHVlKTtcblxuICAgcmV0dXJuIHtcbiAgICAgIGNvbW1hbmRzLFxuICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgcGFyc2VyKHRleHQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgIH0sXG4gICB9O1xufVxuXG5mdW5jdGlvbiBnZXRDb25maWdUYXNrKGtleTogc3RyaW5nLCBzY29wZT86IEdpdENvbmZpZ1Njb3BlKTogU3RyaW5nVGFzazxDb25maWdHZXRSZXN1bHQ+IHtcbiAgIGNvbnN0IGNvbW1hbmRzOiBzdHJpbmdbXSA9IFsnY29uZmlnJywgJy0tbnVsbCcsICctLXNob3ctb3JpZ2luJywgJy0tZ2V0LWFsbCcsIGtleV07XG5cbiAgIGlmIChzY29wZSkge1xuICAgICAgY29tbWFuZHMuc3BsaWNlKDEsIDAsIGAtLSR7c2NvcGV9YCk7XG4gICB9XG5cbiAgIHJldHVybiB7XG4gICAgICBjb21tYW5kcyxcbiAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgIHBhcnNlcih0ZXh0KSB7XG4gICAgICAgICByZXR1cm4gY29uZmlnR2V0UGFyc2VyKHRleHQsIGtleSk7XG4gICAgICB9LFxuICAgfTtcbn1cblxuZnVuY3Rpb24gbGlzdENvbmZpZ1Rhc2soc2NvcGU/OiBHaXRDb25maWdTY29wZSk6IFN0cmluZ1Rhc2s8Q29uZmlnTGlzdFN1bW1hcnk+IHtcbiAgIGNvbnN0IGNvbW1hbmRzID0gWydjb25maWcnLCAnLS1saXN0JywgJy0tc2hvdy1vcmlnaW4nLCAnLS1udWxsJ107XG5cbiAgIGlmIChzY29wZSkge1xuICAgICAgY29tbWFuZHMucHVzaChgLS0ke3Njb3BlfWApO1xuICAgfVxuXG4gICByZXR1cm4ge1xuICAgICAgY29tbWFuZHMsXG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBwYXJzZXIodGV4dDogc3RyaW5nKSB7XG4gICAgICAgICByZXR1cm4gY29uZmlnTGlzdFBhcnNlcih0ZXh0KTtcbiAgICAgIH0sXG4gICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKTogUGljazxTaW1wbGVHaXQsICdhZGRDb25maWcnIHwgJ2dldENvbmZpZycgfCAnbGlzdENvbmZpZyc+IHtcbiAgIHJldHVybiB7XG4gICAgICBhZGRDb25maWcodGhpczogU2ltcGxlR2l0QXBpLCBrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZywgLi4ucmVzdDogdW5rbm93bltdKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgICAgIGFkZENvbmZpZ1Rhc2soXG4gICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgIHJlc3RbMF0gPT09IHRydWUsXG4gICAgICAgICAgICAgICBhc0NvbmZpZ1Njb3BlKHJlc3RbMV0sIEdpdENvbmZpZ1Njb3BlLmxvY2FsKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICAgICApO1xuICAgICAgfSxcblxuICAgICAgZ2V0Q29uZmlnKHRoaXM6IFNpbXBsZUdpdEFwaSwga2V5OiBzdHJpbmcsIHNjb3BlPzogR2l0Q29uZmlnU2NvcGUpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICAgICAgZ2V0Q29uZmlnVGFzayhrZXksIGFzQ29uZmlnU2NvcGUoc2NvcGUsIHVuZGVmaW5lZCkpLFxuICAgICAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICAgICAgICk7XG4gICAgICB9LFxuXG4gICAgICBsaXN0Q29uZmlnKHRoaXM6IFNpbXBsZUdpdEFwaSwgLi4ucmVzdDogdW5rbm93bltdKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgICAgIGxpc3RDb25maWdUYXNrKGFzQ29uZmlnU2NvcGUocmVzdFswXSwgdW5kZWZpbmVkKSksXG4gICAgICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgICAgKTtcbiAgICAgIH0sXG4gICB9O1xufVxuIiwgImV4cG9ydCBlbnVtIERpZmZOYW1lU3RhdHVzIHtcbiAgIEFEREVEID0gJ0EnLFxuICAgQ09QSUVEID0gJ0MnLFxuICAgREVMRVRFRCA9ICdEJyxcbiAgIE1PRElGSUVEID0gJ00nLFxuICAgUkVOQU1FRCA9ICdSJyxcbiAgIENIQU5HRUQgPSAnVCcsXG4gICBVTk1FUkdFRCA9ICdVJyxcbiAgIFVOS05PV04gPSAnWCcsXG4gICBCUk9LRU4gPSAnQicsXG59XG5cbmNvbnN0IGRpZmZOYW1lU3RhdHVzID0gbmV3IFNldChPYmplY3QudmFsdWVzKERpZmZOYW1lU3RhdHVzKSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0RpZmZOYW1lU3RhdHVzKGlucHV0OiBzdHJpbmcpOiBpbnB1dCBpcyBEaWZmTmFtZVN0YXR1cyB7XG4gICByZXR1cm4gZGlmZk5hbWVTdGF0dXMuaGFzKGlucHV0IGFzIERpZmZOYW1lU3RhdHVzKTtcbn1cbiIsICJpbXBvcnQgeyBHcmVwUmVzdWx0LCBTaW1wbGVHaXQgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IFNpbXBsZUdpdEFwaSB9IGZyb20gJy4uL3NpbXBsZS1naXQtYXBpJztcbmltcG9ydCB7XG4gICBhc051bWJlcixcbiAgIGZvckVhY2hMaW5lV2l0aENvbnRlbnQsXG4gICBnZXRUcmFpbGluZ09wdGlvbnMsXG4gICBOVUxMLFxuICAgcHJlZml4ZWRBcnJheSxcbiAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudCxcbn0gZnJvbSAnLi4vdXRpbHMnO1xuXG5pbXBvcnQgeyBjb25maWd1cmF0aW9uRXJyb3JUYXNrIH0gZnJvbSAnLi90YXNrJztcblxuY29uc3QgZGlzYWxsb3dlZE9wdGlvbnMgPSBbJy1oJ107XG5cbmNvbnN0IFF1ZXJ5ID0gU3ltYm9sKCdncmVwUXVlcnknKTtcblxuZXhwb3J0IGludGVyZmFjZSBHaXRHcmVwUXVlcnkgZXh0ZW5kcyBJdGVyYWJsZTxzdHJpbmc+IHtcbiAgIC8qKiBBZGRzIG9uZSBvciBtb3JlIHRlcm1zIHRvIGJlIGdyb3VwZWQgYXMgYW4gXCJhbmRcIiB0byBhbnkgb3RoZXIgdGVybXMgKi9cbiAgIGFuZCguLi5hbmQ6IHN0cmluZ1tdKTogdGhpcztcblxuICAgLyoqIEFkZHMgb25lIG9yIG1vcmUgc2VhcmNoIHRlcm1zIC0gZ2l0LmdyZXAgd2lsbCBcIm9yXCIgdGhpcyB0byBvdGhlciB0ZXJtcyAqL1xuICAgcGFyYW0oLi4ucGFyYW06IHN0cmluZ1tdKTogdGhpcztcbn1cblxuY2xhc3MgR3JlcFF1ZXJ5IGltcGxlbWVudHMgR2l0R3JlcFF1ZXJ5IHtcbiAgIHByaXZhdGUgW1F1ZXJ5XTogc3RyaW5nW10gPSBbXTtcblxuICAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgZm9yIChjb25zdCBxdWVyeSBvZiB0aGlzW1F1ZXJ5XSkge1xuICAgICAgICAgeWllbGQgcXVlcnk7XG4gICAgICB9XG4gICB9XG5cbiAgIGFuZCguLi5hbmQ6IHN0cmluZ1tdKSB7XG4gICAgICBhbmQubGVuZ3RoICYmIHRoaXNbUXVlcnldLnB1c2goJy0tYW5kJywgJygnLCAuLi5wcmVmaXhlZEFycmF5KGFuZCwgJy1lJyksICcpJyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgIH1cblxuICAgcGFyYW0oLi4ucGFyYW06IHN0cmluZ1tdKSB7XG4gICAgICB0aGlzW1F1ZXJ5XS5wdXNoKC4uLnByZWZpeGVkQXJyYXkocGFyYW0sICctZScpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYnVpbGRlciBmb3IgYSBgZ2l0LmdyZXBgIHF1ZXJ5IHdpdGggb3B0aW9uYWwgcGFyYW1zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBncmVwUXVlcnlCdWlsZGVyKC4uLnBhcmFtczogc3RyaW5nW10pOiBHaXRHcmVwUXVlcnkge1xuICAgcmV0dXJuIG5ldyBHcmVwUXVlcnkoKS5wYXJhbSguLi5wYXJhbXMpO1xufVxuXG5mdW5jdGlvbiBwYXJzZUdyZXAoZ3JlcDogc3RyaW5nKTogR3JlcFJlc3VsdCB7XG4gICBjb25zdCBwYXRoczogR3JlcFJlc3VsdFsncGF0aHMnXSA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgY29uc3QgcmVzdWx0czogR3JlcFJlc3VsdFsncmVzdWx0cyddID0ge307XG5cbiAgIGZvckVhY2hMaW5lV2l0aENvbnRlbnQoZ3JlcCwgKGlucHV0KSA9PiB7XG4gICAgICBjb25zdCBbcGF0aCwgbGluZSwgcHJldmlld10gPSBpbnB1dC5zcGxpdChOVUxMKTtcbiAgICAgIHBhdGhzLmFkZChwYXRoKTtcbiAgICAgIChyZXN1bHRzW3BhdGhdID0gcmVzdWx0c1twYXRoXSB8fCBbXSkucHVzaCh7XG4gICAgICAgICBsaW5lOiBhc051bWJlcihsaW5lKSxcbiAgICAgICAgIHBhdGgsXG4gICAgICAgICBwcmV2aWV3LFxuICAgICAgfSk7XG4gICB9KTtcblxuICAgcmV0dXJuIHtcbiAgICAgIHBhdGhzLFxuICAgICAgcmVzdWx0cyxcbiAgIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpOiBQaWNrPFNpbXBsZUdpdCwgJ2dyZXAnPiB7XG4gICByZXR1cm4ge1xuICAgICAgZ3JlcCh0aGlzOiBTaW1wbGVHaXRBcGksIHNlYXJjaFRlcm06IHN0cmluZyB8IEdpdEdyZXBRdWVyeSkge1xuICAgICAgICAgY29uc3QgdGhlbiA9IHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpO1xuICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpO1xuXG4gICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBkaXNhbGxvd2VkT3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaW5jbHVkZXMob3B0aW9uKSkge1xuICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgICAgICAgICBjb25maWd1cmF0aW9uRXJyb3JUYXNrKGBnaXQuZ3JlcDogdXNlIG9mIFwiJHtvcHRpb259XCIgaXMgbm90IHN1cHBvcnRlZC5gKSxcbiAgICAgICAgICAgICAgICAgIHRoZW5cbiAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG5cbiAgICAgICAgIGlmICh0eXBlb2Ygc2VhcmNoVGVybSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHNlYXJjaFRlcm0gPSBncmVwUXVlcnlCdWlsZGVyKCkucGFyYW0oc2VhcmNoVGVybSk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIGNvbnN0IGNvbW1hbmRzID0gWydncmVwJywgJy0tbnVsbCcsICctbicsICctLWZ1bGwtbmFtZScsIC4uLm9wdGlvbnMsIC4uLnNlYXJjaFRlcm1dO1xuXG4gICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgIGNvbW1hbmRzLFxuICAgICAgICAgICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgICAgICAgICAgcGFyc2VyKHN0ZE91dCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlR3JlcChzdGRPdXQpO1xuICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aGVuXG4gICAgICAgICApO1xuICAgICAgfSxcbiAgIH07XG59XG4iLCAiaW1wb3J0IHsgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayB9IGZyb20gJy4vdGFzayc7XG5pbXBvcnQgeyBNYXliZSwgT3B0aW9uRmxhZ3MsIE9wdGlvbnMgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBlbnVtIFJlc2V0TW9kZSB7XG4gICBNSVhFRCA9ICdtaXhlZCcsXG4gICBTT0ZUID0gJ3NvZnQnLFxuICAgSEFSRCA9ICdoYXJkJyxcbiAgIE1FUkdFID0gJ21lcmdlJyxcbiAgIEtFRVAgPSAna2VlcCcsXG59XG5cbmNvbnN0IFJlc2V0TW9kZXMgPSBBcnJheS5mcm9tKE9iamVjdC52YWx1ZXMoUmVzZXRNb2RlKSk7XG5cbmV4cG9ydCB0eXBlIFJlc2V0T3B0aW9ucyA9IE9wdGlvbnMgJlxuICAgT3B0aW9uRmxhZ3M8Jy1xJyB8ICctLXF1aWV0JyB8ICctLW5vLXF1aWV0JyB8ICctLXBhdGhzcGVjLWZyb20tbnVsJz4gJlxuICAgT3B0aW9uRmxhZ3M8Jy0tcGF0aHNwZWMtZnJvbS1maWxlJywgc3RyaW5nPjtcblxuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0VGFzayhtb2RlOiBNYXliZTxSZXNldE1vZGU+LCBjdXN0b21BcmdzOiBzdHJpbmdbXSkge1xuICAgY29uc3QgY29tbWFuZHM6IHN0cmluZ1tdID0gWydyZXNldCddO1xuICAgaWYgKGlzVmFsaWRSZXNldE1vZGUobW9kZSkpIHtcbiAgICAgIGNvbW1hbmRzLnB1c2goYC0tJHttb2RlfWApO1xuICAgfVxuICAgY29tbWFuZHMucHVzaCguLi5jdXN0b21BcmdzKTtcblxuICAgcmV0dXJuIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soY29tbWFuZHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVzZXRNb2RlKG1vZGU6IFJlc2V0TW9kZSB8IGFueSk6IE1heWJlPFJlc2V0TW9kZT4ge1xuICAgaWYgKGlzVmFsaWRSZXNldE1vZGUobW9kZSkpIHtcbiAgICAgIHJldHVybiBtb2RlO1xuICAgfVxuXG4gICBzd2l0Y2ggKHR5cGVvZiBtb2RlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgIHJldHVybiBSZXNldE1vZGUuU09GVDtcbiAgIH1cblxuICAgcmV0dXJuO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkUmVzZXRNb2RlKG1vZGU6IFJlc2V0TW9kZSB8IGFueSk6IG1vZGUgaXMgUmVzZXRNb2RlIHtcbiAgIHJldHVybiBSZXNldE1vZGVzLmluY2x1ZGVzKG1vZGUpO1xufVxuIiwgImltcG9ydCBkZWJ1ZywgeyBEZWJ1Z2dlciB9IGZyb20gJ2RlYnVnJztcbmltcG9ydCB7XG4gICBhcHBlbmQsXG4gICBmaWx0ZXJIYXNMZW5ndGgsXG4gICBmaWx0ZXJTdHJpbmcsXG4gICBmaWx0ZXJUeXBlLFxuICAgTk9PUCxcbiAgIG9iamVjdFRvU3RyaW5nLFxuICAgcmVtb3ZlLFxufSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IE1heWJlIH0gZnJvbSAnLi90eXBlcyc7XG5cbmRlYnVnLmZvcm1hdHRlcnMuTCA9ICh2YWx1ZTogYW55KSA9PiBTdHJpbmcoZmlsdGVySGFzTGVuZ3RoKHZhbHVlKSA/IHZhbHVlLmxlbmd0aCA6ICctJyk7XG5kZWJ1Zy5mb3JtYXR0ZXJzLkIgPSAodmFsdWU6IEJ1ZmZlcikgPT4ge1xuICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygndXRmOCcpO1xuICAgfVxuICAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn07XG5cbnR5cGUgT3V0cHV0TG9nZ2luZ0hhbmRsZXIgPSAobWVzc2FnZTogc3RyaW5nLCAuLi5hcmdzOiBhbnlbXSkgPT4gdm9pZDtcblxuZnVuY3Rpb24gY3JlYXRlTG9nKCkge1xuICAgcmV0dXJuIGRlYnVnKCdzaW1wbGUtZ2l0Jyk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3V0cHV0TG9nZ2VyIGV4dGVuZHMgT3V0cHV0TG9nZ2luZ0hhbmRsZXIge1xuICAgcmVhZG9ubHkgbGFiZWw6IHN0cmluZztcblxuICAgaW5mbzogT3V0cHV0TG9nZ2luZ0hhbmRsZXI7XG4gICBzdGVwKG5leHRTdGVwPzogc3RyaW5nKTogT3V0cHV0TG9nZ2VyO1xuICAgc2libGluZyhuYW1lOiBzdHJpbmcpOiBPdXRwdXRMb2dnZXI7XG59XG5cbmZ1bmN0aW9uIHByZWZpeGVkTG9nZ2VyKFxuICAgdG86IERlYnVnZ2VyLFxuICAgcHJlZml4OiBzdHJpbmcsXG4gICBmb3J3YXJkPzogT3V0cHV0TG9nZ2luZ0hhbmRsZXJcbik6IE91dHB1dExvZ2dpbmdIYW5kbGVyIHtcbiAgIGlmICghcHJlZml4IHx8ICFTdHJpbmcocHJlZml4KS5yZXBsYWNlKC9cXHMqLywgJycpKSB7XG4gICAgICByZXR1cm4gIWZvcndhcmRcbiAgICAgICAgID8gdG9cbiAgICAgICAgIDogKG1lc3NhZ2UsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgdG8obWVzc2FnZSwgLi4uYXJncyk7XG4gICAgICAgICAgICAgIGZvcndhcmQobWVzc2FnZSwgLi4uYXJncyk7XG4gICAgICAgICAgIH07XG4gICB9XG5cbiAgIHJldHVybiAobWVzc2FnZSwgLi4uYXJncykgPT4ge1xuICAgICAgdG8oYCVzICR7bWVzc2FnZX1gLCBwcmVmaXgsIC4uLmFyZ3MpO1xuICAgICAgaWYgKGZvcndhcmQpIHtcbiAgICAgICAgIGZvcndhcmQobWVzc2FnZSwgLi4uYXJncyk7XG4gICAgICB9XG4gICB9O1xufVxuXG5mdW5jdGlvbiBjaGlsZExvZ2dlck5hbWUoXG4gICBuYW1lOiBNYXliZTxzdHJpbmc+LFxuICAgY2hpbGREZWJ1Z2dlcjogTWF5YmU8RGVidWdnZXI+LFxuICAgeyBuYW1lc3BhY2U6IHBhcmVudE5hbWVzcGFjZSB9OiBEZWJ1Z2dlclxuKTogc3RyaW5nIHtcbiAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBuYW1lO1xuICAgfVxuICAgY29uc3QgY2hpbGROYW1lc3BhY2UgPSAoY2hpbGREZWJ1Z2dlciAmJiBjaGlsZERlYnVnZ2VyLm5hbWVzcGFjZSkgfHwgJyc7XG5cbiAgIGlmIChjaGlsZE5hbWVzcGFjZS5zdGFydHNXaXRoKHBhcmVudE5hbWVzcGFjZSkpIHtcbiAgICAgIHJldHVybiBjaGlsZE5hbWVzcGFjZS5zdWJzdHIocGFyZW50TmFtZXNwYWNlLmxlbmd0aCArIDEpO1xuICAgfVxuXG4gICByZXR1cm4gY2hpbGROYW1lc3BhY2UgfHwgcGFyZW50TmFtZXNwYWNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTG9nZ2VyKFxuICAgbGFiZWw6IHN0cmluZyxcbiAgIHZlcmJvc2U/OiBzdHJpbmcgfCBEZWJ1Z2dlcixcbiAgIGluaXRpYWxTdGVwPzogc3RyaW5nLFxuICAgaW5mb0RlYnVnZ2VyID0gY3JlYXRlTG9nKClcbik6IE91dHB1dExvZ2dlciB7XG4gICBjb25zdCBsYWJlbFByZWZpeCA9IChsYWJlbCAmJiBgWyR7bGFiZWx9XWApIHx8ICcnO1xuXG4gICBjb25zdCBzcGF3bmVkOiBPdXRwdXRMb2dnZXJbXSA9IFtdO1xuICAgY29uc3QgZGVidWdEZWJ1Z2dlcjogTWF5YmU8RGVidWdnZXI+ID1cbiAgICAgIHR5cGVvZiB2ZXJib3NlID09PSAnc3RyaW5nJyA/IGluZm9EZWJ1Z2dlci5leHRlbmQodmVyYm9zZSkgOiB2ZXJib3NlO1xuICAgY29uc3Qga2V5ID0gY2hpbGRMb2dnZXJOYW1lKGZpbHRlclR5cGUodmVyYm9zZSwgZmlsdGVyU3RyaW5nKSwgZGVidWdEZWJ1Z2dlciwgaW5mb0RlYnVnZ2VyKTtcblxuICAgcmV0dXJuIHN0ZXAoaW5pdGlhbFN0ZXApO1xuXG4gICBmdW5jdGlvbiBzaWJsaW5nKG5hbWU6IHN0cmluZywgaW5pdGlhbD86IHN0cmluZykge1xuICAgICAgcmV0dXJuIGFwcGVuZChcbiAgICAgICAgIHNwYXduZWQsXG4gICAgICAgICBjcmVhdGVMb2dnZXIobGFiZWwsIGtleS5yZXBsYWNlKC9eW146XSsvLCBuYW1lKSwgaW5pdGlhbCwgaW5mb0RlYnVnZ2VyKVxuICAgICAgKTtcbiAgIH1cblxuICAgZnVuY3Rpb24gc3RlcChwaGFzZT86IHN0cmluZykge1xuICAgICAgY29uc3Qgc3RlcFByZWZpeCA9IChwaGFzZSAmJiBgWyR7cGhhc2V9XWApIHx8ICcnO1xuICAgICAgY29uc3QgZGVidWcgPSAoZGVidWdEZWJ1Z2dlciAmJiBwcmVmaXhlZExvZ2dlcihkZWJ1Z0RlYnVnZ2VyLCBzdGVwUHJlZml4KSkgfHwgTk9PUDtcbiAgICAgIGNvbnN0IGluZm8gPSBwcmVmaXhlZExvZ2dlcihpbmZvRGVidWdnZXIsIGAke2xhYmVsUHJlZml4fSAke3N0ZXBQcmVmaXh9YCwgZGVidWcpO1xuXG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihkZWJ1Z0RlYnVnZ2VyID8gZGVidWcgOiBpbmZvLCB7XG4gICAgICAgICBsYWJlbCxcbiAgICAgICAgIHNpYmxpbmcsXG4gICAgICAgICBpbmZvLFxuICAgICAgICAgc3RlcCxcbiAgICAgIH0pO1xuICAgfVxufVxuXG4vKipcbiAqIFRoZSBgR2l0TG9nZ2VyYCBpcyB1c2VkIGJ5IHRoZSBtYWluIGBTaW1wbGVHaXRgIHJ1bm5lciB0byBoYW5kbGUgbG9nZ2luZ1xuICogYW55IHdhcm5pbmdzIG9yIGVycm9ycy5cbiAqL1xuZXhwb3J0IGNsYXNzIEdpdExvZ2dlciB7XG4gICBwdWJsaWMgZXJyb3I6IE91dHB1dExvZ2dpbmdIYW5kbGVyO1xuXG4gICBwdWJsaWMgd2FybjogT3V0cHV0TG9nZ2luZ0hhbmRsZXI7XG5cbiAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX291dDogRGVidWdnZXIgPSBjcmVhdGVMb2coKSkge1xuICAgICAgdGhpcy5lcnJvciA9IHByZWZpeGVkTG9nZ2VyKF9vdXQsICdbRVJST1JdJyk7XG4gICAgICB0aGlzLndhcm4gPSBwcmVmaXhlZExvZ2dlcihfb3V0LCAnW1dBUk5dJyk7XG4gICB9XG5cbiAgIHNpbGVudChzaWxlbmNlID0gZmFsc2UpIHtcbiAgICAgIGlmIChzaWxlbmNlICE9PSB0aGlzLl9vdXQuZW5hYmxlZCkge1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7IG5hbWVzcGFjZSB9ID0gdGhpcy5fb3V0O1xuICAgICAgY29uc3QgZW52ID0gKHByb2Nlc3MuZW52LkRFQlVHIHx8ICcnKS5zcGxpdCgnLCcpLmZpbHRlcigocykgPT4gISFzKTtcbiAgICAgIGNvbnN0IGhhc09uID0gZW52LmluY2x1ZGVzKG5hbWVzcGFjZSk7XG4gICAgICBjb25zdCBoYXNPZmYgPSBlbnYuaW5jbHVkZXMoYC0ke25hbWVzcGFjZX1gKTtcblxuICAgICAgLy8gZW5hYmxpbmcgdGhlIGxvZ1xuICAgICAgaWYgKCFzaWxlbmNlKSB7XG4gICAgICAgICBpZiAoaGFzT2ZmKSB7XG4gICAgICAgICAgICByZW1vdmUoZW52LCBgLSR7bmFtZXNwYWNlfWApO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVudi5wdXNoKG5hbWVzcGFjZSk7XG4gICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgaWYgKGhhc09uKSB7XG4gICAgICAgICAgICByZW1vdmUoZW52LCBuYW1lc3BhY2UpO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVudi5wdXNoKGAtJHtuYW1lc3BhY2V9YCk7XG4gICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGRlYnVnLmVuYWJsZShlbnYuam9pbignLCcpKTtcbiAgIH1cbn1cbiIsICJpbXBvcnQgeyBTaW1wbGVHaXRUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgR2l0RXJyb3IgfSBmcm9tICcuLi9lcnJvcnMvZ2l0LWVycm9yJztcbmltcG9ydCB7IGNyZWF0ZUxvZ2dlciwgT3V0cHV0TG9nZ2VyIH0gZnJvbSAnLi4vZ2l0LWxvZ2dlcic7XG5cbnR5cGUgQW55U2ltcGxlR2l0VGFzayA9IFNpbXBsZUdpdFRhc2s8YW55PjtcblxudHlwZSBUYXNrSW5Qcm9ncmVzcyA9IHtcbiAgIG5hbWU6IHN0cmluZztcbiAgIGxvZ2dlcjogT3V0cHV0TG9nZ2VyO1xuICAgdGFzazogQW55U2ltcGxlR2l0VGFzaztcbn07XG5cbmV4cG9ydCBjbGFzcyBUYXNrc1BlbmRpbmdRdWV1ZSB7XG4gICBwcml2YXRlIF9xdWV1ZTogTWFwPEFueVNpbXBsZUdpdFRhc2ssIFRhc2tJblByb2dyZXNzPiA9IG5ldyBNYXAoKTtcblxuICAgY29uc3RydWN0b3IocHJpdmF0ZSBsb2dMYWJlbCA9ICdHaXRFeGVjdXRvcicpIHt9XG5cbiAgIHByaXZhdGUgd2l0aFByb2dyZXNzKHRhc2s6IEFueVNpbXBsZUdpdFRhc2spIHtcbiAgICAgIHJldHVybiB0aGlzLl9xdWV1ZS5nZXQodGFzayk7XG4gICB9XG5cbiAgIHByaXZhdGUgY3JlYXRlUHJvZ3Jlc3ModGFzazogQW55U2ltcGxlR2l0VGFzayk6IFRhc2tJblByb2dyZXNzIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBUYXNrc1BlbmRpbmdRdWV1ZS5nZXROYW1lKHRhc2suY29tbWFuZHNbMF0pO1xuICAgICAgY29uc3QgbG9nZ2VyID0gY3JlYXRlTG9nZ2VyKHRoaXMubG9nTGFiZWwsIG5hbWUpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAgdGFzayxcbiAgICAgICAgIGxvZ2dlcixcbiAgICAgICAgIG5hbWUsXG4gICAgICB9O1xuICAgfVxuXG4gICBwdXNoKHRhc2s6IEFueVNpbXBsZUdpdFRhc2spOiBUYXNrSW5Qcm9ncmVzcyB7XG4gICAgICBjb25zdCBwcm9ncmVzcyA9IHRoaXMuY3JlYXRlUHJvZ3Jlc3ModGFzayk7XG4gICAgICBwcm9ncmVzcy5sb2dnZXIoJ0FkZGluZyB0YXNrIHRvIHRoZSBxdWV1ZSwgY29tbWFuZHMgPSAlbycsIHRhc2suY29tbWFuZHMpO1xuXG4gICAgICB0aGlzLl9xdWV1ZS5zZXQodGFzaywgcHJvZ3Jlc3MpO1xuXG4gICAgICByZXR1cm4gcHJvZ3Jlc3M7XG4gICB9XG5cbiAgIGZhdGFsKGVycjogR2l0RXJyb3IpIHtcbiAgICAgIGZvciAoY29uc3QgW3Rhc2ssIHsgbG9nZ2VyIH1dIG9mIEFycmF5LmZyb20odGhpcy5fcXVldWUuZW50cmllcygpKSkge1xuICAgICAgICAgaWYgKHRhc2sgPT09IGVyci50YXNrKSB7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhgRmFpbGVkICVvYCwgZXJyKTtcbiAgICAgICAgICAgIGxvZ2dlcihcbiAgICAgICAgICAgICAgIGBGYXRhbCBleGNlcHRpb24sIGFueSBhcy15ZXQgdW4tc3RhcnRlZCB0YXNrcyBydW4gdGhyb3VnaCB0aGlzIGV4ZWN1dG9yIHdpbGwgbm90IGJlIGF0dGVtcHRlZGBcbiAgICAgICAgICAgICk7XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oXG4gICAgICAgICAgICAgICBgQSBmYXRhbCBleGNlcHRpb24gb2NjdXJyZWQgaW4gYSBwcmV2aW91cyB0YXNrLCB0aGUgcXVldWUgaGFzIGJlZW4gcHVyZ2VkOiAlb2AsXG4gICAgICAgICAgICAgICBlcnIubWVzc2FnZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgdGhpcy5jb21wbGV0ZSh0YXNrKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3F1ZXVlLnNpemUgIT09IDApIHtcbiAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUXVldWUgc2l6ZSBzaG91bGQgYmUgemVybyBhZnRlciBmYXRhbDogJHt0aGlzLl9xdWV1ZS5zaXplfWApO1xuICAgICAgfVxuICAgfVxuXG4gICBjb21wbGV0ZSh0YXNrOiBBbnlTaW1wbGVHaXRUYXNrKSB7XG4gICAgICBjb25zdCBwcm9ncmVzcyA9IHRoaXMud2l0aFByb2dyZXNzKHRhc2spO1xuICAgICAgaWYgKHByb2dyZXNzKSB7XG4gICAgICAgICB0aGlzLl9xdWV1ZS5kZWxldGUodGFzayk7XG4gICAgICB9XG4gICB9XG5cbiAgIGF0dGVtcHQodGFzazogQW55U2ltcGxlR2l0VGFzayk6IFRhc2tJblByb2dyZXNzIHtcbiAgICAgIGNvbnN0IHByb2dyZXNzID0gdGhpcy53aXRoUHJvZ3Jlc3ModGFzayk7XG4gICAgICBpZiAoIXByb2dyZXNzKSB7XG4gICAgICAgICB0aHJvdyBuZXcgR2l0RXJyb3IodW5kZWZpbmVkLCAnVGFza3NQZW5kaW5nUXVldWU6IGF0dGVtcHQgY2FsbGVkIGZvciBhbiB1bmtub3duIHRhc2snKTtcbiAgICAgIH1cbiAgICAgIHByb2dyZXNzLmxvZ2dlcignU3RhcnRpbmcgdGFzaycpO1xuXG4gICAgICByZXR1cm4gcHJvZ3Jlc3M7XG4gICB9XG5cbiAgIHN0YXRpYyBnZXROYW1lKG5hbWUgPSAnZW1wdHknKSB7XG4gICAgICByZXR1cm4gYHRhc2s6JHtuYW1lfTokeysrVGFza3NQZW5kaW5nUXVldWUuY291bnRlcn1gO1xuICAgfVxuXG4gICBwcml2YXRlIHN0YXRpYyBjb3VudGVyID0gMDtcbn1cbiIsICJpbXBvcnQgeyBzcGF3biwgU3Bhd25PcHRpb25zIH0gZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQgeyBHaXRFcnJvciB9IGZyb20gJy4uL2Vycm9ycy9naXQtZXJyb3InO1xuaW1wb3J0IHsgT3V0cHV0TG9nZ2VyIH0gZnJvbSAnLi4vZ2l0LWxvZ2dlcic7XG5pbXBvcnQgeyBQbHVnaW5TdG9yZSB9IGZyb20gJy4uL3BsdWdpbnMnO1xuaW1wb3J0IHsgRW1wdHlUYXNrLCBpc0J1ZmZlclRhc2ssIGlzRW1wdHlUYXNrIH0gZnJvbSAnLi4vdGFza3MvdGFzayc7XG5pbXBvcnQge1xuICAgR2l0RXhlY3V0b3JSZXN1bHQsXG4gICBNYXliZSxcbiAgIG91dHB1dEhhbmRsZXIsXG4gICBSdW5uYWJsZVRhc2ssXG4gICBTaW1wbGVHaXRFeGVjdXRvcixcbiAgIFNpbXBsZUdpdFRhc2ssXG59IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGNhbGxUYXNrUGFyc2VyLCBmaXJzdCwgR2l0T3V0cHV0U3RyZWFtcywgb2JqZWN0VG9TdHJpbmcgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBTY2hlZHVsZXIgfSBmcm9tICcuL3NjaGVkdWxlcic7XG5pbXBvcnQgeyBUYXNrc1BlbmRpbmdRdWV1ZSB9IGZyb20gJy4vdGFza3MtcGVuZGluZy1xdWV1ZSc7XG5cbmV4cG9ydCBjbGFzcyBHaXRFeGVjdXRvckNoYWluIGltcGxlbWVudHMgU2ltcGxlR2l0RXhlY3V0b3Ige1xuICAgcHJpdmF0ZSBfY2hhaW46IFByb21pc2U8YW55PiA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgcHJpdmF0ZSBfcXVldWUgPSBuZXcgVGFza3NQZW5kaW5nUXVldWUoKTtcbiAgIHByaXZhdGUgX2N3ZDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4gICBwdWJsaWMgZ2V0IGN3ZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jd2QgfHwgdGhpcy5fZXhlY3V0b3IuY3dkO1xuICAgfVxuXG4gICBwdWJsaWMgc2V0IGN3ZChjd2Q6IHN0cmluZykge1xuICAgICAgdGhpcy5fY3dkID0gY3dkO1xuICAgfVxuXG4gICBwdWJsaWMgZ2V0IGVudigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9leGVjdXRvci5lbnY7XG4gICB9XG5cbiAgIHB1YmxpYyBnZXQgb3V0cHV0SGFuZGxlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9leGVjdXRvci5vdXRwdXRIYW5kbGVyO1xuICAgfVxuXG4gICBjb25zdHJ1Y3RvcihcbiAgICAgIHByaXZhdGUgX2V4ZWN1dG9yOiBTaW1wbGVHaXRFeGVjdXRvcixcbiAgICAgIHByaXZhdGUgX3NjaGVkdWxlcjogU2NoZWR1bGVyLFxuICAgICAgcHJpdmF0ZSBfcGx1Z2luczogUGx1Z2luU3RvcmVcbiAgICkge31cblxuICAgcHVibGljIGNoYWluKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICB9XG5cbiAgIHB1YmxpYyBwdXNoPFI+KHRhc2s6IFNpbXBsZUdpdFRhc2s8Uj4pOiBQcm9taXNlPFI+IHtcbiAgICAgIHRoaXMuX3F1ZXVlLnB1c2godGFzayk7XG5cbiAgICAgIHJldHVybiAodGhpcy5fY2hhaW4gPSB0aGlzLl9jaGFpbi50aGVuKCgpID0+IHRoaXMuYXR0ZW1wdFRhc2sodGFzaykpKTtcbiAgIH1cblxuICAgcHJpdmF0ZSBhc3luYyBhdHRlbXB0VGFzazxSPih0YXNrOiBTaW1wbGVHaXRUYXNrPFI+KTogUHJvbWlzZTx2b2lkIHwgUj4ge1xuICAgICAgY29uc3Qgb25TY2hlZHVsZUNvbXBsZXRlID0gYXdhaXQgdGhpcy5fc2NoZWR1bGVyLm5leHQoKTtcbiAgICAgIGNvbnN0IG9uUXVldWVDb21wbGV0ZSA9ICgpID0+IHRoaXMuX3F1ZXVlLmNvbXBsZXRlKHRhc2spO1xuXG4gICAgICB0cnkge1xuICAgICAgICAgY29uc3QgeyBsb2dnZXIgfSA9IHRoaXMuX3F1ZXVlLmF0dGVtcHQodGFzayk7XG4gICAgICAgICByZXR1cm4gKGF3YWl0IChpc0VtcHR5VGFzayh0YXNrKVxuICAgICAgICAgICAgPyB0aGlzLmF0dGVtcHRFbXB0eVRhc2sodGFzaywgbG9nZ2VyKVxuICAgICAgICAgICAgOiB0aGlzLmF0dGVtcHRSZW1vdGVUYXNrKHRhc2ssIGxvZ2dlcikpKSBhcyBSO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgdGhyb3cgdGhpcy5vbkZhdGFsRXhjZXB0aW9uKHRhc2ssIGUgYXMgRXJyb3IpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgIG9uUXVldWVDb21wbGV0ZSgpO1xuICAgICAgICAgb25TY2hlZHVsZUNvbXBsZXRlKCk7XG4gICAgICB9XG4gICB9XG5cbiAgIHByaXZhdGUgb25GYXRhbEV4Y2VwdGlvbjxSPih0YXNrOiBTaW1wbGVHaXRUYXNrPFI+LCBlOiBFcnJvcikge1xuICAgICAgY29uc3QgZ2l0RXJyb3IgPVxuICAgICAgICAgZSBpbnN0YW5jZW9mIEdpdEVycm9yID8gT2JqZWN0LmFzc2lnbihlLCB7IHRhc2sgfSkgOiBuZXcgR2l0RXJyb3IodGFzaywgZSAmJiBTdHJpbmcoZSkpO1xuXG4gICAgICB0aGlzLl9jaGFpbiA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgdGhpcy5fcXVldWUuZmF0YWwoZ2l0RXJyb3IpO1xuXG4gICAgICByZXR1cm4gZ2l0RXJyb3I7XG4gICB9XG5cbiAgIHByaXZhdGUgYXN5bmMgYXR0ZW1wdFJlbW90ZVRhc2s8Uj4odGFzazogUnVubmFibGVUYXNrPFI+LCBsb2dnZXI6IE91dHB1dExvZ2dlcikge1xuICAgICAgY29uc3QgYmluYXJ5ID0gdGhpcy5fcGx1Z2lucy5leGVjKCdzcGF3bi5iaW5hcnknLCAnJywgcGx1Z2luQ29udGV4dCh0YXNrLCB0YXNrLmNvbW1hbmRzKSk7XG4gICAgICBjb25zdCBhcmdzID0gdGhpcy5fcGx1Z2lucy5leGVjKFxuICAgICAgICAgJ3NwYXduLmFyZ3MnLFxuICAgICAgICAgWy4uLnRhc2suY29tbWFuZHNdLFxuICAgICAgICAgcGx1Z2luQ29udGV4dCh0YXNrLCB0YXNrLmNvbW1hbmRzKVxuICAgICAgKTtcblxuICAgICAgY29uc3QgcmF3ID0gYXdhaXQgdGhpcy5naXRSZXNwb25zZShcbiAgICAgICAgIHRhc2ssXG4gICAgICAgICBiaW5hcnksXG4gICAgICAgICBhcmdzLFxuICAgICAgICAgdGhpcy5vdXRwdXRIYW5kbGVyLFxuICAgICAgICAgbG9nZ2VyLnN0ZXAoJ1NQQVdOJylcbiAgICAgICk7XG4gICAgICBjb25zdCBvdXRwdXRTdHJlYW1zID0gYXdhaXQgdGhpcy5oYW5kbGVUYXNrRGF0YSh0YXNrLCBhcmdzLCByYXcsIGxvZ2dlci5zdGVwKCdIQU5ETEUnKSk7XG5cbiAgICAgIGxvZ2dlcihgcGFzc2luZyByZXNwb25zZSB0byB0YXNrJ3MgcGFyc2VyIGFzIGEgJXNgLCB0YXNrLmZvcm1hdCk7XG5cbiAgICAgIGlmIChpc0J1ZmZlclRhc2sodGFzaykpIHtcbiAgICAgICAgIHJldHVybiBjYWxsVGFza1BhcnNlcih0YXNrLnBhcnNlciwgb3V0cHV0U3RyZWFtcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYWxsVGFza1BhcnNlcih0YXNrLnBhcnNlciwgb3V0cHV0U3RyZWFtcy5hc1N0cmluZ3MoKSk7XG4gICB9XG5cbiAgIHByaXZhdGUgYXN5bmMgYXR0ZW1wdEVtcHR5VGFzayh0YXNrOiBFbXB0eVRhc2ssIGxvZ2dlcjogT3V0cHV0TG9nZ2VyKSB7XG4gICAgICBsb2dnZXIoYGVtcHR5IHRhc2sgYnlwYXNzaW5nIGNoaWxkIHByb2Nlc3MgdG8gY2FsbCB0byB0YXNrJ3MgcGFyc2VyYCk7XG4gICAgICByZXR1cm4gdGFzay5wYXJzZXIodGhpcyk7XG4gICB9XG5cbiAgIHByaXZhdGUgaGFuZGxlVGFza0RhdGE8Uj4oXG4gICAgICB0YXNrOiBTaW1wbGVHaXRUYXNrPFI+LFxuICAgICAgYXJnczogc3RyaW5nW10sXG4gICAgICByZXN1bHQ6IEdpdEV4ZWN1dG9yUmVzdWx0LFxuICAgICAgbG9nZ2VyOiBPdXRwdXRMb2dnZXJcbiAgICk6IFByb21pc2U8R2l0T3V0cHV0U3RyZWFtcz4ge1xuICAgICAgY29uc3QgeyBleGl0Q29kZSwgcmVqZWN0aW9uLCBzdGRPdXQsIHN0ZEVyciB9ID0gcmVzdWx0O1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKGRvbmUsIGZhaWwpID0+IHtcbiAgICAgICAgIGxvZ2dlcihgUHJlcGFyaW5nIHRvIGhhbmRsZSBwcm9jZXNzIHJlc3BvbnNlIGV4aXRDb2RlPSVkIHN0ZE91dD1gLCBleGl0Q29kZSk7XG5cbiAgICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IHRoaXMuX3BsdWdpbnMuZXhlYyhcbiAgICAgICAgICAgICd0YXNrLmVycm9yJyxcbiAgICAgICAgICAgIHsgZXJyb3I6IHJlamVjdGlvbiB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgLi4ucGx1Z2luQ29udGV4dCh0YXNrLCBhcmdzKSxcbiAgICAgICAgICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICk7XG5cbiAgICAgICAgIGlmIChlcnJvciAmJiB0YXNrLm9uRXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKGBleGl0Q29kZT0lcyBoYW5kbGluZyB3aXRoIGN1c3RvbSBlcnJvciBoYW5kbGVyYCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0YXNrLm9uRXJyb3IoXG4gICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgIChuZXdTdGRPdXQpID0+IHtcbiAgICAgICAgICAgICAgICAgIGxvZ2dlci5pbmZvKGBjdXN0b20gZXJyb3IgaGFuZGxlciB0cmVhdGVkIGFzIHN1Y2Nlc3NgKTtcbiAgICAgICAgICAgICAgICAgIGxvZ2dlcihgY3VzdG9tIGVycm9yIHJldHVybmVkIGEgJXNgLCBvYmplY3RUb1N0cmluZyhuZXdTdGRPdXQpKTtcblxuICAgICAgICAgICAgICAgICAgZG9uZShcbiAgICAgICAgICAgICAgICAgICAgIG5ldyBHaXRPdXRwdXRTdHJlYW1zKFxuICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShuZXdTdGRPdXQpID8gQnVmZmVyLmNvbmNhdChuZXdTdGRPdXQpIDogbmV3U3RkT3V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgQnVmZmVyLmNvbmNhdChzdGRFcnIpXG4gICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgIGZhaWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oXG4gICAgICAgICAgICAgICBgaGFuZGxpbmcgYXMgZXJyb3I6IGV4aXRDb2RlPSVzIHN0ZEVycj0lcyByZWplY3Rpb249JW9gLFxuICAgICAgICAgICAgICAgZXhpdENvZGUsXG4gICAgICAgICAgICAgICBzdGRFcnIubGVuZ3RoLFxuICAgICAgICAgICAgICAgcmVqZWN0aW9uXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIGZhaWwoZXJyb3IpO1xuICAgICAgICAgfVxuXG4gICAgICAgICBsb2dnZXIuaW5mbyhgcmV0cmlldmluZyB0YXNrIG91dHB1dCBjb21wbGV0ZWApO1xuICAgICAgICAgZG9uZShuZXcgR2l0T3V0cHV0U3RyZWFtcyhCdWZmZXIuY29uY2F0KHN0ZE91dCksIEJ1ZmZlci5jb25jYXQoc3RkRXJyKSkpO1xuICAgICAgfSk7XG4gICB9XG5cbiAgIHByaXZhdGUgYXN5bmMgZ2l0UmVzcG9uc2U8Uj4oXG4gICAgICB0YXNrOiBTaW1wbGVHaXRUYXNrPFI+LFxuICAgICAgY29tbWFuZDogc3RyaW5nLFxuICAgICAgYXJnczogc3RyaW5nW10sXG4gICAgICBvdXRwdXRIYW5kbGVyOiBNYXliZTxvdXRwdXRIYW5kbGVyPixcbiAgICAgIGxvZ2dlcjogT3V0cHV0TG9nZ2VyXG4gICApOiBQcm9taXNlPEdpdEV4ZWN1dG9yUmVzdWx0PiB7XG4gICAgICBjb25zdCBvdXRwdXRMb2dnZXIgPSBsb2dnZXIuc2libGluZygnb3V0cHV0Jyk7XG4gICAgICBjb25zdCBzcGF3bk9wdGlvbnM6IFNwYXduT3B0aW9ucyA9IHRoaXMuX3BsdWdpbnMuZXhlYyhcbiAgICAgICAgICdzcGF3bi5vcHRpb25zJyxcbiAgICAgICAgIHtcbiAgICAgICAgICAgIGN3ZDogdGhpcy5jd2QsXG4gICAgICAgICAgICBlbnY6IHRoaXMuZW52LFxuICAgICAgICAgICAgd2luZG93c0hpZGU6IHRydWUsXG4gICAgICAgICB9LFxuICAgICAgICAgcGx1Z2luQ29udGV4dCh0YXNrLCB0YXNrLmNvbW1hbmRzKVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChkb25lKSA9PiB7XG4gICAgICAgICBjb25zdCBzdGRPdXQ6IEJ1ZmZlcltdID0gW107XG4gICAgICAgICBjb25zdCBzdGRFcnI6IEJ1ZmZlcltdID0gW107XG5cbiAgICAgICAgIGxvZ2dlci5pbmZvKGAlcyAlb2AsIGNvbW1hbmQsIGFyZ3MpO1xuICAgICAgICAgbG9nZ2VyKCclTycsIHNwYXduT3B0aW9ucyk7XG5cbiAgICAgICAgIGxldCByZWplY3Rpb24gPSB0aGlzLl9iZWZvcmVTcGF3bih0YXNrLCBhcmdzKTtcbiAgICAgICAgIGlmIChyZWplY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBkb25lKHtcbiAgICAgICAgICAgICAgIHN0ZE91dCxcbiAgICAgICAgICAgICAgIHN0ZEVycixcbiAgICAgICAgICAgICAgIGV4aXRDb2RlOiA5OTAxLFxuICAgICAgICAgICAgICAgcmVqZWN0aW9uLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHRoaXMuX3BsdWdpbnMuZXhlYygnc3Bhd24uYmVmb3JlJywgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAuLi5wbHVnaW5Db250ZXh0KHRhc2ssIGFyZ3MpLFxuICAgICAgICAgICAga2lsbChyZWFzb24pIHtcbiAgICAgICAgICAgICAgIHJlamVjdGlvbiA9IHJlYXNvbiB8fCByZWplY3Rpb247XG4gICAgICAgICAgICB9LFxuICAgICAgICAgfSk7XG5cbiAgICAgICAgIGNvbnN0IHNwYXduZWQgPSBzcGF3bihjb21tYW5kLCBhcmdzLCBzcGF3bk9wdGlvbnMpO1xuXG4gICAgICAgICBzcGF3bmVkLnN0ZG91dCEub24oXG4gICAgICAgICAgICAnZGF0YScsXG4gICAgICAgICAgICBvbkRhdGFSZWNlaXZlZChzdGRPdXQsICdzdGRPdXQnLCBsb2dnZXIsIG91dHB1dExvZ2dlci5zdGVwKCdzdGRPdXQnKSlcbiAgICAgICAgICk7XG4gICAgICAgICBzcGF3bmVkLnN0ZGVyciEub24oXG4gICAgICAgICAgICAnZGF0YScsXG4gICAgICAgICAgICBvbkRhdGFSZWNlaXZlZChzdGRFcnIsICdzdGRFcnInLCBsb2dnZXIsIG91dHB1dExvZ2dlci5zdGVwKCdzdGRFcnInKSlcbiAgICAgICAgICk7XG5cbiAgICAgICAgIHNwYXduZWQub24oJ2Vycm9yJywgb25FcnJvclJlY2VpdmVkKHN0ZEVyciwgbG9nZ2VyKSk7XG5cbiAgICAgICAgIGlmIChvdXRwdXRIYW5kbGVyKSB7XG4gICAgICAgICAgICBsb2dnZXIoYFBhc3NpbmcgY2hpbGQgcHJvY2VzcyBzdGRPdXQvc3RkRXJyIHRvIGN1c3RvbSBvdXRwdXRIYW5kbGVyYCk7XG4gICAgICAgICAgICBvdXRwdXRIYW5kbGVyKGNvbW1hbmQsIHNwYXduZWQuc3Rkb3V0ISwgc3Bhd25lZC5zdGRlcnIhLCBbLi4uYXJnc10pO1xuICAgICAgICAgfVxuXG4gICAgICAgICB0aGlzLl9wbHVnaW5zLmV4ZWMoJ3NwYXduLmFmdGVyJywgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAuLi5wbHVnaW5Db250ZXh0KHRhc2ssIGFyZ3MpLFxuICAgICAgICAgICAgc3Bhd25lZCxcbiAgICAgICAgICAgIGNsb3NlKGV4aXRDb2RlOiBudW1iZXIsIHJlYXNvbj86IEVycm9yKSB7XG4gICAgICAgICAgICAgICBkb25lKHtcbiAgICAgICAgICAgICAgICAgIHN0ZE91dCxcbiAgICAgICAgICAgICAgICAgIHN0ZEVycixcbiAgICAgICAgICAgICAgICAgIGV4aXRDb2RlLFxuICAgICAgICAgICAgICAgICAgcmVqZWN0aW9uOiByZWplY3Rpb24gfHwgcmVhc29uLFxuICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAga2lsbChyZWFzb246IEVycm9yKSB7XG4gICAgICAgICAgICAgICBpZiAoc3Bhd25lZC5raWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgcmVqZWN0aW9uID0gcmVhc29uO1xuICAgICAgICAgICAgICAgc3Bhd25lZC5raWxsKCdTSUdJTlQnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgfVxuXG4gICBwcml2YXRlIF9iZWZvcmVTcGF3bjxSPih0YXNrOiBTaW1wbGVHaXRUYXNrPFI+LCBhcmdzOiBzdHJpbmdbXSkge1xuICAgICAgbGV0IHJlamVjdGlvbjogTWF5YmU8RXJyb3I+O1xuICAgICAgdGhpcy5fcGx1Z2lucy5leGVjKCdzcGF3bi5iZWZvcmUnLCB1bmRlZmluZWQsIHtcbiAgICAgICAgIC4uLnBsdWdpbkNvbnRleHQodGFzaywgYXJncyksXG4gICAgICAgICBraWxsKHJlYXNvbikge1xuICAgICAgICAgICAgcmVqZWN0aW9uID0gcmVhc29uIHx8IHJlamVjdGlvbjtcbiAgICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHJlamVjdGlvbjtcbiAgIH1cbn1cblxuZnVuY3Rpb24gcGx1Z2luQ29udGV4dDxSPih0YXNrOiBTaW1wbGVHaXRUYXNrPFI+LCBjb21tYW5kczogc3RyaW5nW10pIHtcbiAgIHJldHVybiB7XG4gICAgICBtZXRob2Q6IGZpcnN0KHRhc2suY29tbWFuZHMpIHx8ICcnLFxuICAgICAgY29tbWFuZHMsXG4gICB9O1xufVxuXG5mdW5jdGlvbiBvbkVycm9yUmVjZWl2ZWQodGFyZ2V0OiBCdWZmZXJbXSwgbG9nZ2VyOiBPdXRwdXRMb2dnZXIpIHtcbiAgIHJldHVybiAoZXJyOiBFcnJvcikgPT4ge1xuICAgICAgbG9nZ2VyKGBbRVJST1JdIGNoaWxkIHByb2Nlc3MgZXhjZXB0aW9uICVvYCwgZXJyKTtcbiAgICAgIHRhcmdldC5wdXNoKEJ1ZmZlci5mcm9tKFN0cmluZyhlcnIuc3RhY2spLCAnYXNjaWknKSk7XG4gICB9O1xufVxuXG5mdW5jdGlvbiBvbkRhdGFSZWNlaXZlZChcbiAgIHRhcmdldDogQnVmZmVyW10sXG4gICBuYW1lOiBzdHJpbmcsXG4gICBsb2dnZXI6IE91dHB1dExvZ2dlcixcbiAgIG91dHB1dDogT3V0cHV0TG9nZ2VyXG4pIHtcbiAgIHJldHVybiAoYnVmZmVyOiBCdWZmZXIpID0+IHtcbiAgICAgIGxvZ2dlcihgJXMgcmVjZWl2ZWQgJUwgYnl0ZXNgLCBuYW1lLCBidWZmZXIpO1xuICAgICAgb3V0cHV0KGAlQmAsIGJ1ZmZlcik7XG4gICAgICB0YXJnZXQucHVzaChidWZmZXIpO1xuICAgfTtcbn1cbiIsICJpbXBvcnQgdHlwZSB7IFBsdWdpblN0b3JlIH0gZnJvbSAnLi4vcGx1Z2lucyc7XG5pbXBvcnQgdHlwZSB7IEdpdEV4ZWN1dG9yRW52LCBvdXRwdXRIYW5kbGVyLCBTaW1wbGVHaXRFeGVjdXRvciwgU2ltcGxlR2l0VGFzayB9IGZyb20gJy4uL3R5cGVzJztcblxuaW1wb3J0IHsgR2l0RXhlY3V0b3JDaGFpbiB9IGZyb20gJy4vZ2l0LWV4ZWN1dG9yLWNoYWluJztcbmltcG9ydCB7IFNjaGVkdWxlciB9IGZyb20gJy4vc2NoZWR1bGVyJztcblxuZXhwb3J0IGNsYXNzIEdpdEV4ZWN1dG9yIGltcGxlbWVudHMgU2ltcGxlR2l0RXhlY3V0b3Ige1xuICAgcHJpdmF0ZSBfY2hhaW4gPSBuZXcgR2l0RXhlY3V0b3JDaGFpbih0aGlzLCB0aGlzLl9zY2hlZHVsZXIsIHRoaXMuX3BsdWdpbnMpO1xuXG4gICBwdWJsaWMgZW52OiBHaXRFeGVjdXRvckVudjtcbiAgIHB1YmxpYyBvdXRwdXRIYW5kbGVyPzogb3V0cHV0SGFuZGxlcjtcblxuICAgY29uc3RydWN0b3IoXG4gICAgICBwdWJsaWMgY3dkOiBzdHJpbmcsXG4gICAgICBwcml2YXRlIF9zY2hlZHVsZXI6IFNjaGVkdWxlcixcbiAgICAgIHByaXZhdGUgX3BsdWdpbnM6IFBsdWdpblN0b3JlXG4gICApIHt9XG5cbiAgIGNoYWluKCk6IFNpbXBsZUdpdEV4ZWN1dG9yIHtcbiAgICAgIHJldHVybiBuZXcgR2l0RXhlY3V0b3JDaGFpbih0aGlzLCB0aGlzLl9zY2hlZHVsZXIsIHRoaXMuX3BsdWdpbnMpO1xuICAgfVxuXG4gICBwdXNoPFI+KHRhc2s6IFNpbXBsZUdpdFRhc2s8Uj4pOiBQcm9taXNlPFI+IHtcbiAgICAgIHJldHVybiB0aGlzLl9jaGFpbi5wdXNoKHRhc2spO1xuICAgfVxufVxuIiwgImltcG9ydCB7IEdpdEVycm9yIH0gZnJvbSAnLi9lcnJvcnMvZ2l0LWVycm9yJztcbmltcG9ydCB7IEdpdFJlc3BvbnNlRXJyb3IgfSBmcm9tICcuL2Vycm9ycy9naXQtcmVzcG9uc2UtZXJyb3InO1xuaW1wb3J0IHsgU2ltcGxlR2l0VGFzaywgU2ltcGxlR2l0VGFza0NhbGxiYWNrIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBOT09QIH0gZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiB0YXNrQ2FsbGJhY2s8Uj4oXG4gICB0YXNrOiBTaW1wbGVHaXRUYXNrPFI+LFxuICAgcmVzcG9uc2U6IFByb21pc2U8Uj4sXG4gICBjYWxsYmFjazogU2ltcGxlR2l0VGFza0NhbGxiYWNrPFI+ID0gTk9PUFxuKSB7XG4gICBjb25zdCBvblN1Y2Nlc3MgPSAoZGF0YTogUikgPT4ge1xuICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICB9O1xuXG4gICBjb25zdCBvbkVycm9yID0gKGVycjogR2l0RXJyb3IgfCBHaXRSZXNwb25zZUVycm9yKSA9PiB7XG4gICAgICBpZiAoZXJyPy50YXNrID09PSB0YXNrKSB7XG4gICAgICAgICBjYWxsYmFjayhcbiAgICAgICAgICAgIGVyciBpbnN0YW5jZW9mIEdpdFJlc3BvbnNlRXJyb3IgPyBhZGREZXByZWNhdGlvbk5vdGljZVRvRXJyb3IoZXJyKSA6IGVycixcbiAgICAgICAgICAgIHVuZGVmaW5lZCBhcyBhbnlcbiAgICAgICAgICk7XG4gICAgICB9XG4gICB9O1xuXG4gICByZXNwb25zZS50aGVuKG9uU3VjY2Vzcywgb25FcnJvcik7XG59XG5cbmZ1bmN0aW9uIGFkZERlcHJlY2F0aW9uTm90aWNlVG9FcnJvcihlcnI6IEdpdFJlc3BvbnNlRXJyb3IpIHtcbiAgIGxldCBsb2cgPSAobmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICBgc2ltcGxlLWdpdCBkZXByZWNhdGlvbiBub3RpY2U6IGFjY2Vzc2luZyBHaXRSZXNwb25zZUVycm9yLiR7bmFtZX0gc2hvdWxkIGJlIEdpdFJlc3BvbnNlRXJyb3IuZ2l0LiR7bmFtZX0sIHRoaXMgd2lsbCBubyBsb25nZXIgYmUgYXZhaWxhYmxlIGluIHZlcnNpb24gM2BcbiAgICAgICk7XG4gICAgICBsb2cgPSBOT09QO1xuICAgfTtcblxuICAgcmV0dXJuIE9iamVjdC5jcmVhdGUoZXJyLCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhlcnIuZ2l0KS5yZWR1Y2UoZGVzY3JpcHRvclJlZHVjZXIsIHt9KSk7XG5cbiAgIGZ1bmN0aW9uIGRlc2NyaXB0b3JSZWR1Y2VyKGFsbDogUHJvcGVydHlEZXNjcmlwdG9yTWFwLCBuYW1lOiBzdHJpbmcpOiB0eXBlb2YgYWxsIHtcbiAgICAgIGlmIChuYW1lIGluIGVycikge1xuICAgICAgICAgcmV0dXJuIGFsbDtcbiAgICAgIH1cblxuICAgICAgYWxsW25hbWVdID0ge1xuICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgbG9nKG5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIGVyci5naXRbbmFtZV07XG4gICAgICAgICB9LFxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGFsbDtcbiAgIH1cbn1cbiIsICJpbXBvcnQgeyBmb2xkZXJFeGlzdHMgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBTaW1wbGVHaXRFeGVjdXRvciB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGFkaG9jRXhlY1Rhc2sgfSBmcm9tICcuL3Rhc2snO1xuXG5leHBvcnQgZnVuY3Rpb24gY2hhbmdlV29ya2luZ0RpcmVjdG9yeVRhc2soZGlyZWN0b3J5OiBzdHJpbmcsIHJvb3Q/OiBTaW1wbGVHaXRFeGVjdXRvcikge1xuICAgcmV0dXJuIGFkaG9jRXhlY1Rhc2soKGluc3RhbmNlOiBTaW1wbGVHaXRFeGVjdXRvcikgPT4ge1xuICAgICAgaWYgKCFmb2xkZXJFeGlzdHMoZGlyZWN0b3J5KSkge1xuICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBHaXQuY3dkOiBjYW5ub3QgY2hhbmdlIHRvIG5vbi1kaXJlY3RvcnkgXCIke2RpcmVjdG9yeX1cImApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKChyb290IHx8IGluc3RhbmNlKS5jd2QgPSBkaXJlY3RvcnkpO1xuICAgfSk7XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBTaW1wbGVHaXQgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB0eXBlIHsgU2ltcGxlR2l0QXBpIH0gZnJvbSAnLi4vc2ltcGxlLWdpdC1hcGknO1xuaW1wb3J0IHsgZ2V0VHJhaWxpbmdPcHRpb25zLCByZW1vdmUsIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2sgfSBmcm9tICcuL3Rhc2snO1xuXG5mdW5jdGlvbiBjaGVja291dFRhc2soYXJnczogc3RyaW5nW10pIHtcbiAgIGNvbnN0IGNvbW1hbmRzID0gWydjaGVja291dCcsIC4uLmFyZ3NdO1xuICAgaWYgKGNvbW1hbmRzWzFdID09PSAnLWInICYmIGNvbW1hbmRzLmluY2x1ZGVzKCctQicpKSB7XG4gICAgICBjb21tYW5kc1sxXSA9IHJlbW92ZShjb21tYW5kcywgJy1CJyk7XG4gICB9XG5cbiAgIHJldHVybiBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKGNvbW1hbmRzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCk6IFBpY2s8U2ltcGxlR2l0LCAnY2hlY2tvdXQnIHwgJ2NoZWNrb3V0QnJhbmNoJyB8ICdjaGVja291dExvY2FsQnJhbmNoJz4ge1xuICAgcmV0dXJuIHtcbiAgICAgIGNoZWNrb3V0KHRoaXM6IFNpbXBsZUdpdEFwaSkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgICBjaGVja291dFRhc2soZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cywgMSkpLFxuICAgICAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICAgICAgICk7XG4gICAgICB9LFxuXG4gICAgICBjaGVja291dEJyYW5jaCh0aGlzOiBTaW1wbGVHaXRBcGksIGJyYW5jaE5hbWUsIHN0YXJ0UG9pbnQpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICAgICAgY2hlY2tvdXRUYXNrKFsnLWInLCBicmFuY2hOYW1lLCBzdGFydFBvaW50LCAuLi5nZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKV0pLFxuICAgICAgICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICAgICAgICk7XG4gICAgICB9LFxuXG4gICAgICBjaGVja291dExvY2FsQnJhbmNoKHRoaXM6IFNpbXBsZUdpdEFwaSwgYnJhbmNoTmFtZSkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgICBjaGVja291dFRhc2soWyctYicsIGJyYW5jaE5hbWUsIC4uLmdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpXSksXG4gICAgICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgICAgKTtcbiAgICAgIH0sXG4gICB9O1xufVxuIiwgImltcG9ydCB0eXBlIHsgU2ltcGxlR2l0QXBpIH0gZnJvbSAnLi4vc2ltcGxlLWdpdC1hcGknO1xuaW1wb3J0IHR5cGUgeyBTaW1wbGVHaXQgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IGFzQ2FtZWxDYXNlLCBhc051bWJlciwgTGluZVBhcnNlciwgcGFyc2VTdHJpbmdSZXNwb25zZSB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGludGVyZmFjZSBDb3VudE9iamVjdHNSZXN1bHQge1xuICAgY291bnQ6IG51bWJlcjtcbiAgIHNpemU6IG51bWJlcjtcbiAgIGluUGFjazogbnVtYmVyO1xuICAgcGFja3M6IG51bWJlcjtcbiAgIHNpemVQYWNrOiBudW1iZXI7XG4gICBwcnVuZVBhY2thYmxlOiBudW1iZXI7XG4gICBnYXJiYWdlOiBudW1iZXI7XG4gICBzaXplR2FyYmFnZTogbnVtYmVyO1xufVxuXG5mdW5jdGlvbiBjb3VudE9iamVjdHNSZXNwb25zZSgpOiBDb3VudE9iamVjdHNSZXN1bHQge1xuICAgcmV0dXJuIHtcbiAgICAgIGNvdW50OiAwLFxuICAgICAgZ2FyYmFnZTogMCxcbiAgICAgIGluUGFjazogMCxcbiAgICAgIHBhY2tzOiAwLFxuICAgICAgcHJ1bmVQYWNrYWJsZTogMCxcbiAgICAgIHNpemU6IDAsXG4gICAgICBzaXplR2FyYmFnZTogMCxcbiAgICAgIHNpemVQYWNrOiAwLFxuICAgfTtcbn1cblxuY29uc3QgcGFyc2VyOiBMaW5lUGFyc2VyPENvdW50T2JqZWN0c1Jlc3VsdD4gPSBuZXcgTGluZVBhcnNlcihcbiAgIC8oW2Etei1dKyk6IChcXGQrKSQvLFxuICAgKHJlc3VsdCwgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBjb25zdCBwcm9wZXJ0eSA9IGFzQ2FtZWxDYXNlKGtleSk7XG4gICAgICBpZiAocmVzdWx0Lmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgICAgcmVzdWx0W3Byb3BlcnR5IGFzIGtleW9mIHR5cGVvZiByZXN1bHRdID0gYXNOdW1iZXIodmFsdWUpO1xuICAgICAgfVxuICAgfVxuKTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCk6IFBpY2s8U2ltcGxlR2l0LCAnY291bnRPYmplY3RzJz4ge1xuICAgcmV0dXJuIHtcbiAgICAgIGNvdW50T2JqZWN0cyh0aGlzOiBTaW1wbGVHaXRBcGkpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKHtcbiAgICAgICAgICAgIGNvbW1hbmRzOiBbJ2NvdW50LW9iamVjdHMnLCAnLS12ZXJib3NlJ10sXG4gICAgICAgICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICAgICAgICBwYXJzZXIoc3RkT3V0OiBzdHJpbmcpIHtcbiAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVN0cmluZ1Jlc3BvbnNlKGNvdW50T2JqZWN0c1Jlc3BvbnNlKCksIFtwYXJzZXJdLCBzdGRPdXQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgIH0pO1xuICAgICAgfSxcbiAgIH07XG59XG4iLCAiaW1wb3J0IHsgQ29tbWl0UmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBMaW5lUGFyc2VyLCBwYXJzZVN0cmluZ1Jlc3BvbnNlIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5jb25zdCBwYXJzZXJzOiBMaW5lUGFyc2VyPENvbW1pdFJlc3VsdD5bXSA9IFtcbiAgIG5ldyBMaW5lUGFyc2VyKC9eXFxbKFteXFxzXSspKCBcXChbXildK1xcKSk/IChbXlxcXV0rKS8sIChyZXN1bHQsIFticmFuY2gsIHJvb3QsIGNvbW1pdF0pID0+IHtcbiAgICAgIHJlc3VsdC5icmFuY2ggPSBicmFuY2g7XG4gICAgICByZXN1bHQuY29tbWl0ID0gY29tbWl0O1xuICAgICAgcmVzdWx0LnJvb3QgPSAhIXJvb3Q7XG4gICB9KSxcbiAgIG5ldyBMaW5lUGFyc2VyKC9cXHMqQXV0aG9yOlxccyguKykvaSwgKHJlc3VsdCwgW2F1dGhvcl0pID0+IHtcbiAgICAgIGNvbnN0IHBhcnRzID0gYXV0aG9yLnNwbGl0KCc8Jyk7XG4gICAgICBjb25zdCBlbWFpbCA9IHBhcnRzLnBvcCgpO1xuXG4gICAgICBpZiAoIWVtYWlsIHx8ICFlbWFpbC5pbmNsdWRlcygnQCcpKSB7XG4gICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdC5hdXRob3IgPSB7XG4gICAgICAgICBlbWFpbDogZW1haWwuc3Vic3RyKDAsIGVtYWlsLmxlbmd0aCAtIDEpLFxuICAgICAgICAgbmFtZTogcGFydHMuam9pbignPCcpLnRyaW0oKSxcbiAgICAgIH07XG4gICB9KSxcbiAgIG5ldyBMaW5lUGFyc2VyKFxuICAgICAgLyhcXGQrKVteLF0qKD86LFxccyooXFxkKylbXixdKikoPzosXFxzKihcXGQrKSkvZyxcbiAgICAgIChyZXN1bHQsIFtjaGFuZ2VzLCBpbnNlcnRpb25zLCBkZWxldGlvbnNdKSA9PiB7XG4gICAgICAgICByZXN1bHQuc3VtbWFyeS5jaGFuZ2VzID0gcGFyc2VJbnQoY2hhbmdlcywgMTApIHx8IDA7XG4gICAgICAgICByZXN1bHQuc3VtbWFyeS5pbnNlcnRpb25zID0gcGFyc2VJbnQoaW5zZXJ0aW9ucywgMTApIHx8IDA7XG4gICAgICAgICByZXN1bHQuc3VtbWFyeS5kZWxldGlvbnMgPSBwYXJzZUludChkZWxldGlvbnMsIDEwKSB8fCAwO1xuICAgICAgfVxuICAgKSxcbiAgIG5ldyBMaW5lUGFyc2VyKFxuICAgICAgL14oXFxkKylbXixdKig/OixcXHMqKFxcZCspW14oXStcXCgoWystXSkpPy8sXG4gICAgICAocmVzdWx0LCBbY2hhbmdlcywgbGluZXMsIGRpcmVjdGlvbl0pID0+IHtcbiAgICAgICAgIHJlc3VsdC5zdW1tYXJ5LmNoYW5nZXMgPSBwYXJzZUludChjaGFuZ2VzLCAxMCkgfHwgMDtcbiAgICAgICAgIGNvbnN0IGNvdW50ID0gcGFyc2VJbnQobGluZXMsIDEwKSB8fCAwO1xuICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJy0nKSB7XG4gICAgICAgICAgICByZXN1bHQuc3VtbWFyeS5kZWxldGlvbnMgPSBjb3VudDtcbiAgICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnKycpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zdW1tYXJ5Lmluc2VydGlvbnMgPSBjb3VudDtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICksXG5dO1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VDb21taXRSZXN1bHQoc3RkT3V0OiBzdHJpbmcpOiBDb21taXRSZXN1bHQge1xuICAgY29uc3QgcmVzdWx0OiBDb21taXRSZXN1bHQgPSB7XG4gICAgICBhdXRob3I6IG51bGwsXG4gICAgICBicmFuY2g6ICcnLFxuICAgICAgY29tbWl0OiAnJyxcbiAgICAgIHJvb3Q6IGZhbHNlLFxuICAgICAgc3VtbWFyeToge1xuICAgICAgICAgY2hhbmdlczogMCxcbiAgICAgICAgIGluc2VydGlvbnM6IDAsXG4gICAgICAgICBkZWxldGlvbnM6IDAsXG4gICAgICB9LFxuICAgfTtcbiAgIHJldHVybiBwYXJzZVN0cmluZ1Jlc3BvbnNlKHJlc3VsdCwgcGFyc2Vycywgc3RkT3V0KTtcbn1cbiIsICJpbXBvcnQgdHlwZSB7IENvbW1pdFJlc3VsdCwgU2ltcGxlR2l0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgdHlwZSB7IFNpbXBsZUdpdEFwaSB9IGZyb20gJy4uL3NpbXBsZS1naXQtYXBpJztcbmltcG9ydCB0eXBlIHsgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IHBhcnNlQ29tbWl0UmVzdWx0IH0gZnJvbSAnLi4vcGFyc2Vycy9wYXJzZS1jb21taXQnO1xuaW1wb3J0IHtcbiAgIGFzQXJyYXksXG4gICBmaWx0ZXJBcnJheSxcbiAgIGZpbHRlclN0cmluZ09yU3RyaW5nQXJyYXksXG4gICBmaWx0ZXJUeXBlLFxuICAgZ2V0VHJhaWxpbmdPcHRpb25zLFxuICAgcHJlZml4ZWRBcnJheSxcbiAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudCxcbn0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgY29uZmlndXJhdGlvbkVycm9yVGFzayB9IGZyb20gJy4vdGFzayc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21taXRUYXNrKFxuICAgbWVzc2FnZTogc3RyaW5nW10sXG4gICBmaWxlczogc3RyaW5nW10sXG4gICBjdXN0b21BcmdzOiBzdHJpbmdbXVxuKTogU3RyaW5nVGFzazxDb21taXRSZXN1bHQ+IHtcbiAgIGNvbnN0IGNvbW1hbmRzOiBzdHJpbmdbXSA9IFtcbiAgICAgICctYycsXG4gICAgICAnY29yZS5hYmJyZXY9NDAnLFxuICAgICAgJ2NvbW1pdCcsXG4gICAgICAuLi5wcmVmaXhlZEFycmF5KG1lc3NhZ2UsICctbScpLFxuICAgICAgLi4uZmlsZXMsXG4gICAgICAuLi5jdXN0b21BcmdzLFxuICAgXTtcblxuICAgcmV0dXJuIHtcbiAgICAgIGNvbW1hbmRzLFxuICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgcGFyc2VyOiBwYXJzZUNvbW1pdFJlc3VsdCxcbiAgIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpOiBQaWNrPFNpbXBsZUdpdCwgJ2NvbW1pdCc+IHtcbiAgIHJldHVybiB7XG4gICAgICBjb21taXQodGhpczogU2ltcGxlR2l0QXBpLCBtZXNzYWdlOiBzdHJpbmcgfCBzdHJpbmdbXSwgLi4ucmVzdDogdW5rbm93bltdKSB7XG4gICAgICAgICBjb25zdCBuZXh0ID0gdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cyk7XG4gICAgICAgICBjb25zdCB0YXNrID1cbiAgICAgICAgICAgIHJlamVjdERlcHJlY2F0ZWRTaWduYXR1cmVzKG1lc3NhZ2UpIHx8XG4gICAgICAgICAgICBjb21taXRUYXNrKFxuICAgICAgICAgICAgICAgYXNBcnJheShtZXNzYWdlKSxcbiAgICAgICAgICAgICAgIGFzQXJyYXkoZmlsdGVyVHlwZShyZXN0WzBdLCBmaWx0ZXJTdHJpbmdPclN0cmluZ0FycmF5LCBbXSkpLFxuICAgICAgICAgICAgICAgWy4uLmZpbHRlclR5cGUocmVzdFsxXSwgZmlsdGVyQXJyYXksIFtdKSwgLi4uZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cywgMCwgdHJ1ZSldXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayh0YXNrLCBuZXh0KTtcbiAgICAgIH0sXG4gICB9O1xuXG4gICBmdW5jdGlvbiByZWplY3REZXByZWNhdGVkU2lnbmF0dXJlcyhtZXNzYWdlPzogdW5rbm93bikge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgICFmaWx0ZXJTdHJpbmdPclN0cmluZ0FycmF5KG1lc3NhZ2UpICYmXG4gICAgICAgICBjb25maWd1cmF0aW9uRXJyb3JUYXNrKFxuICAgICAgICAgICAgYGdpdC5jb21taXQ6IHJlcXVpcmVzIHRoZSBjb21taXQgbWVzc2FnZSB0byBiZSBzdXBwbGllZCBhcyBhIHN0cmluZy9zdHJpbmdbXWBcbiAgICAgICAgIClcbiAgICAgICk7XG4gICB9XG59XG4iLCAiaW1wb3J0IHsgUmVzcG9uc2UsIFNpbXBsZUdpdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgU2ltcGxlR2l0QXBpIH0gZnJvbSAnLi4vc2ltcGxlLWdpdC1hcGknO1xuaW1wb3J0IHsgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50IH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayB9IGZyb20gJy4vdGFzayc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpOiBQaWNrPFNpbXBsZUdpdCwgJ2ZpcnN0Q29tbWl0Jz4ge1xuICAgcmV0dXJuIHtcbiAgICAgIGZpcnN0Q29tbWl0KHRoaXM6IFNpbXBsZUdpdEFwaSk6IFJlc3BvbnNlPHN0cmluZz4ge1xuICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgICBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKFsncmV2LWxpc3QnLCAnLS1tYXgtcGFyZW50cz0wJywgJ0hFQUQnXSwgdHJ1ZSksXG4gICAgICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgICAgKTtcbiAgICAgIH0sXG4gICB9O1xufVxuIiwgImltcG9ydCB7IHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2sgfSBmcm9tICcuL3Rhc2snO1xuaW1wb3J0IHsgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcblxuLyoqXG4gKiBUYXNrIHVzZWQgYnkgYGdpdC5oYXNoT2JqZWN0YFxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaE9iamVjdFRhc2soZmlsZVBhdGg6IHN0cmluZywgd3JpdGU6IGJvb2xlYW4pOiBTdHJpbmdUYXNrPHN0cmluZz4ge1xuICAgY29uc3QgY29tbWFuZHMgPSBbJ2hhc2gtb2JqZWN0JywgZmlsZVBhdGhdO1xuICAgaWYgKHdyaXRlKSB7XG4gICAgICBjb21tYW5kcy5wdXNoKCctdycpO1xuICAgfVxuXG4gICByZXR1cm4gc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhjb21tYW5kcywgdHJ1ZSk7XG59XG4iLCAiaW1wb3J0IHsgSW5pdFJlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuXG5leHBvcnQgY2xhc3MgSW5pdFN1bW1hcnkgaW1wbGVtZW50cyBJbml0UmVzdWx0IHtcbiAgIGNvbnN0cnVjdG9yKFxuICAgICAgcHVibGljIHJlYWRvbmx5IGJhcmU6IGJvb2xlYW4sXG4gICAgICBwdWJsaWMgcmVhZG9ubHkgcGF0aDogc3RyaW5nLFxuICAgICAgcHVibGljIHJlYWRvbmx5IGV4aXN0aW5nOiBib29sZWFuLFxuICAgICAgcHVibGljIHJlYWRvbmx5IGdpdERpcjogc3RyaW5nXG4gICApIHt9XG59XG5cbmNvbnN0IGluaXRSZXNwb25zZVJlZ2V4ID0gL15Jbml0LisgcmVwb3NpdG9yeSBpbiAoLispJC87XG5jb25zdCByZUluaXRSZXNwb25zZVJlZ2V4ID0gL15SZWluLisgaW4gKC4rKSQvO1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VJbml0KGJhcmU6IGJvb2xlYW4sIHBhdGg6IHN0cmluZywgdGV4dDogc3RyaW5nKSB7XG4gICBjb25zdCByZXNwb25zZSA9IFN0cmluZyh0ZXh0KS50cmltKCk7XG4gICBsZXQgcmVzdWx0O1xuXG4gICBpZiAoKHJlc3VsdCA9IGluaXRSZXNwb25zZVJlZ2V4LmV4ZWMocmVzcG9uc2UpKSkge1xuICAgICAgcmV0dXJuIG5ldyBJbml0U3VtbWFyeShiYXJlLCBwYXRoLCBmYWxzZSwgcmVzdWx0WzFdKTtcbiAgIH1cblxuICAgaWYgKChyZXN1bHQgPSByZUluaXRSZXNwb25zZVJlZ2V4LmV4ZWMocmVzcG9uc2UpKSkge1xuICAgICAgcmV0dXJuIG5ldyBJbml0U3VtbWFyeShiYXJlLCBwYXRoLCB0cnVlLCByZXN1bHRbMV0pO1xuICAgfVxuXG4gICBsZXQgZ2l0RGlyID0gJyc7XG4gICBjb25zdCB0b2tlbnMgPSByZXNwb25zZS5zcGxpdCgnICcpO1xuICAgd2hpbGUgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHRva2VuID0gdG9rZW5zLnNoaWZ0KCk7XG4gICAgICBpZiAodG9rZW4gPT09ICdpbicpIHtcbiAgICAgICAgIGdpdERpciA9IHRva2Vucy5qb2luKCcgJyk7XG4gICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgIH1cblxuICAgcmV0dXJuIG5ldyBJbml0U3VtbWFyeShiYXJlLCBwYXRoLCAvXnJlL2kudGVzdChyZXNwb25zZSksIGdpdERpcik7XG59XG4iLCAiaW1wb3J0IHsgSW5pdFJlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgcGFyc2VJbml0IH0gZnJvbSAnLi4vcmVzcG9uc2VzL0luaXRTdW1tYXJ5JztcbmltcG9ydCB7IFN0cmluZ1Rhc2sgfSBmcm9tICcuLi90eXBlcyc7XG5cbmNvbnN0IGJhcmVDb21tYW5kID0gJy0tYmFyZSc7XG5cbmZ1bmN0aW9uIGhhc0JhcmVDb21tYW5kKGNvbW1hbmQ6IHN0cmluZ1tdKSB7XG4gICByZXR1cm4gY29tbWFuZC5pbmNsdWRlcyhiYXJlQ29tbWFuZCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0VGFzayhiYXJlID0gZmFsc2UsIHBhdGg6IHN0cmluZywgY3VzdG9tQXJnczogc3RyaW5nW10pOiBTdHJpbmdUYXNrPEluaXRSZXN1bHQ+IHtcbiAgIGNvbnN0IGNvbW1hbmRzID0gWydpbml0JywgLi4uY3VzdG9tQXJnc107XG4gICBpZiAoYmFyZSAmJiAhaGFzQmFyZUNvbW1hbmQoY29tbWFuZHMpKSB7XG4gICAgICBjb21tYW5kcy5zcGxpY2UoMSwgMCwgYmFyZUNvbW1hbmQpO1xuICAgfVxuXG4gICByZXR1cm4ge1xuICAgICAgY29tbWFuZHMsXG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBwYXJzZXIodGV4dDogc3RyaW5nKTogSW5pdFJlc3VsdCB7XG4gICAgICAgICByZXR1cm4gcGFyc2VJbml0KGNvbW1hbmRzLmluY2x1ZGVzKCctLWJhcmUnKSwgcGF0aCwgdGV4dCk7XG4gICAgICB9LFxuICAgfTtcbn1cbiIsICJleHBvcnQgZW51bSBMb2dGb3JtYXQge1xuICAgTk9ORSA9ICcnLFxuICAgU1RBVCA9ICctLXN0YXQnLFxuICAgTlVNX1NUQVQgPSAnLS1udW1zdGF0JyxcbiAgIE5BTUVfT05MWSA9ICctLW5hbWUtb25seScsXG4gICBOQU1FX1NUQVRVUyA9ICctLW5hbWUtc3RhdHVzJyxcbn1cblxuY29uc3QgbG9nRm9ybWF0UmVnZXggPSAvXi0tKHN0YXR8bnVtc3RhdHxuYW1lLW9ubHl8bmFtZS1zdGF0dXMpKD18JCkvO1xuXG5leHBvcnQgZnVuY3Rpb24gbG9nRm9ybWF0RnJvbUNvbW1hbmQoY3VzdG9tQXJnczogc3RyaW5nW10pIHtcbiAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VzdG9tQXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZm9ybWF0ID0gbG9nRm9ybWF0UmVnZXguZXhlYyhjdXN0b21BcmdzW2ldKTtcbiAgICAgIGlmIChmb3JtYXQpIHtcbiAgICAgICAgIHJldHVybiBgLS0ke2Zvcm1hdFsxXX1gIGFzIExvZ0Zvcm1hdDtcbiAgICAgIH1cbiAgIH1cblxuICAgcmV0dXJuIExvZ0Zvcm1hdC5OT05FO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNMb2dGb3JtYXQoY3VzdG9tQXJnOiBzdHJpbmcgfCB1bmtub3duKSB7XG4gICByZXR1cm4gbG9nRm9ybWF0UmVnZXgudGVzdChjdXN0b21BcmcgYXMgc3RyaW5nKTtcbn1cbiIsICJpbXBvcnQgeyBEaWZmUmVzdWx0LCBEaWZmUmVzdWx0QmluYXJ5RmlsZSwgRGlmZlJlc3VsdFRleHRGaWxlIH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5cbi8qKipcbiAqIFRoZSBEaWZmU3VtbWFyeSBpcyByZXR1cm5lZCBhcyBhIHJlc3BvbnNlIHRvIGdldHRpbmcgYGdpdCgpLnN0YXR1cygpYFxuICovXG5leHBvcnQgY2xhc3MgRGlmZlN1bW1hcnkgaW1wbGVtZW50cyBEaWZmUmVzdWx0IHtcbiAgIGNoYW5nZWQgPSAwO1xuICAgZGVsZXRpb25zID0gMDtcbiAgIGluc2VydGlvbnMgPSAwO1xuXG4gICBmaWxlczogQXJyYXk8RGlmZlJlc3VsdFRleHRGaWxlIHwgRGlmZlJlc3VsdEJpbmFyeUZpbGU+ID0gW107XG59XG4iLCAiaW1wb3J0IHsgRGlmZlJlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgTG9nRm9ybWF0IH0gZnJvbSAnLi4vYXJncy9sb2ctZm9ybWF0JztcbmltcG9ydCB7IERpZmZTdW1tYXJ5IH0gZnJvbSAnLi4vcmVzcG9uc2VzL0RpZmZTdW1tYXJ5JztcbmltcG9ydCB7IGlzRGlmZk5hbWVTdGF0dXMgfSBmcm9tICcuLi90YXNrcy9kaWZmLW5hbWUtc3RhdHVzJztcbmltcG9ydCB7IGFzTnVtYmVyLCBMaW5lUGFyc2VyLCBvclZvaWQsIHBhcnNlU3RyaW5nUmVzcG9uc2UgfSBmcm9tICcuLi91dGlscyc7XG5cbmNvbnN0IHN0YXRQYXJzZXIgPSBbXG4gICBuZXcgTGluZVBhcnNlcjxEaWZmUmVzdWx0PihcbiAgICAgIC9eKC4rKVxccytcXHxcXHMrKFxcZCspKFxccytbK1xcLV0rKT8kLyxcbiAgICAgIChyZXN1bHQsIFtmaWxlLCBjaGFuZ2VzLCBhbHRlcmF0aW9ucyA9ICcnXSkgPT4ge1xuICAgICAgICAgcmVzdWx0LmZpbGVzLnB1c2goe1xuICAgICAgICAgICAgZmlsZTogZmlsZS50cmltKCksXG4gICAgICAgICAgICBjaGFuZ2VzOiBhc051bWJlcihjaGFuZ2VzKSxcbiAgICAgICAgICAgIGluc2VydGlvbnM6IGFsdGVyYXRpb25zLnJlcGxhY2UoL1teK10vZywgJycpLmxlbmd0aCxcbiAgICAgICAgICAgIGRlbGV0aW9uczogYWx0ZXJhdGlvbnMucmVwbGFjZSgvW14tXS9nLCAnJykubGVuZ3RoLFxuICAgICAgICAgICAgYmluYXJ5OiBmYWxzZSxcbiAgICAgICAgIH0pO1xuICAgICAgfVxuICAgKSxcbiAgIG5ldyBMaW5lUGFyc2VyPERpZmZSZXN1bHQ+KFxuICAgICAgL14oLispIFxcfFxccytCaW4gKFswLTkuXSspIC0+IChbMC05Ll0rKSAoW2Etel0rKS8sXG4gICAgICAocmVzdWx0LCBbZmlsZSwgYmVmb3JlLCBhZnRlcl0pID0+IHtcbiAgICAgICAgIHJlc3VsdC5maWxlcy5wdXNoKHtcbiAgICAgICAgICAgIGZpbGU6IGZpbGUudHJpbSgpLFxuICAgICAgICAgICAgYmVmb3JlOiBhc051bWJlcihiZWZvcmUpLFxuICAgICAgICAgICAgYWZ0ZXI6IGFzTnVtYmVyKGFmdGVyKSxcbiAgICAgICAgICAgIGJpbmFyeTogdHJ1ZSxcbiAgICAgICAgIH0pO1xuICAgICAgfVxuICAgKSxcbiAgIG5ldyBMaW5lUGFyc2VyPERpZmZSZXN1bHQ+KFxuICAgICAgLyhcXGQrKSBmaWxlcz8gY2hhbmdlZFxccyooKD86LCBcXGQrIFteLF0rKXswLDJ9KS8sXG4gICAgICAocmVzdWx0LCBbY2hhbmdlZCwgc3VtbWFyeV0pID0+IHtcbiAgICAgICAgIGNvbnN0IGluc2VydGVkID0gLyhcXGQrKSBpLy5leGVjKHN1bW1hcnkpO1xuICAgICAgICAgY29uc3QgZGVsZXRlZCA9IC8oXFxkKykgZC8uZXhlYyhzdW1tYXJ5KTtcblxuICAgICAgICAgcmVzdWx0LmNoYW5nZWQgPSBhc051bWJlcihjaGFuZ2VkKTtcbiAgICAgICAgIHJlc3VsdC5pbnNlcnRpb25zID0gYXNOdW1iZXIoaW5zZXJ0ZWQ/LlsxXSk7XG4gICAgICAgICByZXN1bHQuZGVsZXRpb25zID0gYXNOdW1iZXIoZGVsZXRlZD8uWzFdKTtcbiAgICAgIH1cbiAgICksXG5dO1xuXG5jb25zdCBudW1TdGF0UGFyc2VyID0gW1xuICAgbmV3IExpbmVQYXJzZXI8RGlmZlJlc3VsdD4oXG4gICAgICAvKFxcZCspXFx0KFxcZCspXFx0KC4rKSQvLFxuICAgICAgKHJlc3VsdCwgW2NoYW5nZXNJbnNlcnQsIGNoYW5nZXNEZWxldGUsIGZpbGVdKSA9PiB7XG4gICAgICAgICBjb25zdCBpbnNlcnRpb25zID0gYXNOdW1iZXIoY2hhbmdlc0luc2VydCk7XG4gICAgICAgICBjb25zdCBkZWxldGlvbnMgPSBhc051bWJlcihjaGFuZ2VzRGVsZXRlKTtcblxuICAgICAgICAgcmVzdWx0LmNoYW5nZWQrKztcbiAgICAgICAgIHJlc3VsdC5pbnNlcnRpb25zICs9IGluc2VydGlvbnM7XG4gICAgICAgICByZXN1bHQuZGVsZXRpb25zICs9IGRlbGV0aW9ucztcblxuICAgICAgICAgcmVzdWx0LmZpbGVzLnB1c2goe1xuICAgICAgICAgICAgZmlsZSxcbiAgICAgICAgICAgIGNoYW5nZXM6IGluc2VydGlvbnMgKyBkZWxldGlvbnMsXG4gICAgICAgICAgICBpbnNlcnRpb25zLFxuICAgICAgICAgICAgZGVsZXRpb25zLFxuICAgICAgICAgICAgYmluYXJ5OiBmYWxzZSxcbiAgICAgICAgIH0pO1xuICAgICAgfVxuICAgKSxcbiAgIG5ldyBMaW5lUGFyc2VyPERpZmZSZXN1bHQ+KC8tXFx0LVxcdCguKykkLywgKHJlc3VsdCwgW2ZpbGVdKSA9PiB7XG4gICAgICByZXN1bHQuY2hhbmdlZCsrO1xuXG4gICAgICByZXN1bHQuZmlsZXMucHVzaCh7XG4gICAgICAgICBmaWxlLFxuICAgICAgICAgYWZ0ZXI6IDAsXG4gICAgICAgICBiZWZvcmU6IDAsXG4gICAgICAgICBiaW5hcnk6IHRydWUsXG4gICAgICB9KTtcbiAgIH0pLFxuXTtcblxuY29uc3QgbmFtZU9ubHlQYXJzZXIgPSBbXG4gICBuZXcgTGluZVBhcnNlcjxEaWZmUmVzdWx0PigvKC4rKSQvLCAocmVzdWx0LCBbZmlsZV0pID0+IHtcbiAgICAgIHJlc3VsdC5jaGFuZ2VkKys7XG4gICAgICByZXN1bHQuZmlsZXMucHVzaCh7XG4gICAgICAgICBmaWxlLFxuICAgICAgICAgY2hhbmdlczogMCxcbiAgICAgICAgIGluc2VydGlvbnM6IDAsXG4gICAgICAgICBkZWxldGlvbnM6IDAsXG4gICAgICAgICBiaW5hcnk6IGZhbHNlLFxuICAgICAgfSk7XG4gICB9KSxcbl07XG5cbmNvbnN0IG5hbWVTdGF0dXNQYXJzZXIgPSBbXG4gICBuZXcgTGluZVBhcnNlcjxEaWZmUmVzdWx0PihcbiAgICAgIC8oW0FDRE1SVFVYQl0pKFswLTldezAsM30pXFx0KC5bXlxcdF0qKShcXHQoLlteXFx0XSopKT8kLyxcbiAgICAgIChyZXN1bHQsIFtzdGF0dXMsIHNpbWlsYXJpdHksIGZyb20sIF90bywgdG9dKSA9PiB7XG4gICAgICAgICByZXN1bHQuY2hhbmdlZCsrO1xuICAgICAgICAgcmVzdWx0LmZpbGVzLnB1c2goe1xuICAgICAgICAgICAgZmlsZTogdG8gPz8gZnJvbSxcbiAgICAgICAgICAgIGNoYW5nZXM6IDAsXG4gICAgICAgICAgICBpbnNlcnRpb25zOiAwLFxuICAgICAgICAgICAgZGVsZXRpb25zOiAwLFxuICAgICAgICAgICAgYmluYXJ5OiBmYWxzZSxcbiAgICAgICAgICAgIHN0YXR1czogb3JWb2lkKGlzRGlmZk5hbWVTdGF0dXMoc3RhdHVzKSAmJiBzdGF0dXMpLFxuICAgICAgICAgICAgZnJvbTogb3JWb2lkKCEhdG8gJiYgZnJvbSAhPT0gdG8gJiYgZnJvbSksXG4gICAgICAgICAgICBzaW1pbGFyaXR5OiBhc051bWJlcihzaW1pbGFyaXR5KSxcbiAgICAgICAgIH0pO1xuICAgICAgfVxuICAgKSxcbl07XG5cbmNvbnN0IGRpZmZTdW1tYXJ5UGFyc2VyczogUmVjb3JkPExvZ0Zvcm1hdCwgTGluZVBhcnNlcjxEaWZmUmVzdWx0PltdPiA9IHtcbiAgIFtMb2dGb3JtYXQuTk9ORV06IHN0YXRQYXJzZXIsXG4gICBbTG9nRm9ybWF0LlNUQVRdOiBzdGF0UGFyc2VyLFxuICAgW0xvZ0Zvcm1hdC5OVU1fU1RBVF06IG51bVN0YXRQYXJzZXIsXG4gICBbTG9nRm9ybWF0Lk5BTUVfU1RBVFVTXTogbmFtZVN0YXR1c1BhcnNlcixcbiAgIFtMb2dGb3JtYXQuTkFNRV9PTkxZXTogbmFtZU9ubHlQYXJzZXIsXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlmZlBhcnNlcihmb3JtYXQgPSBMb2dGb3JtYXQuTk9ORSkge1xuICAgY29uc3QgcGFyc2VyID0gZGlmZlN1bW1hcnlQYXJzZXJzW2Zvcm1hdF07XG5cbiAgIHJldHVybiAoc3RkT3V0OiBzdHJpbmcpID0+IHBhcnNlU3RyaW5nUmVzcG9uc2UobmV3IERpZmZTdW1tYXJ5KCksIHBhcnNlciwgc3RkT3V0LCBmYWxzZSk7XG59XG4iLCAiaW1wb3J0IHsgTGlzdExvZ0xpbmUsIExvZ1Jlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgdG9MaW5lc1dpdGhDb250ZW50IH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgZ2V0RGlmZlBhcnNlciB9IGZyb20gJy4vcGFyc2UtZGlmZi1zdW1tYXJ5JztcbmltcG9ydCB7IExvZ0Zvcm1hdCB9IGZyb20gJy4uL2FyZ3MvbG9nLWZvcm1hdCc7XG5cbmV4cG9ydCBjb25zdCBTVEFSVF9CT1VOREFSWSA9ICdcdTAwRjJcdTAwRjJcdTAwRjJcdTAwRjJcdTAwRjJcdTAwRjIgJztcblxuZXhwb3J0IGNvbnN0IENPTU1JVF9CT1VOREFSWSA9ICcgXHUwMEYyXHUwMEYyJztcblxuZXhwb3J0IGNvbnN0IFNQTElUVEVSID0gJyBcdTAwRjIgJztcblxuY29uc3QgZGVmYXVsdEZpZWxkTmFtZXMgPSBbJ2hhc2gnLCAnZGF0ZScsICdtZXNzYWdlJywgJ3JlZnMnLCAnYXV0aG9yX25hbWUnLCAnYXV0aG9yX2VtYWlsJ107XG5cbmZ1bmN0aW9uIGxpbmVCdWlsZGVyKHRva2Vuczogc3RyaW5nW10sIGZpZWxkczogc3RyaW5nW10pOiBhbnkge1xuICAgcmV0dXJuIGZpZWxkcy5yZWR1Y2UoXG4gICAgICAobGluZSwgZmllbGQsIGluZGV4KSA9PiB7XG4gICAgICAgICBsaW5lW2ZpZWxkXSA9IHRva2Vuc1tpbmRleF0gfHwgJyc7XG4gICAgICAgICByZXR1cm4gbGluZTtcbiAgICAgIH0sXG4gICAgICBPYmplY3QuY3JlYXRlKHsgZGlmZjogbnVsbCB9KSBhcyBhbnlcbiAgICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVMaXN0TG9nU3VtbWFyeVBhcnNlcjxUID0gYW55PihcbiAgIHNwbGl0dGVyID0gU1BMSVRURVIsXG4gICBmaWVsZHMgPSBkZWZhdWx0RmllbGROYW1lcyxcbiAgIGxvZ0Zvcm1hdCA9IExvZ0Zvcm1hdC5OT05FXG4pIHtcbiAgIGNvbnN0IHBhcnNlRGlmZlJlc3VsdCA9IGdldERpZmZQYXJzZXIobG9nRm9ybWF0KTtcblxuICAgcmV0dXJuIGZ1bmN0aW9uIChzdGRPdXQ6IHN0cmluZyk6IExvZ1Jlc3VsdDxUPiB7XG4gICAgICBjb25zdCBhbGw6IFJlYWRvbmx5QXJyYXk8VCAmIExpc3RMb2dMaW5lPiA9IHRvTGluZXNXaXRoQ29udGVudChcbiAgICAgICAgIHN0ZE91dC50cmltKCksXG4gICAgICAgICBmYWxzZSxcbiAgICAgICAgIFNUQVJUX0JPVU5EQVJZXG4gICAgICApLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgY29uc3QgbGluZURldGFpbCA9IGl0ZW0uc3BsaXQoQ09NTUlUX0JPVU5EQVJZKTtcbiAgICAgICAgIGNvbnN0IGxpc3RMb2dMaW5lOiBUICYgTGlzdExvZ0xpbmUgPSBsaW5lQnVpbGRlcihsaW5lRGV0YWlsWzBdLnNwbGl0KHNwbGl0dGVyKSwgZmllbGRzKTtcblxuICAgICAgICAgaWYgKGxpbmVEZXRhaWwubGVuZ3RoID4gMSAmJiAhIWxpbmVEZXRhaWxbMV0udHJpbSgpKSB7XG4gICAgICAgICAgICBsaXN0TG9nTGluZS5kaWZmID0gcGFyc2VEaWZmUmVzdWx0KGxpbmVEZXRhaWxbMV0pO1xuICAgICAgICAgfVxuXG4gICAgICAgICByZXR1cm4gbGlzdExvZ0xpbmU7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgIGFsbCxcbiAgICAgICAgIGxhdGVzdDogKGFsbC5sZW5ndGggJiYgYWxsWzBdKSB8fCBudWxsLFxuICAgICAgICAgdG90YWw6IGFsbC5sZW5ndGgsXG4gICAgICB9O1xuICAgfTtcbn1cbiIsICJpbXBvcnQgeyBTdHJpbmdUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgRGlmZlJlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgaXNMb2dGb3JtYXQsIExvZ0Zvcm1hdCwgbG9nRm9ybWF0RnJvbUNvbW1hbmQgfSBmcm9tICcuLi9hcmdzL2xvZy1mb3JtYXQnO1xuaW1wb3J0IHsgZ2V0RGlmZlBhcnNlciB9IGZyb20gJy4uL3BhcnNlcnMvcGFyc2UtZGlmZi1zdW1tYXJ5JztcbmltcG9ydCB7IGNvbmZpZ3VyYXRpb25FcnJvclRhc2ssIEVtcHR5VGFzayB9IGZyb20gJy4vdGFzayc7XG5cbmV4cG9ydCBmdW5jdGlvbiBkaWZmU3VtbWFyeVRhc2soY3VzdG9tQXJnczogc3RyaW5nW10pOiBTdHJpbmdUYXNrPERpZmZSZXN1bHQ+IHwgRW1wdHlUYXNrIHtcbiAgIGxldCBsb2dGb3JtYXQgPSBsb2dGb3JtYXRGcm9tQ29tbWFuZChjdXN0b21BcmdzKTtcblxuICAgY29uc3QgY29tbWFuZHMgPSBbJ2RpZmYnXTtcblxuICAgaWYgKGxvZ0Zvcm1hdCA9PT0gTG9nRm9ybWF0Lk5PTkUpIHtcbiAgICAgIGxvZ0Zvcm1hdCA9IExvZ0Zvcm1hdC5TVEFUO1xuICAgICAgY29tbWFuZHMucHVzaCgnLS1zdGF0PTQwOTYnKTtcbiAgIH1cblxuICAgY29tbWFuZHMucHVzaCguLi5jdXN0b21BcmdzKTtcblxuICAgcmV0dXJuIChcbiAgICAgIHZhbGlkYXRlTG9nRm9ybWF0Q29uZmlnKGNvbW1hbmRzKSB8fCB7XG4gICAgICAgICBjb21tYW5kcyxcbiAgICAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgICAgIHBhcnNlcjogZ2V0RGlmZlBhcnNlcihsb2dGb3JtYXQpLFxuICAgICAgfVxuICAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlTG9nRm9ybWF0Q29uZmlnKGN1c3RvbUFyZ3M6IHVua25vd25bXSk6IEVtcHR5VGFzayB8IHZvaWQge1xuICAgY29uc3QgZmxhZ3MgPSBjdXN0b21BcmdzLmZpbHRlcihpc0xvZ0Zvcm1hdCk7XG5cbiAgIGlmIChmbGFncy5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4gY29uZmlndXJhdGlvbkVycm9yVGFzayhcbiAgICAgICAgIGBTdW1tYXJ5IGZsYWdzIGFyZSBtdXR1YWxseSBleGNsdXNpdmUgLSBwaWNrIG9uZSBvZiAke2ZsYWdzLmpvaW4oJywnKX1gXG4gICAgICApO1xuICAgfVxuXG4gICBpZiAoZmxhZ3MubGVuZ3RoICYmIGN1c3RvbUFyZ3MuaW5jbHVkZXMoJy16JykpIHtcbiAgICAgIHJldHVybiBjb25maWd1cmF0aW9uRXJyb3JUYXNrKFxuICAgICAgICAgYFN1bW1hcnkgZmxhZyAke2ZsYWdzfSBwYXJzaW5nIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggbnVsbCB0ZXJtaW5hdGlvbiBvcHRpb24gJy16J2BcbiAgICAgICk7XG4gICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBPcHRpb25zLCBTdHJpbmdUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHR5cGUgeyBMb2dSZXN1bHQsIFNpbXBsZUdpdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgbG9nRm9ybWF0RnJvbUNvbW1hbmQgfSBmcm9tICcuLi9hcmdzL2xvZy1mb3JtYXQnO1xuaW1wb3J0IHsgcGF0aHNwZWMgfSBmcm9tICcuLi9hcmdzL3BhdGhzcGVjJztcbmltcG9ydCB7XG4gICBDT01NSVRfQk9VTkRBUlksXG4gICBjcmVhdGVMaXN0TG9nU3VtbWFyeVBhcnNlcixcbiAgIFNQTElUVEVSLFxuICAgU1RBUlRfQk9VTkRBUlksXG59IGZyb20gJy4uL3BhcnNlcnMvcGFyc2UtbGlzdC1sb2ctc3VtbWFyeSc7XG5pbXBvcnQge1xuICAgYXBwZW5kVGFza09wdGlvbnMsXG4gICBmaWx0ZXJBcnJheSxcbiAgIGZpbHRlclByaW1pdGl2ZXMsXG4gICBmaWx0ZXJTdHJpbmcsXG4gICBmaWx0ZXJUeXBlLFxuICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50LFxuICAgdHJhaWxpbmdPcHRpb25zQXJndW1lbnQsXG59IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IFNpbXBsZUdpdEFwaSB9IGZyb20gJy4uL3NpbXBsZS1naXQtYXBpJztcbmltcG9ydCB7IGNvbmZpZ3VyYXRpb25FcnJvclRhc2sgfSBmcm9tICcuL3Rhc2snO1xuaW1wb3J0IHsgdmFsaWRhdGVMb2dGb3JtYXRDb25maWcgfSBmcm9tICcuL2RpZmYnO1xuXG5lbnVtIGV4Y2x1ZGVPcHRpb25zIHtcbiAgICctLXByZXR0eScsXG4gICAnbWF4LWNvdW50JyxcbiAgICdtYXhDb3VudCcsXG4gICAnbicsXG4gICAnZmlsZScsXG4gICAnZm9ybWF0JyxcbiAgICdmcm9tJyxcbiAgICd0bycsXG4gICAnc3BsaXR0ZXInLFxuICAgJ3N5bW1ldHJpYycsXG4gICAnbWFpbE1hcCcsXG4gICAnbXVsdGlMaW5lJyxcbiAgICdzdHJpY3REYXRlJyxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEZWZhdWx0TG9nRmllbGRzIHtcbiAgIGhhc2g6IHN0cmluZztcbiAgIGRhdGU6IHN0cmluZztcbiAgIG1lc3NhZ2U6IHN0cmluZztcbiAgIHJlZnM6IHN0cmluZztcbiAgIGJvZHk6IHN0cmluZztcbiAgIGF1dGhvcl9uYW1lOiBzdHJpbmc7XG4gICBhdXRob3JfZW1haWw6IHN0cmluZztcbn1cblxuZXhwb3J0IHR5cGUgTG9nT3B0aW9uczxUID0gRGVmYXVsdExvZ0ZpZWxkcz4gPSB7XG4gICBmaWxlPzogc3RyaW5nO1xuICAgZm9ybWF0PzogVDtcbiAgIGZyb20/OiBzdHJpbmc7XG4gICBtYWlsTWFwPzogYm9vbGVhbjtcbiAgIG1heENvdW50PzogbnVtYmVyO1xuICAgbXVsdGlMaW5lPzogYm9vbGVhbjtcbiAgIHNwbGl0dGVyPzogc3RyaW5nO1xuICAgc3RyaWN0RGF0ZT86IGJvb2xlYW47XG4gICBzeW1tZXRyaWM/OiBib29sZWFuO1xuICAgdG8/OiBzdHJpbmc7XG59O1xuXG5pbnRlcmZhY2UgUGFyc2VkTG9nT3B0aW9ucyB7XG4gICBmaWVsZHM6IHN0cmluZ1tdO1xuICAgc3BsaXR0ZXI6IHN0cmluZztcbiAgIGNvbW1hbmRzOiBzdHJpbmdbXTtcbn1cblxuZnVuY3Rpb24gcHJldHR5Rm9ybWF0KFxuICAgZm9ybWF0OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCB1bmtub3duPixcbiAgIHNwbGl0dGVyOiBzdHJpbmdcbik6IFtzdHJpbmdbXSwgc3RyaW5nXSB7XG4gICBjb25zdCBmaWVsZHM6IHN0cmluZ1tdID0gW107XG4gICBjb25zdCBmb3JtYXRTdHI6IHN0cmluZ1tdID0gW107XG5cbiAgIE9iamVjdC5rZXlzKGZvcm1hdCkuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICAgIGZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgICAgIGZvcm1hdFN0ci5wdXNoKFN0cmluZyhmb3JtYXRbZmllbGRdKSk7XG4gICB9KTtcblxuICAgcmV0dXJuIFtmaWVsZHMsIGZvcm1hdFN0ci5qb2luKHNwbGl0dGVyKV07XG59XG5cbmZ1bmN0aW9uIHVzZXJPcHRpb25zPFQgZXh0ZW5kcyBPcHRpb25zPihpbnB1dDogVCk6IE9wdGlvbnMge1xuICAgcmV0dXJuIE9iamVjdC5rZXlzKGlucHV0KS5yZWR1Y2UoKG91dCwga2V5KSA9PiB7XG4gICAgICBpZiAoIShrZXkgaW4gZXhjbHVkZU9wdGlvbnMpKSB7XG4gICAgICAgICBvdXRba2V5XSA9IGlucHV0W2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0O1xuICAgfSwge30gYXMgT3B0aW9ucyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUxvZ09wdGlvbnM8VCBleHRlbmRzIE9wdGlvbnM+KFxuICAgb3B0OiBPcHRpb25zIHwgTG9nT3B0aW9uczxUPiA9IHt9LFxuICAgY3VzdG9tQXJnczogc3RyaW5nW10gPSBbXVxuKTogUGFyc2VkTG9nT3B0aW9ucyB7XG4gICBjb25zdCBzcGxpdHRlciA9IGZpbHRlclR5cGUob3B0LnNwbGl0dGVyLCBmaWx0ZXJTdHJpbmcsIFNQTElUVEVSKTtcbiAgIGNvbnN0IGZvcm1hdCA9XG4gICAgICAhZmlsdGVyUHJpbWl0aXZlcyhvcHQuZm9ybWF0KSAmJiBvcHQuZm9ybWF0XG4gICAgICAgICA/IG9wdC5mb3JtYXRcbiAgICAgICAgIDoge1xuICAgICAgICAgICAgICBoYXNoOiAnJUgnLFxuICAgICAgICAgICAgICBkYXRlOiBvcHQuc3RyaWN0RGF0ZSA9PT0gZmFsc2UgPyAnJWFpJyA6ICclYUknLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAnJXMnLFxuICAgICAgICAgICAgICByZWZzOiAnJUQnLFxuICAgICAgICAgICAgICBib2R5OiBvcHQubXVsdGlMaW5lID8gJyVCJyA6ICclYicsXG4gICAgICAgICAgICAgIGF1dGhvcl9uYW1lOiBvcHQubWFpbE1hcCAhPT0gZmFsc2UgPyAnJWFOJyA6ICclYW4nLFxuICAgICAgICAgICAgICBhdXRob3JfZW1haWw6IG9wdC5tYWlsTWFwICE9PSBmYWxzZSA/ICclYUUnIDogJyVhZScsXG4gICAgICAgICAgIH07XG5cbiAgIGNvbnN0IFtmaWVsZHMsIGZvcm1hdFN0cl0gPSBwcmV0dHlGb3JtYXQoZm9ybWF0LCBzcGxpdHRlcik7XG5cbiAgIGNvbnN0IHN1ZmZpeDogc3RyaW5nW10gPSBbXTtcbiAgIGNvbnN0IGNvbW1hbmQ6IHN0cmluZ1tdID0gW1xuICAgICAgYC0tcHJldHR5PWZvcm1hdDoke1NUQVJUX0JPVU5EQVJZfSR7Zm9ybWF0U3RyfSR7Q09NTUlUX0JPVU5EQVJZfWAsXG4gICAgICAuLi5jdXN0b21BcmdzLFxuICAgXTtcblxuICAgY29uc3QgbWF4Q291bnQ6IG51bWJlciB8IHVuZGVmaW5lZCA9IChvcHQgYXMgYW55KS5uIHx8IChvcHQgYXMgYW55KVsnbWF4LWNvdW50J10gfHwgb3B0Lm1heENvdW50O1xuICAgaWYgKG1heENvdW50KSB7XG4gICAgICBjb21tYW5kLnB1c2goYC0tbWF4LWNvdW50PSR7bWF4Q291bnR9YCk7XG4gICB9XG5cbiAgIGlmIChvcHQuZnJvbSB8fCBvcHQudG8pIHtcbiAgICAgIGNvbnN0IHJhbmdlT3BlcmF0b3IgPSBvcHQuc3ltbWV0cmljICE9PSBmYWxzZSA/ICcuLi4nIDogJy4uJztcbiAgICAgIHN1ZmZpeC5wdXNoKGAke29wdC5mcm9tIHx8ICcnfSR7cmFuZ2VPcGVyYXRvcn0ke29wdC50byB8fCAnJ31gKTtcbiAgIH1cblxuICAgaWYgKGZpbHRlclN0cmluZyhvcHQuZmlsZSkpIHtcbiAgICAgIGNvbW1hbmQucHVzaCgnLS1mb2xsb3cnLCBwYXRoc3BlYyhvcHQuZmlsZSkpO1xuICAgfVxuXG4gICBhcHBlbmRUYXNrT3B0aW9ucyh1c2VyT3B0aW9ucyhvcHQgYXMgT3B0aW9ucyksIGNvbW1hbmQpO1xuXG4gICByZXR1cm4ge1xuICAgICAgZmllbGRzLFxuICAgICAgc3BsaXR0ZXIsXG4gICAgICBjb21tYW5kczogWy4uLmNvbW1hbmQsIC4uLnN1ZmZpeF0sXG4gICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9nVGFzazxUPihcbiAgIHNwbGl0dGVyOiBzdHJpbmcsXG4gICBmaWVsZHM6IHN0cmluZ1tdLFxuICAgY3VzdG9tQXJnczogc3RyaW5nW11cbik6IFN0cmluZ1Rhc2s8TG9nUmVzdWx0PFQ+PiB7XG4gICBjb25zdCBwYXJzZXIgPSBjcmVhdGVMaXN0TG9nU3VtbWFyeVBhcnNlcihzcGxpdHRlciwgZmllbGRzLCBsb2dGb3JtYXRGcm9tQ29tbWFuZChjdXN0b21BcmdzKSk7XG5cbiAgIHJldHVybiB7XG4gICAgICBjb21tYW5kczogWydsb2cnLCAuLi5jdXN0b21BcmdzXSxcbiAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgIHBhcnNlcixcbiAgIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpOiBQaWNrPFNpbXBsZUdpdCwgJ2xvZyc+IHtcbiAgIHJldHVybiB7XG4gICAgICBsb2c8VCBleHRlbmRzIE9wdGlvbnM+KHRoaXM6IFNpbXBsZUdpdEFwaSwgLi4ucmVzdDogdW5rbm93bltdKSB7XG4gICAgICAgICBjb25zdCBuZXh0ID0gdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cyk7XG4gICAgICAgICBjb25zdCBvcHRpb25zID0gcGFyc2VMb2dPcHRpb25zPFQ+KFxuICAgICAgICAgICAgdHJhaWxpbmdPcHRpb25zQXJndW1lbnQoYXJndW1lbnRzKSxcbiAgICAgICAgICAgIGZpbHRlclR5cGUoYXJndW1lbnRzWzBdLCBmaWx0ZXJBcnJheSlcbiAgICAgICAgICk7XG4gICAgICAgICBjb25zdCB0YXNrID1cbiAgICAgICAgICAgIHJlamVjdERlcHJlY2F0ZWRTaWduYXR1cmVzKC4uLnJlc3QpIHx8XG4gICAgICAgICAgICB2YWxpZGF0ZUxvZ0Zvcm1hdENvbmZpZyhvcHRpb25zLmNvbW1hbmRzKSB8fFxuICAgICAgICAgICAgY3JlYXRlTG9nVGFzayhvcHRpb25zKTtcblxuICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2sodGFzaywgbmV4dCk7XG4gICAgICB9LFxuICAgfTtcblxuICAgZnVuY3Rpb24gY3JlYXRlTG9nVGFzayhvcHRpb25zOiBQYXJzZWRMb2dPcHRpb25zKSB7XG4gICAgICByZXR1cm4gbG9nVGFzayhvcHRpb25zLnNwbGl0dGVyLCBvcHRpb25zLmZpZWxkcywgb3B0aW9ucy5jb21tYW5kcyk7XG4gICB9XG5cbiAgIGZ1bmN0aW9uIHJlamVjdERlcHJlY2F0ZWRTaWduYXR1cmVzKGZyb20/OiB1bmtub3duLCB0bz86IHVua25vd24pIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgICBmaWx0ZXJTdHJpbmcoZnJvbSkgJiZcbiAgICAgICAgIGZpbHRlclN0cmluZyh0bykgJiZcbiAgICAgICAgIGNvbmZpZ3VyYXRpb25FcnJvclRhc2soXG4gICAgICAgICAgICBgZ2l0LmxvZyhzdHJpbmcsIHN0cmluZykgc2hvdWxkIGJlIHJlcGxhY2VkIHdpdGggZ2l0LmxvZyh7IGZyb206IHN0cmluZywgdG86IHN0cmluZyB9KWBcbiAgICAgICAgIClcbiAgICAgICk7XG4gICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgIE1lcmdlQ29uZmxpY3QsXG4gICBNZXJnZUNvbmZsaWN0RGVsZXRpb24sXG4gICBNZXJnZURldGFpbCxcbiAgIE1lcmdlUmVzdWx0U3RhdHVzLFxufSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcblxuZXhwb3J0IGNsYXNzIE1lcmdlU3VtbWFyeUNvbmZsaWN0IGltcGxlbWVudHMgTWVyZ2VDb25mbGljdCB7XG4gICBjb25zdHJ1Y3RvcihcbiAgICAgIHB1YmxpYyByZWFkb25seSByZWFzb246IHN0cmluZyxcbiAgICAgIHB1YmxpYyByZWFkb25seSBmaWxlOiBzdHJpbmcgfCBudWxsID0gbnVsbCxcbiAgICAgIHB1YmxpYyByZWFkb25seSBtZXRhPzogTWVyZ2VDb25mbGljdERlbGV0aW9uXG4gICApIHt9XG5cbiAgIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIGAke3RoaXMuZmlsZX06JHt0aGlzLnJlYXNvbn1gO1xuICAgfVxufVxuXG5leHBvcnQgY2xhc3MgTWVyZ2VTdW1tYXJ5RGV0YWlsIGltcGxlbWVudHMgTWVyZ2VEZXRhaWwge1xuICAgcHVibGljIGNvbmZsaWN0czogTWVyZ2VDb25mbGljdFtdID0gW107XG4gICBwdWJsaWMgbWVyZ2VzOiBzdHJpbmdbXSA9IFtdO1xuICAgcHVibGljIHJlc3VsdDogTWVyZ2VSZXN1bHRTdGF0dXMgPSAnc3VjY2Vzcyc7XG5cbiAgIGdldCBmYWlsZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25mbGljdHMubGVuZ3RoID4gMDtcbiAgIH1cblxuICAgZ2V0IHJlYXNvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlc3VsdDtcbiAgIH1cblxuICAgdG9TdHJpbmcoKSB7XG4gICAgICBpZiAodGhpcy5jb25mbGljdHMubGVuZ3RoKSB7XG4gICAgICAgICByZXR1cm4gYENPTkZMSUNUUzogJHt0aGlzLmNvbmZsaWN0cy5qb2luKCcsICcpfWA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnT0snO1xuICAgfVxufVxuIiwgImltcG9ydCB7XG4gICBQdWxsRGV0YWlsRmlsZUNoYW5nZXMsXG4gICBQdWxsRGV0YWlsU3VtbWFyeSxcbiAgIFB1bGxGYWlsZWRSZXN1bHQsXG4gICBQdWxsUmVzdWx0LFxufSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcblxuZXhwb3J0IGNsYXNzIFB1bGxTdW1tYXJ5IGltcGxlbWVudHMgUHVsbFJlc3VsdCB7XG4gICBwdWJsaWMgcmVtb3RlTWVzc2FnZXMgPSB7XG4gICAgICBhbGw6IFtdLFxuICAgfTtcbiAgIHB1YmxpYyBjcmVhdGVkID0gW107XG4gICBwdWJsaWMgZGVsZXRlZDogc3RyaW5nW10gPSBbXTtcbiAgIHB1YmxpYyBmaWxlczogc3RyaW5nW10gPSBbXTtcbiAgIHB1YmxpYyBkZWxldGlvbnM6IFB1bGxEZXRhaWxGaWxlQ2hhbmdlcyA9IHt9O1xuICAgcHVibGljIGluc2VydGlvbnM6IFB1bGxEZXRhaWxGaWxlQ2hhbmdlcyA9IHt9O1xuICAgcHVibGljIHN1bW1hcnk6IFB1bGxEZXRhaWxTdW1tYXJ5ID0ge1xuICAgICAgY2hhbmdlczogMCxcbiAgICAgIGRlbGV0aW9uczogMCxcbiAgICAgIGluc2VydGlvbnM6IDAsXG4gICB9O1xufVxuXG5leHBvcnQgY2xhc3MgUHVsbEZhaWxlZFN1bW1hcnkgaW1wbGVtZW50cyBQdWxsRmFpbGVkUmVzdWx0IHtcbiAgIHJlbW90ZSA9ICcnO1xuICAgaGFzaCA9IHtcbiAgICAgIGxvY2FsOiAnJyxcbiAgICAgIHJlbW90ZTogJycsXG4gICB9O1xuICAgYnJhbmNoID0ge1xuICAgICAgbG9jYWw6ICcnLFxuICAgICAgcmVtb3RlOiAnJyxcbiAgIH07XG4gICBtZXNzYWdlID0gJyc7XG5cbiAgIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbiAgIH1cbn1cbiIsICJpbXBvcnQge1xuICAgUmVtb3RlTWVzc2FnZVJlc3VsdCxcbiAgIFJlbW90ZU1lc3NhZ2VzLFxuICAgUmVtb3RlTWVzc2FnZXNPYmplY3RFbnVtZXJhdGlvbixcbn0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBhc051bWJlciwgUmVtb3RlTGluZVBhcnNlciB9IGZyb20gJy4uL3V0aWxzJztcblxuZnVuY3Rpb24gb2JqZWN0RW51bWVyYXRpb25SZXN1bHQ8VCBleHRlbmRzIFJlbW90ZU1lc3NhZ2VzID0gUmVtb3RlTWVzc2FnZXM+KFxuICAgcmVtb3RlTWVzc2FnZXM6IFRcbik6IFJlbW90ZU1lc3NhZ2VzT2JqZWN0RW51bWVyYXRpb24ge1xuICAgcmV0dXJuIChyZW1vdGVNZXNzYWdlcy5vYmplY3RzID0gcmVtb3RlTWVzc2FnZXMub2JqZWN0cyB8fCB7XG4gICAgICBjb21wcmVzc2luZzogMCxcbiAgICAgIGNvdW50aW5nOiAwLFxuICAgICAgZW51bWVyYXRpbmc6IDAsXG4gICAgICBwYWNrUmV1c2VkOiAwLFxuICAgICAgcmV1c2VkOiB7IGNvdW50OiAwLCBkZWx0YTogMCB9LFxuICAgICAgdG90YWw6IHsgY291bnQ6IDAsIGRlbHRhOiAwIH0sXG4gICB9KTtcbn1cblxuZnVuY3Rpb24gYXNPYmplY3RDb3VudChzb3VyY2U6IHN0cmluZykge1xuICAgY29uc3QgY291bnQgPSAvXlxccyooXFxkKykvLmV4ZWMoc291cmNlKTtcbiAgIGNvbnN0IGRlbHRhID0gL2RlbHRhIChcXGQrKS9pLmV4ZWMoc291cmNlKTtcblxuICAgcmV0dXJuIHtcbiAgICAgIGNvdW50OiBhc051bWJlcigoY291bnQgJiYgY291bnRbMV0pIHx8ICcwJyksXG4gICAgICBkZWx0YTogYXNOdW1iZXIoKGRlbHRhICYmIGRlbHRhWzFdKSB8fCAnMCcpLFxuICAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IHJlbW90ZU1lc3NhZ2VzT2JqZWN0UGFyc2VyczogUmVtb3RlTGluZVBhcnNlcjxSZW1vdGVNZXNzYWdlUmVzdWx0PFJlbW90ZU1lc3NhZ2VzPj5bXSA9XG4gICBbXG4gICAgICBuZXcgUmVtb3RlTGluZVBhcnNlcihcbiAgICAgICAgIC9ecmVtb3RlOlxccyooZW51bWVyYXRpbmd8Y291bnRpbmd8Y29tcHJlc3NpbmcpIG9iamVjdHM6IChcXGQrKSwvaSxcbiAgICAgICAgIChyZXN1bHQsIFthY3Rpb24sIGNvdW50XSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gYWN0aW9uLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBjb25zdCBlbnVtZXJhdGlvbiA9IG9iamVjdEVudW1lcmF0aW9uUmVzdWx0KHJlc3VsdC5yZW1vdGVNZXNzYWdlcyk7XG5cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oZW51bWVyYXRpb24sIHsgW2tleV06IGFzTnVtYmVyKGNvdW50KSB9KTtcbiAgICAgICAgIH1cbiAgICAgICksXG4gICAgICBuZXcgUmVtb3RlTGluZVBhcnNlcihcbiAgICAgICAgIC9ecmVtb3RlOlxccyooZW51bWVyYXRpbmd8Y291bnRpbmd8Y29tcHJlc3NpbmcpIG9iamVjdHM6IFxcZCslIFxcKFxcZCtcXC8oXFxkKylcXCksL2ksXG4gICAgICAgICAocmVzdWx0LCBbYWN0aW9uLCBjb3VudF0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGFjdGlvbi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgY29uc3QgZW51bWVyYXRpb24gPSBvYmplY3RFbnVtZXJhdGlvblJlc3VsdChyZXN1bHQucmVtb3RlTWVzc2FnZXMpO1xuXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGVudW1lcmF0aW9uLCB7IFtrZXldOiBhc051bWJlcihjb3VudCkgfSk7XG4gICAgICAgICB9XG4gICAgICApLFxuICAgICAgbmV3IFJlbW90ZUxpbmVQYXJzZXIoXG4gICAgICAgICAvdG90YWwgKFteLF0rKSwgcmV1c2VkIChbXixdKyksIHBhY2stcmV1c2VkIChcXGQrKS9pLFxuICAgICAgICAgKHJlc3VsdCwgW3RvdGFsLCByZXVzZWQsIHBhY2tSZXVzZWRdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvYmplY3RzID0gb2JqZWN0RW51bWVyYXRpb25SZXN1bHQocmVzdWx0LnJlbW90ZU1lc3NhZ2VzKTtcbiAgICAgICAgICAgIG9iamVjdHMudG90YWwgPSBhc09iamVjdENvdW50KHRvdGFsKTtcbiAgICAgICAgICAgIG9iamVjdHMucmV1c2VkID0gYXNPYmplY3RDb3VudChyZXVzZWQpO1xuICAgICAgICAgICAgb2JqZWN0cy5wYWNrUmV1c2VkID0gYXNOdW1iZXIocGFja1JldXNlZCk7XG4gICAgICAgICB9XG4gICAgICApLFxuICAgXTtcbiIsICJpbXBvcnQgeyBQdXNoUmVzdWx0UmVtb3RlTWVzc2FnZXMsIFJlbW90ZU1lc3NhZ2VSZXN1bHQsIFJlbW90ZU1lc3NhZ2VzIH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBhc051bWJlciwgcGFyc2VTdHJpbmdSZXNwb25zZSwgUmVtb3RlTGluZVBhcnNlciB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IHJlbW90ZU1lc3NhZ2VzT2JqZWN0UGFyc2VycyB9IGZyb20gJy4vcGFyc2UtcmVtb3RlLW9iamVjdHMnO1xuXG5jb25zdCBwYXJzZXJzOiBSZW1vdGVMaW5lUGFyc2VyPFJlbW90ZU1lc3NhZ2VSZXN1bHQ8UHVzaFJlc3VsdFJlbW90ZU1lc3NhZ2VzIHwgUmVtb3RlTWVzc2FnZXM+PltdID1cbiAgIFtcbiAgICAgIG5ldyBSZW1vdGVMaW5lUGFyc2VyKC9ecmVtb3RlOlxccyooLispJC8sIChyZXN1bHQsIFt0ZXh0XSkgPT4ge1xuICAgICAgICAgcmVzdWx0LnJlbW90ZU1lc3NhZ2VzLmFsbC5wdXNoKHRleHQudHJpbSgpKTtcbiAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pLFxuICAgICAgLi4ucmVtb3RlTWVzc2FnZXNPYmplY3RQYXJzZXJzLFxuICAgICAgbmV3IFJlbW90ZUxpbmVQYXJzZXIoXG4gICAgICAgICBbL2NyZWF0ZSBhICg/OnB1bGx8bWVyZ2UpIHJlcXVlc3QvaSwgL1xccyhodHRwcz86XFwvXFwvXFxTKykkL10sXG4gICAgICAgICAocmVzdWx0LCBbcHVsbFJlcXVlc3RVcmxdKSA9PiB7XG4gICAgICAgICAgICAocmVzdWx0LnJlbW90ZU1lc3NhZ2VzIGFzIFB1c2hSZXN1bHRSZW1vdGVNZXNzYWdlcykucHVsbFJlcXVlc3RVcmwgPSBwdWxsUmVxdWVzdFVybDtcbiAgICAgICAgIH1cbiAgICAgICksXG4gICAgICBuZXcgUmVtb3RlTGluZVBhcnNlcihcbiAgICAgICAgIFsvZm91bmQgKFxcZCspIHZ1bG5lcmFiaWxpdGllcy4rXFwoKFteKV0rKVxcKS9pLCAvXFxzKGh0dHBzPzpcXC9cXC9cXFMrKSQvXSxcbiAgICAgICAgIChyZXN1bHQsIFtjb3VudCwgc3VtbWFyeSwgdXJsXSkgPT4ge1xuICAgICAgICAgICAgKHJlc3VsdC5yZW1vdGVNZXNzYWdlcyBhcyBQdXNoUmVzdWx0UmVtb3RlTWVzc2FnZXMpLnZ1bG5lcmFiaWxpdGllcyA9IHtcbiAgICAgICAgICAgICAgIGNvdW50OiBhc051bWJlcihjb3VudCksXG4gICAgICAgICAgICAgICBzdW1tYXJ5LFxuICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgIH1cbiAgICAgICksXG4gICBdO1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VSZW1vdGVNZXNzYWdlczxUIGV4dGVuZHMgUmVtb3RlTWVzc2FnZXMgPSBSZW1vdGVNZXNzYWdlcz4oXG4gICBfc3RkT3V0OiBzdHJpbmcsXG4gICBzdGRFcnI6IHN0cmluZ1xuKTogUmVtb3RlTWVzc2FnZVJlc3VsdCB7XG4gICByZXR1cm4gcGFyc2VTdHJpbmdSZXNwb25zZSh7IHJlbW90ZU1lc3NhZ2VzOiBuZXcgUmVtb3RlTWVzc2FnZVN1bW1hcnkoKSBhcyBUIH0sIHBhcnNlcnMsIHN0ZEVycik7XG59XG5cbmV4cG9ydCBjbGFzcyBSZW1vdGVNZXNzYWdlU3VtbWFyeSBpbXBsZW1lbnRzIFJlbW90ZU1lc3NhZ2VzIHtcbiAgIHB1YmxpYyByZWFkb25seSBhbGw6IHN0cmluZ1tdID0gW107XG59XG4iLCAiaW1wb3J0IHsgUHVsbERldGFpbCwgUHVsbEZhaWxlZFJlc3VsdCwgUHVsbFJlc3VsdCwgUmVtb3RlTWVzc2FnZXMgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IFB1bGxGYWlsZWRTdW1tYXJ5LCBQdWxsU3VtbWFyeSB9IGZyb20gJy4uL3Jlc3BvbnNlcy9QdWxsU3VtbWFyeSc7XG5pbXBvcnQgeyBUYXNrUGFyc2VyIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgYXBwZW5kLCBMaW5lUGFyc2VyLCBwYXJzZVN0cmluZ1Jlc3BvbnNlIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgcGFyc2VSZW1vdGVNZXNzYWdlcyB9IGZyb20gJy4vcGFyc2UtcmVtb3RlLW1lc3NhZ2VzJztcblxuY29uc3QgRklMRV9VUERBVEVfUkVHRVggPSAvXlxccyooLis/KVxccytcXHxcXHMrXFxkK1xccyooXFwrKikoLSopLztcbmNvbnN0IFNVTU1BUllfUkVHRVggPSAvKFxcZCspXFxEKygoXFxkKylcXEQrXFwoXFwrXFwpKT8oXFxEKyhcXGQrKVxcRCtcXCgtXFwpKT8vO1xuY29uc3QgQUNUSU9OX1JFR0VYID0gL14oY3JlYXRlfGRlbGV0ZSkgbW9kZSBcXGQrICguKykvO1xuXG5jb25zdCBwYXJzZXJzOiBMaW5lUGFyc2VyPFB1bGxSZXN1bHQ+W10gPSBbXG4gICBuZXcgTGluZVBhcnNlcihGSUxFX1VQREFURV9SRUdFWCwgKHJlc3VsdCwgW2ZpbGUsIGluc2VydGlvbnMsIGRlbGV0aW9uc10pID0+IHtcbiAgICAgIHJlc3VsdC5maWxlcy5wdXNoKGZpbGUpO1xuXG4gICAgICBpZiAoaW5zZXJ0aW9ucykge1xuICAgICAgICAgcmVzdWx0Lmluc2VydGlvbnNbZmlsZV0gPSBpbnNlcnRpb25zLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlbGV0aW9ucykge1xuICAgICAgICAgcmVzdWx0LmRlbGV0aW9uc1tmaWxlXSA9IGRlbGV0aW9ucy5sZW5ndGg7XG4gICAgICB9XG4gICB9KSxcbiAgIG5ldyBMaW5lUGFyc2VyKFNVTU1BUllfUkVHRVgsIChyZXN1bHQsIFtjaGFuZ2VzLCAsIGluc2VydGlvbnMsICwgZGVsZXRpb25zXSkgPT4ge1xuICAgICAgaWYgKGluc2VydGlvbnMgIT09IHVuZGVmaW5lZCB8fCBkZWxldGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgcmVzdWx0LnN1bW1hcnkuY2hhbmdlcyA9ICtjaGFuZ2VzIHx8IDA7XG4gICAgICAgICByZXN1bHQuc3VtbWFyeS5pbnNlcnRpb25zID0gK2luc2VydGlvbnMgfHwgMDtcbiAgICAgICAgIHJlc3VsdC5zdW1tYXJ5LmRlbGV0aW9ucyA9ICtkZWxldGlvbnMgfHwgMDtcbiAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgfSksXG4gICBuZXcgTGluZVBhcnNlcihBQ1RJT05fUkVHRVgsIChyZXN1bHQsIFthY3Rpb24sIGZpbGVdKSA9PiB7XG4gICAgICBhcHBlbmQocmVzdWx0LmZpbGVzLCBmaWxlKTtcbiAgICAgIGFwcGVuZChhY3Rpb24gPT09ICdjcmVhdGUnID8gcmVzdWx0LmNyZWF0ZWQgOiByZXN1bHQuZGVsZXRlZCwgZmlsZSk7XG4gICB9KSxcbl07XG5cbmNvbnN0IGVycm9yUGFyc2VyczogTGluZVBhcnNlcjxQdWxsRmFpbGVkUmVzdWx0PltdID0gW1xuICAgbmV3IExpbmVQYXJzZXIoL15mcm9tXFxzKC4rKSQvaSwgKHJlc3VsdCwgW3JlbW90ZV0pID0+IHZvaWQgKHJlc3VsdC5yZW1vdGUgPSByZW1vdGUpKSxcbiAgIG5ldyBMaW5lUGFyc2VyKC9eZmF0YWw6XFxzKC4rKSQvLCAocmVzdWx0LCBbbWVzc2FnZV0pID0+IHZvaWQgKHJlc3VsdC5tZXNzYWdlID0gbWVzc2FnZSkpLFxuICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAvKFthLXowLTldKylcXC5cXC4oW2EtejAtOV0rKVxccysoXFxTKylcXHMrLT5cXHMrKFxcUyspJC8sXG4gICAgICAocmVzdWx0LCBbaGFzaExvY2FsLCBoYXNoUmVtb3RlLCBicmFuY2hMb2NhbCwgYnJhbmNoUmVtb3RlXSkgPT4ge1xuICAgICAgICAgcmVzdWx0LmJyYW5jaC5sb2NhbCA9IGJyYW5jaExvY2FsO1xuICAgICAgICAgcmVzdWx0Lmhhc2gubG9jYWwgPSBoYXNoTG9jYWw7XG4gICAgICAgICByZXN1bHQuYnJhbmNoLnJlbW90ZSA9IGJyYW5jaFJlbW90ZTtcbiAgICAgICAgIHJlc3VsdC5oYXNoLnJlbW90ZSA9IGhhc2hSZW1vdGU7XG4gICAgICB9XG4gICApLFxuXTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlUHVsbERldGFpbDogVGFza1BhcnNlcjxzdHJpbmcsIFB1bGxEZXRhaWw+ID0gKHN0ZE91dCwgc3RkRXJyKSA9PiB7XG4gICByZXR1cm4gcGFyc2VTdHJpbmdSZXNwb25zZShuZXcgUHVsbFN1bW1hcnkoKSwgcGFyc2VycywgW3N0ZE91dCwgc3RkRXJyXSk7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2VQdWxsUmVzdWx0OiBUYXNrUGFyc2VyPHN0cmluZywgUHVsbFJlc3VsdD4gPSAoc3RkT3V0LCBzdGRFcnIpID0+IHtcbiAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgbmV3IFB1bGxTdW1tYXJ5KCksXG4gICAgICBwYXJzZVB1bGxEZXRhaWwoc3RkT3V0LCBzdGRFcnIpLFxuICAgICAgcGFyc2VSZW1vdGVNZXNzYWdlczxSZW1vdGVNZXNzYWdlcz4oc3RkT3V0LCBzdGRFcnIpXG4gICApO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUHVsbEVycm9yUmVzdWx0KHN0ZE91dDogc3RyaW5nLCBzdGRFcnI6IHN0cmluZykge1xuICAgY29uc3QgcHVsbEVycm9yID0gcGFyc2VTdHJpbmdSZXNwb25zZShuZXcgUHVsbEZhaWxlZFN1bW1hcnkoKSwgZXJyb3JQYXJzZXJzLCBbc3RkT3V0LCBzdGRFcnJdKTtcblxuICAgcmV0dXJuIHB1bGxFcnJvci5tZXNzYWdlICYmIHB1bGxFcnJvcjtcbn1cbiIsICJpbXBvcnQgeyBNZXJnZURldGFpbCwgTWVyZ2VSZXN1bHQgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IE1lcmdlU3VtbWFyeUNvbmZsaWN0LCBNZXJnZVN1bW1hcnlEZXRhaWwgfSBmcm9tICcuLi9yZXNwb25zZXMvTWVyZ2VTdW1tYXJ5JztcbmltcG9ydCB7IFRhc2tQYXJzZXIgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBMaW5lUGFyc2VyLCBwYXJzZVN0cmluZ1Jlc3BvbnNlIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgcGFyc2VQdWxsUmVzdWx0IH0gZnJvbSAnLi9wYXJzZS1wdWxsJztcblxuY29uc3QgcGFyc2VyczogTGluZVBhcnNlcjxNZXJnZURldGFpbD5bXSA9IFtcbiAgIG5ldyBMaW5lUGFyc2VyKC9eQXV0by1tZXJnaW5nXFxzKyguKykkLywgKHN1bW1hcnksIFthdXRvTWVyZ2VdKSA9PiB7XG4gICAgICBzdW1tYXJ5Lm1lcmdlcy5wdXNoKGF1dG9NZXJnZSk7XG4gICB9KSxcbiAgIG5ldyBMaW5lUGFyc2VyKC9eQ09ORkxJQ1RcXHMrXFwoKC4rKVxcKTogTWVyZ2UgY29uZmxpY3QgaW4gKC4rKSQvLCAoc3VtbWFyeSwgW3JlYXNvbiwgZmlsZV0pID0+IHtcbiAgICAgIHN1bW1hcnkuY29uZmxpY3RzLnB1c2gobmV3IE1lcmdlU3VtbWFyeUNvbmZsaWN0KHJlYXNvbiwgZmlsZSkpO1xuICAgfSksXG4gICBuZXcgTGluZVBhcnNlcihcbiAgICAgIC9eQ09ORkxJQ1RcXHMrXFwoKC4rXFwvZGVsZXRlKVxcKTogKC4rKSBkZWxldGVkIGluICguKykgYW5kLyxcbiAgICAgIChzdW1tYXJ5LCBbcmVhc29uLCBmaWxlLCBkZWxldGVSZWZdKSA9PiB7XG4gICAgICAgICBzdW1tYXJ5LmNvbmZsaWN0cy5wdXNoKG5ldyBNZXJnZVN1bW1hcnlDb25mbGljdChyZWFzb24sIGZpbGUsIHsgZGVsZXRlUmVmIH0pKTtcbiAgICAgIH1cbiAgICksXG4gICBuZXcgTGluZVBhcnNlcigvXkNPTkZMSUNUXFxzK1xcKCguKylcXCk6LywgKHN1bW1hcnksIFtyZWFzb25dKSA9PiB7XG4gICAgICBzdW1tYXJ5LmNvbmZsaWN0cy5wdXNoKG5ldyBNZXJnZVN1bW1hcnlDb25mbGljdChyZWFzb24sIG51bGwpKTtcbiAgIH0pLFxuICAgbmV3IExpbmVQYXJzZXIoL15BdXRvbWF0aWMgbWVyZ2UgZmFpbGVkO1xccysoLispJC8sIChzdW1tYXJ5LCBbcmVzdWx0XSkgPT4ge1xuICAgICAgc3VtbWFyeS5yZXN1bHQgPSByZXN1bHQ7XG4gICB9KSxcbl07XG5cbi8qKlxuICogUGFyc2UgdGhlIGNvbXBsZXRlIHJlc3BvbnNlIGZyb20gYGdpdC5tZXJnZWBcbiAqL1xuZXhwb3J0IGNvbnN0IHBhcnNlTWVyZ2VSZXN1bHQ6IFRhc2tQYXJzZXI8c3RyaW5nLCBNZXJnZVJlc3VsdD4gPSAoc3RkT3V0LCBzdGRFcnIpID0+IHtcbiAgIHJldHVybiBPYmplY3QuYXNzaWduKHBhcnNlTWVyZ2VEZXRhaWwoc3RkT3V0LCBzdGRFcnIpLCBwYXJzZVB1bGxSZXN1bHQoc3RkT3V0LCBzdGRFcnIpKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIG1lcmdlIHNwZWNpZmljIGRldGFpbCAoaWU6IG5vdCB0aGUgY29udGVudCBhbHNvIGF2YWlsYWJsZSBpbiB0aGUgcHVsbCBkZXRhaWwpIGZyb20gYGdpdC5tbmVyZ2VgXG4gKiBAcGFyYW0gc3RkT3V0XG4gKi9cbmV4cG9ydCBjb25zdCBwYXJzZU1lcmdlRGV0YWlsOiBUYXNrUGFyc2VyPHN0cmluZywgTWVyZ2VEZXRhaWw+ID0gKHN0ZE91dCkgPT4ge1xuICAgcmV0dXJuIHBhcnNlU3RyaW5nUmVzcG9uc2UobmV3IE1lcmdlU3VtbWFyeURldGFpbCgpLCBwYXJzZXJzLCBzdGRPdXQpO1xufTtcbiIsICJpbXBvcnQgeyBNZXJnZVJlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgR2l0UmVzcG9uc2VFcnJvciB9IGZyb20gJy4uL2Vycm9ycy9naXQtcmVzcG9uc2UtZXJyb3InO1xuaW1wb3J0IHsgcGFyc2VNZXJnZVJlc3VsdCB9IGZyb20gJy4uL3BhcnNlcnMvcGFyc2UtbWVyZ2UnO1xuaW1wb3J0IHsgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGNvbmZpZ3VyYXRpb25FcnJvclRhc2ssIEVtcHR5VGFzayB9IGZyb20gJy4vdGFzayc7XG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZVRhc2soY3VzdG9tQXJnczogc3RyaW5nW10pOiBFbXB0eVRhc2sgfCBTdHJpbmdUYXNrPE1lcmdlUmVzdWx0PiB7XG4gICBpZiAoIWN1c3RvbUFyZ3MubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gY29uZmlndXJhdGlvbkVycm9yVGFzaygnR2l0Lm1lcmdlIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBvcHRpb24nKTtcbiAgIH1cblxuICAgcmV0dXJuIHtcbiAgICAgIGNvbW1hbmRzOiBbJ21lcmdlJywgLi4uY3VzdG9tQXJnc10sXG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBwYXJzZXIoc3RkT3V0LCBzdGRFcnIpOiBNZXJnZVJlc3VsdCB7XG4gICAgICAgICBjb25zdCBtZXJnZSA9IHBhcnNlTWVyZ2VSZXN1bHQoc3RkT3V0LCBzdGRFcnIpO1xuICAgICAgICAgaWYgKG1lcmdlLmZhaWxlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEdpdFJlc3BvbnNlRXJyb3IobWVyZ2UpO1xuICAgICAgICAgfVxuXG4gICAgICAgICByZXR1cm4gbWVyZ2U7XG4gICAgICB9LFxuICAgfTtcbn1cbiIsICJpbXBvcnQge1xuICAgUHVzaERldGFpbCxcbiAgIFB1c2hSZXN1bHQsXG4gICBQdXNoUmVzdWx0UHVzaGVkSXRlbSxcbiAgIFB1c2hSZXN1bHRSZW1vdGVNZXNzYWdlcyxcbn0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBUYXNrUGFyc2VyIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgTGluZVBhcnNlciwgcGFyc2VTdHJpbmdSZXNwb25zZSB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IHBhcnNlUmVtb3RlTWVzc2FnZXMgfSBmcm9tICcuL3BhcnNlLXJlbW90ZS1tZXNzYWdlcyc7XG5cbmZ1bmN0aW9uIHB1c2hSZXN1bHRQdXNoZWRJdGVtKGxvY2FsOiBzdHJpbmcsIHJlbW90ZTogc3RyaW5nLCBzdGF0dXM6IHN0cmluZyk6IFB1c2hSZXN1bHRQdXNoZWRJdGVtIHtcbiAgIGNvbnN0IGRlbGV0ZWQgPSBzdGF0dXMuaW5jbHVkZXMoJ2RlbGV0ZWQnKTtcbiAgIGNvbnN0IHRhZyA9IHN0YXR1cy5pbmNsdWRlcygndGFnJykgfHwgL15yZWZzXFwvdGFncy8udGVzdChsb2NhbCk7XG4gICBjb25zdCBhbHJlYWR5VXBkYXRlZCA9ICFzdGF0dXMuaW5jbHVkZXMoJ25ldycpO1xuXG4gICByZXR1cm4ge1xuICAgICAgZGVsZXRlZCxcbiAgICAgIHRhZyxcbiAgICAgIGJyYW5jaDogIXRhZyxcbiAgICAgIG5ldzogIWFscmVhZHlVcGRhdGVkLFxuICAgICAgYWxyZWFkeVVwZGF0ZWQsXG4gICAgICBsb2NhbCxcbiAgICAgIHJlbW90ZSxcbiAgIH07XG59XG5cbmNvbnN0IHBhcnNlcnM6IExpbmVQYXJzZXI8UHVzaERldGFpbD5bXSA9IFtcbiAgIG5ldyBMaW5lUGFyc2VyKC9eUHVzaGluZyB0byAoLispJC8sIChyZXN1bHQsIFtyZXBvXSkgPT4ge1xuICAgICAgcmVzdWx0LnJlcG8gPSByZXBvO1xuICAgfSksXG4gICBuZXcgTGluZVBhcnNlcigvXnVwZGF0aW5nIGxvY2FsIHRyYWNraW5nIHJlZiAnKC4rKScvLCAocmVzdWx0LCBbbG9jYWxdKSA9PiB7XG4gICAgICByZXN1bHQucmVmID0ge1xuICAgICAgICAgLi4uKHJlc3VsdC5yZWYgfHwge30pLFxuICAgICAgICAgbG9jYWwsXG4gICAgICB9O1xuICAgfSksXG4gICBuZXcgTGluZVBhcnNlcigvXls9Ki1dXFxzKyhbXjpdKyk6KFxcUyspXFxzK1xcWyguKyldJC8sIChyZXN1bHQsIFtsb2NhbCwgcmVtb3RlLCB0eXBlXSkgPT4ge1xuICAgICAgcmVzdWx0LnB1c2hlZC5wdXNoKHB1c2hSZXN1bHRQdXNoZWRJdGVtKGxvY2FsLCByZW1vdGUsIHR5cGUpKTtcbiAgIH0pLFxuICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAvXkJyYW5jaCAnKFteJ10rKScgc2V0IHVwIHRvIHRyYWNrIHJlbW90ZSBicmFuY2ggJyhbXiddKyknIGZyb20gJyhbXiddKyknLyxcbiAgICAgIChyZXN1bHQsIFtsb2NhbCwgcmVtb3RlLCByZW1vdGVOYW1lXSkgPT4ge1xuICAgICAgICAgcmVzdWx0LmJyYW5jaCA9IHtcbiAgICAgICAgICAgIC4uLihyZXN1bHQuYnJhbmNoIHx8IHt9KSxcbiAgICAgICAgICAgIGxvY2FsLFxuICAgICAgICAgICAgcmVtb3RlLFxuICAgICAgICAgICAgcmVtb3RlTmFtZSxcbiAgICAgICAgIH07XG4gICAgICB9XG4gICApLFxuICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAvXihbXjpdKyk6KFxcUyspXFxzKyhbYS16MC05XSspXFwuXFwuKFthLXowLTldKykkLyxcbiAgICAgIChyZXN1bHQsIFtsb2NhbCwgcmVtb3RlLCBmcm9tLCB0b10pID0+IHtcbiAgICAgICAgIHJlc3VsdC51cGRhdGUgPSB7XG4gICAgICAgICAgICBoZWFkOiB7XG4gICAgICAgICAgICAgICBsb2NhbCxcbiAgICAgICAgICAgICAgIHJlbW90ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYXNoOiB7XG4gICAgICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgfTtcbiAgICAgIH1cbiAgICksXG5dO1xuXG5leHBvcnQgY29uc3QgcGFyc2VQdXNoUmVzdWx0OiBUYXNrUGFyc2VyPHN0cmluZywgUHVzaFJlc3VsdD4gPSAoc3RkT3V0LCBzdGRFcnIpID0+IHtcbiAgIGNvbnN0IHB1c2hEZXRhaWwgPSBwYXJzZVB1c2hEZXRhaWwoc3RkT3V0LCBzdGRFcnIpO1xuICAgY29uc3QgcmVzcG9uc2VEZXRhaWwgPSBwYXJzZVJlbW90ZU1lc3NhZ2VzPFB1c2hSZXN1bHRSZW1vdGVNZXNzYWdlcz4oc3RkT3V0LCBzdGRFcnIpO1xuXG4gICByZXR1cm4ge1xuICAgICAgLi4ucHVzaERldGFpbCxcbiAgICAgIC4uLnJlc3BvbnNlRGV0YWlsLFxuICAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBwYXJzZVB1c2hEZXRhaWw6IFRhc2tQYXJzZXI8c3RyaW5nLCBQdXNoRGV0YWlsPiA9IChzdGRPdXQsIHN0ZEVycikgPT4ge1xuICAgcmV0dXJuIHBhcnNlU3RyaW5nUmVzcG9uc2UoeyBwdXNoZWQ6IFtdIH0sIHBhcnNlcnMsIFtzdGRPdXQsIHN0ZEVycl0pO1xufTtcbiIsICJpbXBvcnQgeyBQdXNoUmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBwYXJzZVB1c2hSZXN1bHQgYXMgcGFyc2VyIH0gZnJvbSAnLi4vcGFyc2Vycy9wYXJzZS1wdXNoJztcbmltcG9ydCB7IFN0cmluZ1Rhc2sgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBhcHBlbmQsIHJlbW92ZSB9IGZyb20gJy4uL3V0aWxzJztcblxudHlwZSBQdXNoUmVmID0geyByZW1vdGU/OiBzdHJpbmc7IGJyYW5jaD86IHN0cmluZyB9O1xuXG5leHBvcnQgZnVuY3Rpb24gcHVzaFRhZ3NUYXNrKHJlZjogUHVzaFJlZiA9IHt9LCBjdXN0b21BcmdzOiBzdHJpbmdbXSk6IFN0cmluZ1Rhc2s8UHVzaFJlc3VsdD4ge1xuICAgYXBwZW5kKGN1c3RvbUFyZ3MsICctLXRhZ3MnKTtcbiAgIHJldHVybiBwdXNoVGFzayhyZWYsIGN1c3RvbUFyZ3MpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHVzaFRhc2socmVmOiBQdXNoUmVmID0ge30sIGN1c3RvbUFyZ3M6IHN0cmluZ1tdKTogU3RyaW5nVGFzazxQdXNoUmVzdWx0PiB7XG4gICBjb25zdCBjb21tYW5kcyA9IFsncHVzaCcsIC4uLmN1c3RvbUFyZ3NdO1xuICAgaWYgKHJlZi5icmFuY2gpIHtcbiAgICAgIGNvbW1hbmRzLnNwbGljZSgxLCAwLCByZWYuYnJhbmNoKTtcbiAgIH1cbiAgIGlmIChyZWYucmVtb3RlKSB7XG4gICAgICBjb21tYW5kcy5zcGxpY2UoMSwgMCwgcmVmLnJlbW90ZSk7XG4gICB9XG5cbiAgIHJlbW92ZShjb21tYW5kcywgJy12Jyk7XG4gICBhcHBlbmQoY29tbWFuZHMsICctLXZlcmJvc2UnKTtcbiAgIGFwcGVuZChjb21tYW5kcywgJy0tcG9yY2VsYWluJyk7XG5cbiAgIHJldHVybiB7XG4gICAgICBjb21tYW5kcyxcbiAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgIHBhcnNlcixcbiAgIH07XG59XG4iLCAiaW1wb3J0IHsgU2ltcGxlR2l0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBTaW1wbGVHaXRBcGkgfSBmcm9tICcuLi9zaW1wbGUtZ2l0LWFwaSc7XG5pbXBvcnQgeyBnZXRUcmFpbGluZ09wdGlvbnMsIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IHN0cmFpZ2h0VGhyb3VnaEJ1ZmZlclRhc2ssIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2sgfSBmcm9tICcuL3Rhc2snO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKTogUGljazxTaW1wbGVHaXQsICdzaG93QnVmZmVyJyB8ICdzaG93Jz4ge1xuICAgcmV0dXJuIHtcbiAgICAgIHNob3dCdWZmZXIodGhpczogU2ltcGxlR2l0QXBpKSB7XG4gICAgICAgICBjb25zdCBjb21tYW5kcyA9IFsnc2hvdycsIC4uLmdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMsIDEpXTtcbiAgICAgICAgIGlmICghY29tbWFuZHMuaW5jbHVkZXMoJy0tYmluYXJ5JykpIHtcbiAgICAgICAgICAgIGNvbW1hbmRzLnNwbGljZSgxLCAwLCAnLS1iaW5hcnknKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgICBzdHJhaWdodFRocm91Z2hCdWZmZXJUYXNrKGNvbW1hbmRzKSxcbiAgICAgICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICAgICApO1xuICAgICAgfSxcblxuICAgICAgc2hvdyh0aGlzOiBTaW1wbGVHaXRBcGkpIHtcbiAgICAgICAgIGNvbnN0IGNvbW1hbmRzID0gWydzaG93JywgLi4uZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cywgMSldO1xuICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgICBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKGNvbW1hbmRzKSxcbiAgICAgICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICAgICApO1xuICAgICAgfSxcbiAgIH07XG59XG4iLCAiaW1wb3J0IHsgRmlsZVN0YXR1c1Jlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuXG5leHBvcnQgY29uc3QgZnJvbVBhdGhSZWdleCA9IC9eKC4rKVxcMCguKykkLztcblxuZXhwb3J0IGNsYXNzIEZpbGVTdGF0dXNTdW1tYXJ5IGltcGxlbWVudHMgRmlsZVN0YXR1c1Jlc3VsdCB7XG4gICBwdWJsaWMgcmVhZG9ubHkgZnJvbTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4gICBjb25zdHJ1Y3RvcihcbiAgICAgIHB1YmxpYyBwYXRoOiBzdHJpbmcsXG4gICAgICBwdWJsaWMgaW5kZXg6IHN0cmluZyxcbiAgICAgIHB1YmxpYyB3b3JraW5nX2Rpcjogc3RyaW5nXG4gICApIHtcbiAgICAgIGlmIChpbmRleCA9PT0gJ1InIHx8IHdvcmtpbmdfZGlyID09PSAnUicpIHtcbiAgICAgICAgIGNvbnN0IGRldGFpbCA9IGZyb21QYXRoUmVnZXguZXhlYyhwYXRoKSB8fCBbbnVsbCwgcGF0aCwgcGF0aF07XG4gICAgICAgICB0aGlzLmZyb20gPSBkZXRhaWxbMl0gfHwgJyc7XG4gICAgICAgICB0aGlzLnBhdGggPSBkZXRhaWxbMV0gfHwgJyc7XG4gICAgICB9XG4gICB9XG59XG4iLCAiaW1wb3J0IHsgU3RhdHVzUmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBhcHBlbmQsIE5VTEwgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBGaWxlU3RhdHVzU3VtbWFyeSB9IGZyb20gJy4vRmlsZVN0YXR1c1N1bW1hcnknO1xuXG50eXBlIFN0YXR1c0xpbmVQYXJzZXIgPSAocmVzdWx0OiBTdGF0dXNSZXN1bHQsIGZpbGU6IHN0cmluZykgPT4gdm9pZDtcblxuZXhwb3J0IGNsYXNzIFN0YXR1c1N1bW1hcnkgaW1wbGVtZW50cyBTdGF0dXNSZXN1bHQge1xuICAgcHVibGljIG5vdF9hZGRlZCA9IFtdO1xuICAgcHVibGljIGNvbmZsaWN0ZWQgPSBbXTtcbiAgIHB1YmxpYyBjcmVhdGVkID0gW107XG4gICBwdWJsaWMgZGVsZXRlZCA9IFtdO1xuICAgcHVibGljIGlnbm9yZWQgPSB1bmRlZmluZWQ7XG4gICBwdWJsaWMgbW9kaWZpZWQgPSBbXTtcbiAgIHB1YmxpYyByZW5hbWVkID0gW107XG4gICBwdWJsaWMgZmlsZXMgPSBbXTtcbiAgIHB1YmxpYyBzdGFnZWQgPSBbXTtcbiAgIHB1YmxpYyBhaGVhZCA9IDA7XG4gICBwdWJsaWMgYmVoaW5kID0gMDtcbiAgIHB1YmxpYyBjdXJyZW50ID0gbnVsbDtcbiAgIHB1YmxpYyB0cmFja2luZyA9IG51bGw7XG4gICBwdWJsaWMgZGV0YWNoZWQgPSBmYWxzZTtcblxuICAgcHVibGljIGlzQ2xlYW4gPSAoKSA9PiB7XG4gICAgICByZXR1cm4gIXRoaXMuZmlsZXMubGVuZ3RoO1xuICAgfTtcbn1cblxuZW51bSBQb3JjZWxhaW5GaWxlU3RhdHVzIHtcbiAgIEFEREVEID0gJ0EnLFxuICAgREVMRVRFRCA9ICdEJyxcbiAgIE1PRElGSUVEID0gJ00nLFxuICAgUkVOQU1FRCA9ICdSJyxcbiAgIENPUElFRCA9ICdDJyxcbiAgIFVOTUVSR0VEID0gJ1UnLFxuICAgVU5UUkFDS0VEID0gJz8nLFxuICAgSUdOT1JFRCA9ICchJyxcbiAgIE5PTkUgPSAnICcsXG59XG5cbmZ1bmN0aW9uIHJlbmFtZWRGaWxlKGxpbmU6IHN0cmluZykge1xuICAgY29uc3QgW3RvLCBmcm9tXSA9IGxpbmUuc3BsaXQoTlVMTCk7XG5cbiAgIHJldHVybiB7XG4gICAgICBmcm9tOiBmcm9tIHx8IHRvLFxuICAgICAgdG8sXG4gICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZXIoXG4gICBpbmRleFg6IFBvcmNlbGFpbkZpbGVTdGF0dXMsXG4gICBpbmRleFk6IFBvcmNlbGFpbkZpbGVTdGF0dXMsXG4gICBoYW5kbGVyOiBTdGF0dXNMaW5lUGFyc2VyXG4pOiBbc3RyaW5nLCBTdGF0dXNMaW5lUGFyc2VyXSB7XG4gICByZXR1cm4gW2Ake2luZGV4WH0ke2luZGV4WX1gLCBoYW5kbGVyXTtcbn1cblxuZnVuY3Rpb24gY29uZmxpY3RzKGluZGV4WDogUG9yY2VsYWluRmlsZVN0YXR1cywgLi4uaW5kZXhZOiBQb3JjZWxhaW5GaWxlU3RhdHVzW10pIHtcbiAgIHJldHVybiBpbmRleFkubWFwKCh5KSA9PiBwYXJzZXIoaW5kZXhYLCB5LCAocmVzdWx0LCBmaWxlKSA9PiBhcHBlbmQocmVzdWx0LmNvbmZsaWN0ZWQsIGZpbGUpKSk7XG59XG5cbmNvbnN0IHBhcnNlcnM6IE1hcDxzdHJpbmcsIFN0YXR1c0xpbmVQYXJzZXI+ID0gbmV3IE1hcChbXG4gICBwYXJzZXIoUG9yY2VsYWluRmlsZVN0YXR1cy5OT05FLCBQb3JjZWxhaW5GaWxlU3RhdHVzLkFEREVELCAocmVzdWx0LCBmaWxlKSA9PlxuICAgICAgYXBwZW5kKHJlc3VsdC5jcmVhdGVkLCBmaWxlKVxuICAgKSxcbiAgIHBhcnNlcihQb3JjZWxhaW5GaWxlU3RhdHVzLk5PTkUsIFBvcmNlbGFpbkZpbGVTdGF0dXMuREVMRVRFRCwgKHJlc3VsdCwgZmlsZSkgPT5cbiAgICAgIGFwcGVuZChyZXN1bHQuZGVsZXRlZCwgZmlsZSlcbiAgICksXG4gICBwYXJzZXIoUG9yY2VsYWluRmlsZVN0YXR1cy5OT05FLCBQb3JjZWxhaW5GaWxlU3RhdHVzLk1PRElGSUVELCAocmVzdWx0LCBmaWxlKSA9PlxuICAgICAgYXBwZW5kKHJlc3VsdC5tb2RpZmllZCwgZmlsZSlcbiAgICksXG5cbiAgIHBhcnNlcihcbiAgICAgIFBvcmNlbGFpbkZpbGVTdGF0dXMuQURERUQsXG4gICAgICBQb3JjZWxhaW5GaWxlU3RhdHVzLk5PTkUsXG4gICAgICAocmVzdWx0LCBmaWxlKSA9PiBhcHBlbmQocmVzdWx0LmNyZWF0ZWQsIGZpbGUpICYmIGFwcGVuZChyZXN1bHQuc3RhZ2VkLCBmaWxlKVxuICAgKSxcbiAgIHBhcnNlcihcbiAgICAgIFBvcmNlbGFpbkZpbGVTdGF0dXMuQURERUQsXG4gICAgICBQb3JjZWxhaW5GaWxlU3RhdHVzLk1PRElGSUVELFxuICAgICAgKHJlc3VsdCwgZmlsZSkgPT5cbiAgICAgICAgIGFwcGVuZChyZXN1bHQuY3JlYXRlZCwgZmlsZSkgJiZcbiAgICAgICAgIGFwcGVuZChyZXN1bHQuc3RhZ2VkLCBmaWxlKSAmJlxuICAgICAgICAgYXBwZW5kKHJlc3VsdC5tb2RpZmllZCwgZmlsZSlcbiAgICksXG5cbiAgIHBhcnNlcihcbiAgICAgIFBvcmNlbGFpbkZpbGVTdGF0dXMuREVMRVRFRCxcbiAgICAgIFBvcmNlbGFpbkZpbGVTdGF0dXMuTk9ORSxcbiAgICAgIChyZXN1bHQsIGZpbGUpID0+IGFwcGVuZChyZXN1bHQuZGVsZXRlZCwgZmlsZSkgJiYgYXBwZW5kKHJlc3VsdC5zdGFnZWQsIGZpbGUpXG4gICApLFxuXG4gICBwYXJzZXIoXG4gICAgICBQb3JjZWxhaW5GaWxlU3RhdHVzLk1PRElGSUVELFxuICAgICAgUG9yY2VsYWluRmlsZVN0YXR1cy5OT05FLFxuICAgICAgKHJlc3VsdCwgZmlsZSkgPT4gYXBwZW5kKHJlc3VsdC5tb2RpZmllZCwgZmlsZSkgJiYgYXBwZW5kKHJlc3VsdC5zdGFnZWQsIGZpbGUpXG4gICApLFxuICAgcGFyc2VyKFxuICAgICAgUG9yY2VsYWluRmlsZVN0YXR1cy5NT0RJRklFRCxcbiAgICAgIFBvcmNlbGFpbkZpbGVTdGF0dXMuTU9ESUZJRUQsXG4gICAgICAocmVzdWx0LCBmaWxlKSA9PiBhcHBlbmQocmVzdWx0Lm1vZGlmaWVkLCBmaWxlKSAmJiBhcHBlbmQocmVzdWx0LnN0YWdlZCwgZmlsZSlcbiAgICksXG5cbiAgIHBhcnNlcihQb3JjZWxhaW5GaWxlU3RhdHVzLlJFTkFNRUQsIFBvcmNlbGFpbkZpbGVTdGF0dXMuTk9ORSwgKHJlc3VsdCwgZmlsZSkgPT4ge1xuICAgICAgYXBwZW5kKHJlc3VsdC5yZW5hbWVkLCByZW5hbWVkRmlsZShmaWxlKSk7XG4gICB9KSxcbiAgIHBhcnNlcihQb3JjZWxhaW5GaWxlU3RhdHVzLlJFTkFNRUQsIFBvcmNlbGFpbkZpbGVTdGF0dXMuTU9ESUZJRUQsIChyZXN1bHQsIGZpbGUpID0+IHtcbiAgICAgIGNvbnN0IHJlbmFtZWQgPSByZW5hbWVkRmlsZShmaWxlKTtcbiAgICAgIGFwcGVuZChyZXN1bHQucmVuYW1lZCwgcmVuYW1lZCk7XG4gICAgICBhcHBlbmQocmVzdWx0Lm1vZGlmaWVkLCByZW5hbWVkLnRvKTtcbiAgIH0pLFxuICAgcGFyc2VyKFBvcmNlbGFpbkZpbGVTdGF0dXMuSUdOT1JFRCwgUG9yY2VsYWluRmlsZVN0YXR1cy5JR05PUkVELCAoX3Jlc3VsdCwgX2ZpbGUpID0+IHtcbiAgICAgIGFwcGVuZCgoX3Jlc3VsdC5pZ25vcmVkID0gX3Jlc3VsdC5pZ25vcmVkIHx8IFtdKSwgX2ZpbGUpO1xuICAgfSksXG5cbiAgIHBhcnNlcihQb3JjZWxhaW5GaWxlU3RhdHVzLlVOVFJBQ0tFRCwgUG9yY2VsYWluRmlsZVN0YXR1cy5VTlRSQUNLRUQsIChyZXN1bHQsIGZpbGUpID0+XG4gICAgICBhcHBlbmQocmVzdWx0Lm5vdF9hZGRlZCwgZmlsZSlcbiAgICksXG5cbiAgIC4uLmNvbmZsaWN0cyhQb3JjZWxhaW5GaWxlU3RhdHVzLkFEREVELCBQb3JjZWxhaW5GaWxlU3RhdHVzLkFEREVELCBQb3JjZWxhaW5GaWxlU3RhdHVzLlVOTUVSR0VEKSxcbiAgIC4uLmNvbmZsaWN0cyhcbiAgICAgIFBvcmNlbGFpbkZpbGVTdGF0dXMuREVMRVRFRCxcbiAgICAgIFBvcmNlbGFpbkZpbGVTdGF0dXMuREVMRVRFRCxcbiAgICAgIFBvcmNlbGFpbkZpbGVTdGF0dXMuVU5NRVJHRURcbiAgICksXG4gICAuLi5jb25mbGljdHMoXG4gICAgICBQb3JjZWxhaW5GaWxlU3RhdHVzLlVOTUVSR0VELFxuICAgICAgUG9yY2VsYWluRmlsZVN0YXR1cy5BRERFRCxcbiAgICAgIFBvcmNlbGFpbkZpbGVTdGF0dXMuREVMRVRFRCxcbiAgICAgIFBvcmNlbGFpbkZpbGVTdGF0dXMuVU5NRVJHRURcbiAgICksXG5cbiAgIFtcbiAgICAgICcjIycsXG4gICAgICAocmVzdWx0LCBsaW5lKSA9PiB7XG4gICAgICAgICBjb25zdCBhaGVhZFJlZyA9IC9haGVhZCAoXFxkKykvO1xuICAgICAgICAgY29uc3QgYmVoaW5kUmVnID0gL2JlaGluZCAoXFxkKykvO1xuICAgICAgICAgY29uc3QgY3VycmVudFJlZyA9IC9eKC4rPyg/PSg/OlxcLnszfXxcXHN8JCkpKS87XG4gICAgICAgICBjb25zdCB0cmFja2luZ1JlZyA9IC9cXC57M30oXFxTKikvO1xuICAgICAgICAgY29uc3Qgb25FbXB0eUJyYW5jaFJlZyA9IC9cXHNvblxccyhbXFxTXSspJC87XG4gICAgICAgICBsZXQgcmVnZXhSZXN1bHQ7XG5cbiAgICAgICAgIHJlZ2V4UmVzdWx0ID0gYWhlYWRSZWcuZXhlYyhsaW5lKTtcbiAgICAgICAgIHJlc3VsdC5haGVhZCA9IChyZWdleFJlc3VsdCAmJiArcmVnZXhSZXN1bHRbMV0pIHx8IDA7XG5cbiAgICAgICAgIHJlZ2V4UmVzdWx0ID0gYmVoaW5kUmVnLmV4ZWMobGluZSk7XG4gICAgICAgICByZXN1bHQuYmVoaW5kID0gKHJlZ2V4UmVzdWx0ICYmICtyZWdleFJlc3VsdFsxXSkgfHwgMDtcblxuICAgICAgICAgcmVnZXhSZXN1bHQgPSBjdXJyZW50UmVnLmV4ZWMobGluZSk7XG4gICAgICAgICByZXN1bHQuY3VycmVudCA9IHJlZ2V4UmVzdWx0ICYmIHJlZ2V4UmVzdWx0WzFdO1xuXG4gICAgICAgICByZWdleFJlc3VsdCA9IHRyYWNraW5nUmVnLmV4ZWMobGluZSk7XG4gICAgICAgICByZXN1bHQudHJhY2tpbmcgPSByZWdleFJlc3VsdCAmJiByZWdleFJlc3VsdFsxXTtcblxuICAgICAgICAgcmVnZXhSZXN1bHQgPSBvbkVtcHR5QnJhbmNoUmVnLmV4ZWMobGluZSk7XG4gICAgICAgICByZXN1bHQuY3VycmVudCA9IChyZWdleFJlc3VsdCAmJiByZWdleFJlc3VsdFsxXSkgfHwgcmVzdWx0LmN1cnJlbnQ7XG5cbiAgICAgICAgIHJlc3VsdC5kZXRhY2hlZCA9IC9cXChubyBicmFuY2hcXCkvLnRlc3QobGluZSk7XG4gICAgICB9LFxuICAgXSxcbl0pO1xuXG5leHBvcnQgY29uc3QgcGFyc2VTdGF0dXNTdW1tYXJ5ID0gZnVuY3Rpb24gKHRleHQ6IHN0cmluZyk6IFN0YXR1c1Jlc3VsdCB7XG4gICBjb25zdCBsaW5lcyA9IHRleHQuc3BsaXQoTlVMTCk7XG4gICBjb25zdCBzdGF0dXMgPSBuZXcgU3RhdHVzU3VtbWFyeSgpO1xuXG4gICBmb3IgKGxldCBpID0gMCwgbCA9IGxpbmVzLmxlbmd0aDsgaSA8IGw7ICkge1xuICAgICAgbGV0IGxpbmUgPSBsaW5lc1tpKytdLnRyaW0oKTtcblxuICAgICAgaWYgKCFsaW5lKSB7XG4gICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxpbmUuY2hhckF0KDApID09PSBQb3JjZWxhaW5GaWxlU3RhdHVzLlJFTkFNRUQpIHtcbiAgICAgICAgIGxpbmUgKz0gTlVMTCArIChsaW5lc1tpKytdIHx8ICcnKTtcbiAgICAgIH1cblxuICAgICAgc3BsaXRMaW5lKHN0YXR1cywgbGluZSk7XG4gICB9XG5cbiAgIHJldHVybiBzdGF0dXM7XG59O1xuXG5mdW5jdGlvbiBzcGxpdExpbmUocmVzdWx0OiBTdGF0dXNSZXN1bHQsIGxpbmVTdHI6IHN0cmluZykge1xuICAgY29uc3QgdHJpbW1lZCA9IGxpbmVTdHIudHJpbSgpO1xuICAgc3dpdGNoICgnICcpIHtcbiAgICAgIGNhc2UgdHJpbW1lZC5jaGFyQXQoMik6XG4gICAgICAgICByZXR1cm4gZGF0YSh0cmltbWVkLmNoYXJBdCgwKSwgdHJpbW1lZC5jaGFyQXQoMSksIHRyaW1tZWQuc3Vic3RyKDMpKTtcbiAgICAgIGNhc2UgdHJpbW1lZC5jaGFyQXQoMSk6XG4gICAgICAgICByZXR1cm4gZGF0YShQb3JjZWxhaW5GaWxlU3RhdHVzLk5PTkUsIHRyaW1tZWQuY2hhckF0KDApLCB0cmltbWVkLnN1YnN0cigyKSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAgcmV0dXJuO1xuICAgfVxuXG4gICBmdW5jdGlvbiBkYXRhKGluZGV4OiBzdHJpbmcsIHdvcmtpbmdEaXI6IHN0cmluZywgcGF0aDogc3RyaW5nKSB7XG4gICAgICBjb25zdCByYXcgPSBgJHtpbmRleH0ke3dvcmtpbmdEaXJ9YDtcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSBwYXJzZXJzLmdldChyYXcpO1xuXG4gICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgaGFuZGxlcihyZXN1bHQsIHBhdGgpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmF3ICE9PSAnIyMnICYmIHJhdyAhPT0gJyEhJykge1xuICAgICAgICAgcmVzdWx0LmZpbGVzLnB1c2gobmV3IEZpbGVTdGF0dXNTdW1tYXJ5KHBhdGgsIGluZGV4LCB3b3JraW5nRGlyKSk7XG4gICAgICB9XG4gICB9XG59XG4iLCAiaW1wb3J0IHsgU3RhdHVzUmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBwYXJzZVN0YXR1c1N1bW1hcnkgfSBmcm9tICcuLi9yZXNwb25zZXMvU3RhdHVzU3VtbWFyeSc7XG5pbXBvcnQgeyBTdHJpbmdUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5jb25zdCBpZ25vcmVkT3B0aW9ucyA9IFsnLS1udWxsJywgJy16J107XG5cbmV4cG9ydCBmdW5jdGlvbiBzdGF0dXNUYXNrKGN1c3RvbUFyZ3M6IHN0cmluZ1tdKTogU3RyaW5nVGFzazxTdGF0dXNSZXN1bHQ+IHtcbiAgIGNvbnN0IGNvbW1hbmRzID0gW1xuICAgICAgJ3N0YXR1cycsXG4gICAgICAnLS1wb3JjZWxhaW4nLFxuICAgICAgJy1iJyxcbiAgICAgICctdScsXG4gICAgICAnLS1udWxsJyxcbiAgICAgIC4uLmN1c3RvbUFyZ3MuZmlsdGVyKChhcmcpID0+ICFpZ25vcmVkT3B0aW9ucy5pbmNsdWRlcyhhcmcpKSxcbiAgIF07XG5cbiAgIHJldHVybiB7XG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBjb21tYW5kcyxcbiAgICAgIHBhcnNlcih0ZXh0OiBzdHJpbmcpIHtcbiAgICAgICAgIHJldHVybiBwYXJzZVN0YXR1c1N1bW1hcnkodGV4dCk7XG4gICAgICB9LFxuICAgfTtcbn1cbiIsICJpbXBvcnQgdHlwZSB7IFNpbXBsZUdpdEFwaSB9IGZyb20gJy4uL3NpbXBsZS1naXQtYXBpJztcbmltcG9ydCB0eXBlIHsgU2ltcGxlR2l0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBhc051bWJlciwgRXhpdENvZGVzLCBMaW5lUGFyc2VyLCBwYXJzZVN0cmluZ1Jlc3BvbnNlIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFZlcnNpb25SZXN1bHQge1xuICAgbWFqb3I6IG51bWJlcjtcbiAgIG1pbm9yOiBudW1iZXI7XG4gICBwYXRjaDogbnVtYmVyIHwgc3RyaW5nO1xuICAgYWdlbnQ6IHN0cmluZztcbiAgIGluc3RhbGxlZDogYm9vbGVhbjtcbn1cblxuY29uc3QgTk9UX0lOU1RBTExFRCA9ICdpbnN0YWxsZWQ9ZmFsc2UnO1xuXG5mdW5jdGlvbiB2ZXJzaW9uUmVzcG9uc2UoXG4gICBtYWpvciA9IDAsXG4gICBtaW5vciA9IDAsXG4gICBwYXRjaDogc3RyaW5nIHwgbnVtYmVyID0gMCxcbiAgIGFnZW50ID0gJycsXG4gICBpbnN0YWxsZWQgPSB0cnVlXG4pOiBWZXJzaW9uUmVzdWx0IHtcbiAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoXG4gICAgICB7XG4gICAgICAgICBtYWpvcixcbiAgICAgICAgIG1pbm9yLFxuICAgICAgICAgcGF0Y2gsXG4gICAgICAgICBhZ2VudCxcbiAgICAgICAgIGluc3RhbGxlZCxcbiAgICAgIH0sXG4gICAgICAndG9TdHJpbmcnLFxuICAgICAge1xuICAgICAgICAgdmFsdWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5tYWpvcn0uJHt0aGlzLm1pbm9yfS4ke3RoaXMucGF0Y2h9YDtcbiAgICAgICAgIH0sXG4gICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB9XG4gICApO1xufVxuXG5mdW5jdGlvbiBub3RJbnN0YWxsZWRSZXNwb25zZSgpIHtcbiAgIHJldHVybiB2ZXJzaW9uUmVzcG9uc2UoMCwgMCwgMCwgJycsIGZhbHNlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCk6IFBpY2s8U2ltcGxlR2l0LCAndmVyc2lvbic+IHtcbiAgIHJldHVybiB7XG4gICAgICB2ZXJzaW9uKHRoaXM6IFNpbXBsZUdpdEFwaSkge1xuICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soe1xuICAgICAgICAgICAgY29tbWFuZHM6IFsnLS12ZXJzaW9uJ10sXG4gICAgICAgICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICAgICAgICBwYXJzZXI6IHZlcnNpb25QYXJzZXIsXG4gICAgICAgICAgICBvbkVycm9yKHJlc3VsdCwgZXJyb3IsIGRvbmUsIGZhaWwpIHtcbiAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZXhpdENvZGUgPT09IEV4aXRDb2Rlcy5OT1RfRk9VTkQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBkb25lKEJ1ZmZlci5mcm9tKE5PVF9JTlNUQUxMRUQpKTtcbiAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgZmFpbChlcnJvcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgfSk7XG4gICAgICB9LFxuICAgfTtcbn1cblxuY29uc3QgcGFyc2VyczogTGluZVBhcnNlcjxWZXJzaW9uUmVzdWx0PltdID0gW1xuICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAvdmVyc2lvbiAoXFxkKylcXC4oXFxkKylcXC4oXFxkKykoPzpcXHMqXFwoKC4rKVxcKSk/LyxcbiAgICAgIChyZXN1bHQsIFttYWpvciwgbWlub3IsIHBhdGNoLCBhZ2VudCA9ICcnXSkgPT4ge1xuICAgICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICAgIHZlcnNpb25SZXNwb25zZShhc051bWJlcihtYWpvciksIGFzTnVtYmVyKG1pbm9yKSwgYXNOdW1iZXIocGF0Y2gpLCBhZ2VudClcbiAgICAgICAgICk7XG4gICAgICB9XG4gICApLFxuICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAvdmVyc2lvbiAoXFxkKylcXC4oXFxkKylcXC4oXFxEKykoLispPyQvLFxuICAgICAgKHJlc3VsdCwgW21ham9yLCBtaW5vciwgcGF0Y2gsIGFnZW50ID0gJyddKSA9PiB7XG4gICAgICAgICBPYmplY3QuYXNzaWduKHJlc3VsdCwgdmVyc2lvblJlc3BvbnNlKGFzTnVtYmVyKG1ham9yKSwgYXNOdW1iZXIobWlub3IpLCBwYXRjaCwgYWdlbnQpKTtcbiAgICAgIH1cbiAgICksXG5dO1xuXG5mdW5jdGlvbiB2ZXJzaW9uUGFyc2VyKHN0ZE91dDogc3RyaW5nKSB7XG4gICBpZiAoc3RkT3V0ID09PSBOT1RfSU5TVEFMTEVEKSB7XG4gICAgICByZXR1cm4gbm90SW5zdGFsbGVkUmVzcG9uc2UoKTtcbiAgIH1cblxuICAgcmV0dXJuIHBhcnNlU3RyaW5nUmVzcG9uc2UodmVyc2lvblJlc3BvbnNlKDAsIDAsIDAsIHN0ZE91dCksIHBhcnNlcnMsIHN0ZE91dCk7XG59XG4iLCAiaW1wb3J0IHsgU2ltcGxlR2l0QmFzZSB9IGZyb20gJy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgdGFza0NhbGxiYWNrIH0gZnJvbSAnLi90YXNrLWNhbGxiYWNrJztcbmltcG9ydCB7IGNoYW5nZVdvcmtpbmdEaXJlY3RvcnlUYXNrIH0gZnJvbSAnLi90YXNrcy9jaGFuZ2Utd29ya2luZy1kaXJlY3RvcnknO1xuaW1wb3J0IGNoZWNrb3V0IGZyb20gJy4vdGFza3MvY2hlY2tvdXQnO1xuaW1wb3J0IGNvdW50T2JqZWN0cyBmcm9tICcuL3Rhc2tzL2NvdW50LW9iamVjdHMnO1xuaW1wb3J0IGNvbW1pdCBmcm9tICcuL3Rhc2tzL2NvbW1pdCc7XG5pbXBvcnQgY29uZmlnIGZyb20gJy4vdGFza3MvY29uZmlnJztcbmltcG9ydCBmaXJzdENvbW1pdCBmcm9tICcuL3Rhc2tzL2ZpcnN0LWNvbW1pdCc7XG5pbXBvcnQgZ3JlcCBmcm9tICcuL3Rhc2tzL2dyZXAnO1xuaW1wb3J0IHsgaGFzaE9iamVjdFRhc2sgfSBmcm9tICcuL3Rhc2tzL2hhc2gtb2JqZWN0JztcbmltcG9ydCB7IGluaXRUYXNrIH0gZnJvbSAnLi90YXNrcy9pbml0JztcbmltcG9ydCBsb2cgZnJvbSAnLi90YXNrcy9sb2cnO1xuaW1wb3J0IHsgbWVyZ2VUYXNrIH0gZnJvbSAnLi90YXNrcy9tZXJnZSc7XG5pbXBvcnQgeyBwdXNoVGFzayB9IGZyb20gJy4vdGFza3MvcHVzaCc7XG5pbXBvcnQgc2hvdyBmcm9tICcuL3Rhc2tzL3Nob3cnO1xuaW1wb3J0IHsgc3RhdHVzVGFzayB9IGZyb20gJy4vdGFza3Mvc3RhdHVzJztcbmltcG9ydCB7IGNvbmZpZ3VyYXRpb25FcnJvclRhc2ssIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2sgfSBmcm9tICcuL3Rhc2tzL3Rhc2snO1xuaW1wb3J0IHZlcnNpb24gZnJvbSAnLi90YXNrcy92ZXJzaW9uJztcbmltcG9ydCB7IG91dHB1dEhhbmRsZXIsIFNpbXBsZUdpdEV4ZWN1dG9yLCBTaW1wbGVHaXRUYXNrLCBTaW1wbGVHaXRUYXNrQ2FsbGJhY2sgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7XG4gICBhc0FycmF5LFxuICAgZmlsdGVyU3RyaW5nLFxuICAgZmlsdGVyVHlwZSxcbiAgIGdldFRyYWlsaW5nT3B0aW9ucyxcbiAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudCxcbn0gZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBjbGFzcyBTaW1wbGVHaXRBcGkgaW1wbGVtZW50cyBTaW1wbGVHaXRCYXNlIHtcbiAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2V4ZWN1dG9yOiBTaW1wbGVHaXRFeGVjdXRvcikge31cblxuICAgcHJvdGVjdGVkIF9ydW5UYXNrPFQ+KHRhc2s6IFNpbXBsZUdpdFRhc2s8VD4sIHRoZW4/OiBTaW1wbGVHaXRUYXNrQ2FsbGJhY2s8VD4pIHtcbiAgICAgIGNvbnN0IGNoYWluID0gdGhpcy5fZXhlY3V0b3IuY2hhaW4oKTtcbiAgICAgIGNvbnN0IHByb21pc2UgPSBjaGFpbi5wdXNoKHRhc2spO1xuXG4gICAgICBpZiAodGhlbikge1xuICAgICAgICAgdGFza0NhbGxiYWNrKHRhc2ssIHByb21pc2UsIHRoZW4pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZSh0aGlzLCB7XG4gICAgICAgICB0aGVuOiB7IHZhbHVlOiBwcm9taXNlLnRoZW4uYmluZChwcm9taXNlKSB9LFxuICAgICAgICAgY2F0Y2g6IHsgdmFsdWU6IHByb21pc2UuY2F0Y2guYmluZChwcm9taXNlKSB9LFxuICAgICAgICAgX2V4ZWN1dG9yOiB7IHZhbHVlOiBjaGFpbiB9LFxuICAgICAgfSk7XG4gICB9XG5cbiAgIGFkZChmaWxlczogc3RyaW5nIHwgc3RyaW5nW10pIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICAgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhbJ2FkZCcsIC4uLmFzQXJyYXkoZmlsZXMpXSksXG4gICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgIH1cblxuICAgY3dkKGRpcmVjdG9yeTogc3RyaW5nIHwgeyBwYXRoOiBzdHJpbmc7IHJvb3Q/OiBib29sZWFuIH0pIHtcbiAgICAgIGNvbnN0IG5leHQgPSB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKTtcblxuICAgICAgaWYgKHR5cGVvZiBkaXJlY3RvcnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhjaGFuZ2VXb3JraW5nRGlyZWN0b3J5VGFzayhkaXJlY3RvcnksIHRoaXMuX2V4ZWN1dG9yKSwgbmV4dCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZGlyZWN0b3J5Py5wYXRoID09PSAnc3RyaW5nJykge1xuICAgICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICAgICBjaGFuZ2VXb3JraW5nRGlyZWN0b3J5VGFzayhcbiAgICAgICAgICAgICAgIGRpcmVjdG9yeS5wYXRoLFxuICAgICAgICAgICAgICAgKGRpcmVjdG9yeS5yb290ICYmIHRoaXMuX2V4ZWN1dG9yKSB8fCB1bmRlZmluZWRcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBuZXh0XG4gICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgIGNvbmZpZ3VyYXRpb25FcnJvclRhc2soJ0dpdC5jd2Q6IHdvcmtpbmdEaXJlY3RvcnkgbXVzdCBiZSBzdXBwbGllZCBhcyBhIHN0cmluZycpLFxuICAgICAgICAgbmV4dFxuICAgICAgKTtcbiAgIH1cblxuICAgaGFzaE9iamVjdChwYXRoOiBzdHJpbmcsIHdyaXRlOiBib29sZWFuIHwgdW5rbm93bikge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICBoYXNoT2JqZWN0VGFzayhwYXRoLCB3cml0ZSA9PT0gdHJ1ZSksXG4gICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgIH1cblxuICAgaW5pdChiYXJlPzogYm9vbGVhbiB8IHVua25vd24pIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICAgaW5pdFRhc2soYmFyZSA9PT0gdHJ1ZSwgdGhpcy5fZXhlY3V0b3IuY3dkLCBnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKSksXG4gICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgIH1cblxuICAgbWVyZ2UoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgIG1lcmdlVGFzayhnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKSksXG4gICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgIH1cblxuICAgbWVyZ2VGcm9tVG8ocmVtb3RlOiBzdHJpbmcsIGJyYW5jaDogc3RyaW5nKSB7XG4gICAgICBpZiAoIShmaWx0ZXJTdHJpbmcocmVtb3RlKSAmJiBmaWx0ZXJTdHJpbmcoYnJhbmNoKSkpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICAgICAgY29uZmlndXJhdGlvbkVycm9yVGFzayhcbiAgICAgICAgICAgICAgIGBHaXQubWVyZ2VGcm9tVG8gcmVxdWlyZXMgdGhhdCB0aGUgJ3JlbW90ZScgYW5kICdicmFuY2gnIGFyZ3VtZW50cyBhcmUgc3VwcGxpZWQgYXMgc3RyaW5nc2BcbiAgICAgICAgICAgIClcbiAgICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICAgbWVyZ2VUYXNrKFtyZW1vdGUsIGJyYW5jaCwgLi4uZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cyldKSxcbiAgICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMsIGZhbHNlKVxuICAgICAgKTtcbiAgIH1cblxuICAgb3V0cHV0SGFuZGxlcihoYW5kbGVyOiBvdXRwdXRIYW5kbGVyKSB7XG4gICAgICB0aGlzLl9leGVjdXRvci5vdXRwdXRIYW5kbGVyID0gaGFuZGxlcjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgfVxuXG4gICBwdXNoKCkge1xuICAgICAgY29uc3QgdGFzayA9IHB1c2hUYXNrKFxuICAgICAgICAge1xuICAgICAgICAgICAgcmVtb3RlOiBmaWx0ZXJUeXBlKGFyZ3VtZW50c1swXSwgZmlsdGVyU3RyaW5nKSxcbiAgICAgICAgICAgIGJyYW5jaDogZmlsdGVyVHlwZShhcmd1bWVudHNbMV0sIGZpbHRlclN0cmluZyksXG4gICAgICAgICB9LFxuICAgICAgICAgZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cylcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKHRhc2ssIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpKTtcbiAgIH1cblxuICAgc3Rhc2goKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgICAgIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soWydzdGFzaCcsIC4uLmdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpXSksXG4gICAgICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgICAgKTtcbiAgIH1cblxuICAgc3RhdHVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICAgICBzdGF0dXNUYXNrKGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpKSxcbiAgICAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICAgICApO1xuICAgfVxufVxuXG5PYmplY3QuYXNzaWduKFxuICAgU2ltcGxlR2l0QXBpLnByb3RvdHlwZSxcbiAgIGNoZWNrb3V0KCksXG4gICBjb21taXQoKSxcbiAgIGNvbmZpZygpLFxuICAgY291bnRPYmplY3RzKCksXG4gICBmaXJzdENvbW1pdCgpLFxuICAgZ3JlcCgpLFxuICAgbG9nKCksXG4gICBzaG93KCksXG4gICB2ZXJzaW9uKClcbik7XG4iLCAiaW1wb3J0IHsgYXBwZW5kLCByZW1vdmUgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBjcmVhdGVEZWZlcnJlZCwgRGVmZXJyZWRQcm9taXNlIH0gZnJvbSAnQGt3c2l0ZXMvcHJvbWlzZS1kZWZlcnJlZCc7XG5pbXBvcnQgeyBjcmVhdGVMb2dnZXIgfSBmcm9tICcuLi9naXQtbG9nZ2VyJztcblxudHlwZSBTY2hlZHVsZUNvbXBsZXRlQ2FsbGJhY2sgPSAoKSA9PiB2b2lkO1xudHlwZSBTY2hlZHVsZWRUYXNrID0gUGljazxEZWZlcnJlZFByb21pc2U8U2NoZWR1bGVDb21wbGV0ZUNhbGxiYWNrPiwgJ3Byb21pc2UnIHwgJ2RvbmUnPiAmIHtcbiAgIGlkOiBudW1iZXI7XG59O1xuXG5jb25zdCBjcmVhdGVTY2hlZHVsZWRUYXNrOiAoKSA9PiBTY2hlZHVsZWRUYXNrID0gKCgpID0+IHtcbiAgIGxldCBpZCA9IDA7XG4gICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWQrKztcbiAgICAgIGNvbnN0IHsgcHJvbWlzZSwgZG9uZSB9ID0gY3JlYXRlRGVmZXJyZWQ8U2NoZWR1bGVDb21wbGV0ZUNhbGxiYWNrPigpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAgcHJvbWlzZSxcbiAgICAgICAgIGRvbmUsXG4gICAgICAgICBpZCxcbiAgICAgIH07XG4gICB9O1xufSkoKTtcblxuZXhwb3J0IGNsYXNzIFNjaGVkdWxlciB7XG4gICBwcml2YXRlIGxvZ2dlciA9IGNyZWF0ZUxvZ2dlcignJywgJ3NjaGVkdWxlcicpO1xuICAgcHJpdmF0ZSBwZW5kaW5nOiBTY2hlZHVsZWRUYXNrW10gPSBbXTtcbiAgIHByaXZhdGUgcnVubmluZzogU2NoZWR1bGVkVGFza1tdID0gW107XG5cbiAgIGNvbnN0cnVjdG9yKHByaXZhdGUgY29uY3VycmVuY3kgPSAyKSB7XG4gICAgICB0aGlzLmxvZ2dlcihgQ29uc3RydWN0ZWQsIGNvbmN1cnJlbmN5PSVzYCwgY29uY3VycmVuY3kpO1xuICAgfVxuXG4gICBwcml2YXRlIHNjaGVkdWxlKCkge1xuICAgICAgaWYgKCF0aGlzLnBlbmRpbmcubGVuZ3RoIHx8IHRoaXMucnVubmluZy5sZW5ndGggPj0gdGhpcy5jb25jdXJyZW5jeSkge1xuICAgICAgICAgdGhpcy5sb2dnZXIoXG4gICAgICAgICAgICBgU2NoZWR1bGUgYXR0ZW1wdCBpZ25vcmVkLCBwZW5kaW5nPSVzIHJ1bm5pbmc9JXMgY29uY3VycmVuY3k9JXNgLFxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nLmxlbmd0aCxcbiAgICAgICAgICAgIHRoaXMucnVubmluZy5sZW5ndGgsXG4gICAgICAgICAgICB0aGlzLmNvbmN1cnJlbmN5XG4gICAgICAgICApO1xuICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0YXNrID0gYXBwZW5kKHRoaXMucnVubmluZywgdGhpcy5wZW5kaW5nLnNoaWZ0KCkhKTtcbiAgICAgIHRoaXMubG9nZ2VyKGBBdHRlbXB0aW5nIGlkPSVzYCwgdGFzay5pZCk7XG4gICAgICB0YXNrLmRvbmUoKCkgPT4ge1xuICAgICAgICAgdGhpcy5sb2dnZXIoYENvbXBsZXRpbmcgaWQ9YCwgdGFzay5pZCk7XG4gICAgICAgICByZW1vdmUodGhpcy5ydW5uaW5nLCB0YXNrKTtcbiAgICAgICAgIHRoaXMuc2NoZWR1bGUoKTtcbiAgICAgIH0pO1xuICAgfVxuXG4gICBuZXh0KCk6IFByb21pc2U8U2NoZWR1bGVDb21wbGV0ZUNhbGxiYWNrPiB7XG4gICAgICBjb25zdCB7IHByb21pc2UsIGlkIH0gPSBhcHBlbmQodGhpcy5wZW5kaW5nLCBjcmVhdGVTY2hlZHVsZWRUYXNrKCkpO1xuICAgICAgdGhpcy5sb2dnZXIoYFNjaGVkdWxpbmcgaWQ9JXNgLCBpZCk7XG5cbiAgICAgIHRoaXMuc2NoZWR1bGUoKTtcblxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICB9XG59XG4iLCAiaW1wb3J0IHsgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayB9IGZyb20gJy4vdGFzayc7XG5pbXBvcnQgeyBPcHRpb25GbGFncywgT3B0aW9ucywgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IHR5cGUgQXBwbHlPcHRpb25zID0gT3B0aW9ucyAmXG4gICBPcHRpb25GbGFnczxcbiAgICAgIHwgJy0tc3RhdCdcbiAgICAgIHwgJy0tbnVtc3RhdCdcbiAgICAgIHwgJy0tc3VtbWFyeSdcbiAgICAgIHwgJy0tY2hlY2snXG4gICAgICB8ICctLWluZGV4J1xuICAgICAgfCAnLS1pbnRlbnQtdG8tYWRkJ1xuICAgICAgfCAnLS0zd2F5J1xuICAgICAgfCAnLS1hcHBseSdcbiAgICAgIHwgJy0tbm8tYWRkJ1xuICAgICAgfCAnLVInXG4gICAgICB8ICctLXJldmVyc2UnXG4gICAgICB8ICctLWFsbG93LWJpbmFyeS1yZXBsYWNlbWVudCdcbiAgICAgIHwgJy0tYmluYXJ5J1xuICAgICAgfCAnLS1yZWplY3QnXG4gICAgICB8ICcteidcbiAgICAgIHwgJy0taW5hY2N1cmF0ZS1lb2YnXG4gICAgICB8ICctLXJlY291bnQnXG4gICAgICB8ICctLWNhY2hlZCdcbiAgICAgIHwgJy0taWdub3JlLXNwYWNlLWNoYW5nZSdcbiAgICAgIHwgJy0taWdub3JlLXdoaXRlc3BhY2UnXG4gICAgICB8ICctLXZlcmJvc2UnXG4gICAgICB8ICctLXVuc2FmZS1wYXRocydcbiAgID4gJlxuICAgT3B0aW9uRmxhZ3M8Jy0td2hpdGVzcGFjZScsICdub3dhcm4nIHwgJ3dhcm4nIHwgJ2ZpeCcgfCAnZXJyb3InIHwgJ2Vycm9yLWFsbCc+ICZcbiAgIE9wdGlvbkZsYWdzPCctLWJ1aWxkLWZha2UtYW5jZXN0b3InIHwgJy0tZXhjbHVkZScgfCAnLS1pbmNsdWRlJyB8ICctLWRpcmVjdG9yeScsIHN0cmluZz4gJlxuICAgT3B0aW9uRmxhZ3M8Jy1wJyB8ICctQycsIG51bWJlcj47XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVBhdGNoVGFzayhwYXRjaGVzOiBzdHJpbmdbXSwgY3VzdG9tQXJnczogc3RyaW5nW10pOiBTdHJpbmdUYXNrPHN0cmluZz4ge1xuICAgcmV0dXJuIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soWydhcHBseScsIC4uLmN1c3RvbUFyZ3MsIC4uLnBhdGNoZXNdKTtcbn1cbiIsICJpbXBvcnQge1xuICAgQnJhbmNoTXVsdGlEZWxldGVSZXN1bHQsXG4gICBCcmFuY2hTaW5nbGVEZWxldGVGYWlsdXJlLFxuICAgQnJhbmNoU2luZ2xlRGVsZXRlUmVzdWx0LFxuICAgQnJhbmNoU2luZ2xlRGVsZXRlU3VjY2Vzcyxcbn0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5cbmV4cG9ydCBjbGFzcyBCcmFuY2hEZWxldGlvbkJhdGNoIGltcGxlbWVudHMgQnJhbmNoTXVsdGlEZWxldGVSZXN1bHQge1xuICAgYWxsOiBCcmFuY2hTaW5nbGVEZWxldGVSZXN1bHRbXSA9IFtdO1xuICAgYnJhbmNoZXM6IHsgW2JyYW5jaE5hbWU6IHN0cmluZ106IEJyYW5jaFNpbmdsZURlbGV0ZVJlc3VsdCB9ID0ge307XG4gICBlcnJvcnM6IEJyYW5jaFNpbmdsZURlbGV0ZVJlc3VsdFtdID0gW107XG5cbiAgIGdldCBzdWNjZXNzKCk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuICF0aGlzLmVycm9ycy5sZW5ndGg7XG4gICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBicmFuY2hEZWxldGlvblN1Y2Nlc3MoYnJhbmNoOiBzdHJpbmcsIGhhc2g6IHN0cmluZyk6IEJyYW5jaFNpbmdsZURlbGV0ZVN1Y2Nlc3Mge1xuICAgcmV0dXJuIHtcbiAgICAgIGJyYW5jaCxcbiAgICAgIGhhc2gsXG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJyYW5jaERlbGV0aW9uRmFpbHVyZShicmFuY2g6IHN0cmluZyk6IEJyYW5jaFNpbmdsZURlbGV0ZUZhaWx1cmUge1xuICAgcmV0dXJuIHtcbiAgICAgIGJyYW5jaCxcbiAgICAgIGhhc2g6IG51bGwsXG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1NpbmdsZUJyYW5jaERlbGV0ZUZhaWx1cmUoXG4gICB0ZXN0OiBCcmFuY2hTaW5nbGVEZWxldGVSZXN1bHRcbik6IHRlc3QgaXMgQnJhbmNoU2luZ2xlRGVsZXRlU3VjY2VzcyB7XG4gICByZXR1cm4gdGVzdC5zdWNjZXNzO1xufVxuIiwgImltcG9ydCB7IEJyYW5jaE11bHRpRGVsZXRlUmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQge1xuICAgQnJhbmNoRGVsZXRpb25CYXRjaCxcbiAgIGJyYW5jaERlbGV0aW9uRmFpbHVyZSxcbiAgIGJyYW5jaERlbGV0aW9uU3VjY2Vzcyxcbn0gZnJvbSAnLi4vcmVzcG9uc2VzL0JyYW5jaERlbGV0ZVN1bW1hcnknO1xuaW1wb3J0IHsgVGFza1BhcnNlciB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IEV4aXRDb2RlcywgTGluZVBhcnNlciwgcGFyc2VTdHJpbmdSZXNwb25zZSB9IGZyb20gJy4uL3V0aWxzJztcblxuY29uc3QgZGVsZXRlU3VjY2Vzc1JlZ2V4ID0gLyhcXFMrKVxccytcXChcXFMrXFxzKFteKV0rKVxcKS87XG5jb25zdCBkZWxldGVFcnJvclJlZ2V4ID0gL15lcnJvclteJ10rJyhbXiddKyknL207XG5cbmNvbnN0IHBhcnNlcnM6IExpbmVQYXJzZXI8QnJhbmNoTXVsdGlEZWxldGVSZXN1bHQ+W10gPSBbXG4gICBuZXcgTGluZVBhcnNlcihkZWxldGVTdWNjZXNzUmVnZXgsIChyZXN1bHQsIFticmFuY2gsIGhhc2hdKSA9PiB7XG4gICAgICBjb25zdCBkZWxldGlvbiA9IGJyYW5jaERlbGV0aW9uU3VjY2VzcyhicmFuY2gsIGhhc2gpO1xuXG4gICAgICByZXN1bHQuYWxsLnB1c2goZGVsZXRpb24pO1xuICAgICAgcmVzdWx0LmJyYW5jaGVzW2JyYW5jaF0gPSBkZWxldGlvbjtcbiAgIH0pLFxuICAgbmV3IExpbmVQYXJzZXIoZGVsZXRlRXJyb3JSZWdleCwgKHJlc3VsdCwgW2JyYW5jaF0pID0+IHtcbiAgICAgIGNvbnN0IGRlbGV0aW9uID0gYnJhbmNoRGVsZXRpb25GYWlsdXJlKGJyYW5jaCk7XG5cbiAgICAgIHJlc3VsdC5lcnJvcnMucHVzaChkZWxldGlvbik7XG4gICAgICByZXN1bHQuYWxsLnB1c2goZGVsZXRpb24pO1xuICAgICAgcmVzdWx0LmJyYW5jaGVzW2JyYW5jaF0gPSBkZWxldGlvbjtcbiAgIH0pLFxuXTtcblxuZXhwb3J0IGNvbnN0IHBhcnNlQnJhbmNoRGVsZXRpb25zOiBUYXNrUGFyc2VyPHN0cmluZywgQnJhbmNoTXVsdGlEZWxldGVSZXN1bHQ+ID0gKFxuICAgc3RkT3V0LFxuICAgc3RkRXJyXG4pID0+IHtcbiAgIHJldHVybiBwYXJzZVN0cmluZ1Jlc3BvbnNlKG5ldyBCcmFuY2hEZWxldGlvbkJhdGNoKCksIHBhcnNlcnMsIFtzdGRPdXQsIHN0ZEVycl0pO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0JyYW5jaERlbGV0aW9uRXJyb3IoZGF0YTogc3RyaW5nLCBwcm9jZXNzRXhpdENvZGU6IEV4aXRDb2Rlcyk6IGJvb2xlYW4ge1xuICAgcmV0dXJuIHByb2Nlc3NFeGl0Q29kZSA9PT0gRXhpdENvZGVzLkVSUk9SICYmIGRlbGV0ZUVycm9yUmVnZXgudGVzdChkYXRhKTtcbn1cbiIsICJpbXBvcnQgdHlwZSB7IEJyYW5jaFN1bW1hcnksIEJyYW5jaFN1bW1hcnlCcmFuY2ggfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcblxuZXhwb3J0IGVudW0gQnJhbmNoU3RhdHVzSWRlbnRpZmllciB7XG4gICBDVVJSRU5UID0gJyonLFxuICAgTElOS0VEID0gJysnLFxufVxuXG5leHBvcnQgY2xhc3MgQnJhbmNoU3VtbWFyeVJlc3VsdCBpbXBsZW1lbnRzIEJyYW5jaFN1bW1hcnkge1xuICAgcHVibGljIGFsbDogc3RyaW5nW10gPSBbXTtcbiAgIHB1YmxpYyBicmFuY2hlczogeyBbcDogc3RyaW5nXTogQnJhbmNoU3VtbWFyeUJyYW5jaCB9ID0ge307XG4gICBwdWJsaWMgY3VycmVudDogc3RyaW5nID0gJyc7XG4gICBwdWJsaWMgZGV0YWNoZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgcHVzaChcbiAgICAgIHN0YXR1czogQnJhbmNoU3RhdHVzSWRlbnRpZmllciB8IHVua25vd24sXG4gICAgICBkZXRhY2hlZDogYm9vbGVhbixcbiAgICAgIG5hbWU6IHN0cmluZyxcbiAgICAgIGNvbW1pdDogc3RyaW5nLFxuICAgICAgbGFiZWw6IHN0cmluZ1xuICAgKSB7XG4gICAgICBpZiAoc3RhdHVzID09PSBCcmFuY2hTdGF0dXNJZGVudGlmaWVyLkNVUlJFTlQpIHtcbiAgICAgICAgIHRoaXMuZGV0YWNoZWQgPSBkZXRhY2hlZDtcbiAgICAgICAgIHRoaXMuY3VycmVudCA9IG5hbWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYWxsLnB1c2gobmFtZSk7XG4gICAgICB0aGlzLmJyYW5jaGVzW25hbWVdID0ge1xuICAgICAgICAgY3VycmVudDogc3RhdHVzID09PSBCcmFuY2hTdGF0dXNJZGVudGlmaWVyLkNVUlJFTlQsXG4gICAgICAgICBsaW5rZWRXb3JrVHJlZTogc3RhdHVzID09PSBCcmFuY2hTdGF0dXNJZGVudGlmaWVyLkxJTktFRCxcbiAgICAgICAgIG5hbWUsXG4gICAgICAgICBjb21taXQsXG4gICAgICAgICBsYWJlbCxcbiAgICAgIH07XG4gICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBCcmFuY2hTdW1tYXJ5IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBCcmFuY2hTdW1tYXJ5UmVzdWx0IH0gZnJvbSAnLi4vcmVzcG9uc2VzL0JyYW5jaFN1bW1hcnknO1xuaW1wb3J0IHsgTGluZVBhcnNlciwgcGFyc2VTdHJpbmdSZXNwb25zZSB9IGZyb20gJy4uL3V0aWxzJztcblxuY29uc3QgcGFyc2VyczogTGluZVBhcnNlcjxCcmFuY2hTdW1tYXJ5UmVzdWx0PltdID0gW1xuICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAvXihbKitdXFxzKT9cXCgoPzpIRUFEICk/ZGV0YWNoZWQgKD86ZnJvbXxhdCkgKFxcUyspXFwpXFxzKyhbYS16MC05XSspXFxzKC4qKSQvLFxuICAgICAgKHJlc3VsdCwgW2N1cnJlbnQsIG5hbWUsIGNvbW1pdCwgbGFiZWxdKSA9PiB7XG4gICAgICAgICByZXN1bHQucHVzaChicmFuY2hTdGF0dXMoY3VycmVudCksIHRydWUsIG5hbWUsIGNvbW1pdCwgbGFiZWwpO1xuICAgICAgfVxuICAgKSxcbiAgIG5ldyBMaW5lUGFyc2VyKFxuICAgICAgL14oWyorXVxccyk/KFxcUyspXFxzKyhbYS16MC05XSspXFxzPyguKikkL3MsXG4gICAgICAocmVzdWx0LCBbY3VycmVudCwgbmFtZSwgY29tbWl0LCBsYWJlbF0pID0+IHtcbiAgICAgICAgIHJlc3VsdC5wdXNoKGJyYW5jaFN0YXR1cyhjdXJyZW50KSwgZmFsc2UsIG5hbWUsIGNvbW1pdCwgbGFiZWwpO1xuICAgICAgfVxuICAgKSxcbl07XG5cbmZ1bmN0aW9uIGJyYW5jaFN0YXR1cyhpbnB1dD86IHN0cmluZykge1xuICAgcmV0dXJuIGlucHV0ID8gaW5wdXQuY2hhckF0KDApIDogJyc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUJyYW5jaFN1bW1hcnkoc3RkT3V0OiBzdHJpbmcpOiBCcmFuY2hTdW1tYXJ5IHtcbiAgIHJldHVybiBwYXJzZVN0cmluZ1Jlc3BvbnNlKG5ldyBCcmFuY2hTdW1tYXJ5UmVzdWx0KCksIHBhcnNlcnMsIHN0ZE91dCk7XG59XG4iLCAiaW1wb3J0IHsgQnJhbmNoTXVsdGlEZWxldGVSZXN1bHQsIEJyYW5jaFNpbmdsZURlbGV0ZVJlc3VsdCwgQnJhbmNoU3VtbWFyeSB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IEdpdFJlc3BvbnNlRXJyb3IgfSBmcm9tICcuLi9lcnJvcnMvZ2l0LXJlc3BvbnNlLWVycm9yJztcbmltcG9ydCB7IGhhc0JyYW5jaERlbGV0aW9uRXJyb3IsIHBhcnNlQnJhbmNoRGVsZXRpb25zIH0gZnJvbSAnLi4vcGFyc2Vycy9wYXJzZS1icmFuY2gtZGVsZXRlJztcbmltcG9ydCB7IHBhcnNlQnJhbmNoU3VtbWFyeSB9IGZyb20gJy4uL3BhcnNlcnMvcGFyc2UtYnJhbmNoJztcbmltcG9ydCB7IGJ1ZmZlclRvU3RyaW5nIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gY29udGFpbnNEZWxldGVCcmFuY2hDb21tYW5kKGNvbW1hbmRzOiBzdHJpbmdbXSkge1xuICAgY29uc3QgZGVsZXRlQ29tbWFuZHMgPSBbJy1kJywgJy1EJywgJy0tZGVsZXRlJ107XG4gICByZXR1cm4gY29tbWFuZHMuc29tZSgoY29tbWFuZCkgPT4gZGVsZXRlQ29tbWFuZHMuaW5jbHVkZXMoY29tbWFuZCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYnJhbmNoVGFzayhcbiAgIGN1c3RvbUFyZ3M6IHN0cmluZ1tdXG4pOiBTdHJpbmdUYXNrPEJyYW5jaFN1bW1hcnkgfCBCcmFuY2hTaW5nbGVEZWxldGVSZXN1bHQ+IHtcbiAgIGNvbnN0IGlzRGVsZXRlID0gY29udGFpbnNEZWxldGVCcmFuY2hDb21tYW5kKGN1c3RvbUFyZ3MpO1xuICAgY29uc3QgY29tbWFuZHMgPSBbJ2JyYW5jaCcsIC4uLmN1c3RvbUFyZ3NdO1xuXG4gICBpZiAoY29tbWFuZHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb21tYW5kcy5wdXNoKCctYScpO1xuICAgfVxuXG4gICBpZiAoIWNvbW1hbmRzLmluY2x1ZGVzKCctdicpKSB7XG4gICAgICBjb21tYW5kcy5zcGxpY2UoMSwgMCwgJy12Jyk7XG4gICB9XG5cbiAgIHJldHVybiB7XG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBjb21tYW5kcyxcbiAgICAgIHBhcnNlcihzdGRPdXQsIHN0ZEVycikge1xuICAgICAgICAgaWYgKGlzRGVsZXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VCcmFuY2hEZWxldGlvbnMoc3RkT3V0LCBzdGRFcnIpLmFsbFswXTtcbiAgICAgICAgIH1cblxuICAgICAgICAgcmV0dXJuIHBhcnNlQnJhbmNoU3VtbWFyeShzdGRPdXQpO1xuICAgICAgfSxcbiAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBicmFuY2hMb2NhbFRhc2soKTogU3RyaW5nVGFzazxCcmFuY2hTdW1tYXJ5PiB7XG4gICBjb25zdCBwYXJzZXIgPSBwYXJzZUJyYW5jaFN1bW1hcnk7XG5cbiAgIHJldHVybiB7XG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBjb21tYW5kczogWydicmFuY2gnLCAnLXYnXSxcbiAgICAgIHBhcnNlcixcbiAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWxldGVCcmFuY2hlc1Rhc2soXG4gICBicmFuY2hlczogc3RyaW5nW10sXG4gICBmb3JjZURlbGV0ZSA9IGZhbHNlXG4pOiBTdHJpbmdUYXNrPEJyYW5jaE11bHRpRGVsZXRlUmVzdWx0PiB7XG4gICByZXR1cm4ge1xuICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgY29tbWFuZHM6IFsnYnJhbmNoJywgJy12JywgZm9yY2VEZWxldGUgPyAnLUQnIDogJy1kJywgLi4uYnJhbmNoZXNdLFxuICAgICAgcGFyc2VyKHN0ZE91dCwgc3RkRXJyKSB7XG4gICAgICAgICByZXR1cm4gcGFyc2VCcmFuY2hEZWxldGlvbnMoc3RkT3V0LCBzdGRFcnIpO1xuICAgICAgfSxcbiAgICAgIG9uRXJyb3IoeyBleGl0Q29kZSwgc3RkT3V0IH0sIGVycm9yLCBkb25lLCBmYWlsKSB7XG4gICAgICAgICBpZiAoIWhhc0JyYW5jaERlbGV0aW9uRXJyb3IoU3RyaW5nKGVycm9yKSwgZXhpdENvZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFpbChlcnJvcik7XG4gICAgICAgICB9XG5cbiAgICAgICAgIGRvbmUoc3RkT3V0KTtcbiAgICAgIH0sXG4gICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVsZXRlQnJhbmNoVGFzayhcbiAgIGJyYW5jaDogc3RyaW5nLFxuICAgZm9yY2VEZWxldGUgPSBmYWxzZVxuKTogU3RyaW5nVGFzazxCcmFuY2hTaW5nbGVEZWxldGVSZXN1bHQ+IHtcbiAgIGNvbnN0IHRhc2s6IFN0cmluZ1Rhc2s8QnJhbmNoU2luZ2xlRGVsZXRlUmVzdWx0PiA9IHtcbiAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgIGNvbW1hbmRzOiBbJ2JyYW5jaCcsICctdicsIGZvcmNlRGVsZXRlID8gJy1EJyA6ICctZCcsIGJyYW5jaF0sXG4gICAgICBwYXJzZXIoc3RkT3V0LCBzdGRFcnIpIHtcbiAgICAgICAgIHJldHVybiBwYXJzZUJyYW5jaERlbGV0aW9ucyhzdGRPdXQsIHN0ZEVycikuYnJhbmNoZXNbYnJhbmNoXSE7XG4gICAgICB9LFxuICAgICAgb25FcnJvcih7IGV4aXRDb2RlLCBzdGRFcnIsIHN0ZE91dCB9LCBlcnJvciwgXywgZmFpbCkge1xuICAgICAgICAgaWYgKCFoYXNCcmFuY2hEZWxldGlvbkVycm9yKFN0cmluZyhlcnJvciksIGV4aXRDb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhaWwoZXJyb3IpO1xuICAgICAgICAgfVxuXG4gICAgICAgICB0aHJvdyBuZXcgR2l0UmVzcG9uc2VFcnJvcihcbiAgICAgICAgICAgIHRhc2sucGFyc2VyKGJ1ZmZlclRvU3RyaW5nKHN0ZE91dCksIGJ1ZmZlclRvU3RyaW5nKHN0ZEVycikpLFxuICAgICAgICAgICAgU3RyaW5nKGVycm9yKVxuICAgICAgICAgKTtcbiAgICAgIH0sXG4gICB9O1xuXG4gICByZXR1cm4gdGFzaztcbn1cbiIsICIvKipcbiAqIFBhcnNlciBmb3IgdGhlIGBjaGVjay1pZ25vcmVgIGNvbW1hbmQgLSByZXR1cm5zIGVhY2ggZmlsZSBhcyBhIHN0cmluZyBhcnJheVxuICovXG5leHBvcnQgY29uc3QgcGFyc2VDaGVja0lnbm9yZSA9ICh0ZXh0OiBzdHJpbmcpOiBzdHJpbmdbXSA9PiB7XG4gICByZXR1cm4gdGV4dFxuICAgICAgLnNwbGl0KC9cXG4vZylcbiAgICAgIC5tYXAoKGxpbmUpID0+IGxpbmUudHJpbSgpKVxuICAgICAgLmZpbHRlcigoZmlsZSkgPT4gISFmaWxlKTtcbn07XG4iLCAiaW1wb3J0IHsgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IHBhcnNlQ2hlY2tJZ25vcmUgfSBmcm9tICcuLi9yZXNwb25zZXMvQ2hlY2tJZ25vcmUnO1xuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tJZ25vcmVUYXNrKHBhdGhzOiBzdHJpbmdbXSk6IFN0cmluZ1Rhc2s8c3RyaW5nW10+IHtcbiAgIHJldHVybiB7XG4gICAgICBjb21tYW5kczogWydjaGVjay1pZ25vcmUnLCAuLi5wYXRoc10sXG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBwYXJzZXI6IHBhcnNlQ2hlY2tJZ25vcmUsXG4gICB9O1xufVxuIiwgImltcG9ydCB7IGNvbmZpZ3VyYXRpb25FcnJvclRhc2ssIEVtcHR5VGFzaywgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayB9IGZyb20gJy4vdGFzayc7XG5pbXBvcnQgeyBPcHRpb25GbGFncywgT3B0aW9ucywgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGFwcGVuZCwgZmlsdGVyU3RyaW5nIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgdHlwZSBDbG9uZU9wdGlvbnMgPSBPcHRpb25zICZcbiAgIE9wdGlvbkZsYWdzPFxuICAgICAgfCAnLS1iYXJlJ1xuICAgICAgfCAnLS1kaXNzb2NpYXRlJ1xuICAgICAgfCAnLS1taXJyb3InXG4gICAgICB8ICctLW5vLWNoZWNrb3V0J1xuICAgICAgfCAnLS1uby1yZW1vdGUtc3VibW9kdWxlcydcbiAgICAgIHwgJy0tbm8tc2hhbGxvdy1zdWJtb2R1bGVzJ1xuICAgICAgfCAnLS1uby1zaW5nbGUtYnJhbmNoJ1xuICAgICAgfCAnLS1uby10YWdzJ1xuICAgICAgfCAnLS1yZW1vdGUtc3VibW9kdWxlcydcbiAgICAgIHwgJy0tc2luZ2xlLWJyYW5jaCdcbiAgICAgIHwgJy0tc2hhbGxvdy1zdWJtb2R1bGVzJ1xuICAgICAgfCAnLS12ZXJib3NlJ1xuICAgPiAmXG4gICBPcHRpb25GbGFnczwnLS1kZXB0aCcgfCAnLWonIHwgJy0tam9icycsIG51bWJlcj4gJlxuICAgT3B0aW9uRmxhZ3M8XG4gICAgICB8ICctLWJyYW5jaCdcbiAgICAgIHwgJy0tb3JpZ2luJ1xuICAgICAgfCAnLS1yZWN1cnNlLXN1Ym1vZHVsZXMnXG4gICAgICB8ICctLXNlcGFyYXRlLWdpdC1kaXInXG4gICAgICB8ICctLXNoYWxsb3ctZXhjbHVkZSdcbiAgICAgIHwgJy0tc2hhbGxvdy1zaW5jZSdcbiAgICAgIHwgJy0tdGVtcGxhdGUnLFxuICAgICAgc3RyaW5nXG4gICA+O1xuXG5mdW5jdGlvbiBkaXNhbGxvd2VkQ29tbWFuZChjb21tYW5kOiBzdHJpbmcpIHtcbiAgIHJldHVybiAvXi0tdXBsb2FkLXBhY2soPXwkKS8udGVzdChjb21tYW5kKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lVGFzayhcbiAgIHJlcG86IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgIGRpcmVjdG9yeTogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgY3VzdG9tQXJnczogc3RyaW5nW11cbik6IFN0cmluZ1Rhc2s8c3RyaW5nPiB8IEVtcHR5VGFzayB7XG4gICBjb25zdCBjb21tYW5kcyA9IFsnY2xvbmUnLCAuLi5jdXN0b21BcmdzXTtcblxuICAgZmlsdGVyU3RyaW5nKHJlcG8pICYmIGNvbW1hbmRzLnB1c2gocmVwbyk7XG4gICBmaWx0ZXJTdHJpbmcoZGlyZWN0b3J5KSAmJiBjb21tYW5kcy5wdXNoKGRpcmVjdG9yeSk7XG5cbiAgIGNvbnN0IGJhbm5lZCA9IGNvbW1hbmRzLmZpbmQoZGlzYWxsb3dlZENvbW1hbmQpO1xuICAgaWYgKGJhbm5lZCkge1xuICAgICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25FcnJvclRhc2soYGdpdC5mZXRjaDogcG90ZW50aWFsIGV4cGxvaXQgYXJndW1lbnQgYmxvY2tlZC5gKTtcbiAgIH1cblxuICAgcmV0dXJuIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soY29tbWFuZHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xvbmVNaXJyb3JUYXNrKFxuICAgcmVwbzogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgZGlyZWN0b3J5OiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICBjdXN0b21BcmdzOiBzdHJpbmdbXVxuKSB7XG4gICBhcHBlbmQoY3VzdG9tQXJncywgJy0tbWlycm9yJyk7XG5cbiAgIHJldHVybiBjbG9uZVRhc2socmVwbywgZGlyZWN0b3J5LCBjdXN0b21BcmdzKTtcbn1cbiIsICJpbXBvcnQgeyBGZXRjaFJlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgTGluZVBhcnNlciwgcGFyc2VTdHJpbmdSZXNwb25zZSB9IGZyb20gJy4uL3V0aWxzJztcblxuY29uc3QgcGFyc2VyczogTGluZVBhcnNlcjxGZXRjaFJlc3VsdD5bXSA9IFtcbiAgIG5ldyBMaW5lUGFyc2VyKC9Gcm9tICguKykkLywgKHJlc3VsdCwgW3JlbW90ZV0pID0+IHtcbiAgICAgIHJlc3VsdC5yZW1vdGUgPSByZW1vdGU7XG4gICB9KSxcbiAgIG5ldyBMaW5lUGFyc2VyKC9cXCogXFxbbmV3IGJyYW5jaF1cXHMrKFxcUyspXFxzKi0+ICguKykkLywgKHJlc3VsdCwgW25hbWUsIHRyYWNraW5nXSkgPT4ge1xuICAgICAgcmVzdWx0LmJyYW5jaGVzLnB1c2goe1xuICAgICAgICAgbmFtZSxcbiAgICAgICAgIHRyYWNraW5nLFxuICAgICAgfSk7XG4gICB9KSxcbiAgIG5ldyBMaW5lUGFyc2VyKC9cXCogXFxbbmV3IHRhZ11cXHMrKFxcUyspXFxzKi0+ICguKykkLywgKHJlc3VsdCwgW25hbWUsIHRyYWNraW5nXSkgPT4ge1xuICAgICAgcmVzdWx0LnRhZ3MucHVzaCh7XG4gICAgICAgICBuYW1lLFxuICAgICAgICAgdHJhY2tpbmcsXG4gICAgICB9KTtcbiAgIH0pLFxuICAgbmV3IExpbmVQYXJzZXIoLy0gXFxbZGVsZXRlZF1cXHMrXFxTK1xccyotPiAoLispJC8sIChyZXN1bHQsIFt0cmFja2luZ10pID0+IHtcbiAgICAgIHJlc3VsdC5kZWxldGVkLnB1c2goe1xuICAgICAgICAgdHJhY2tpbmcsXG4gICAgICB9KTtcbiAgIH0pLFxuICAgbmV3IExpbmVQYXJzZXIoXG4gICAgICAvXFxzKihbXi5dKylcXC5cXC4oXFxTKylcXHMrKFxcUyspXFxzKi0+ICguKykkLyxcbiAgICAgIChyZXN1bHQsIFtmcm9tLCB0bywgbmFtZSwgdHJhY2tpbmddKSA9PiB7XG4gICAgICAgICByZXN1bHQudXBkYXRlZC5wdXNoKHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB0cmFja2luZyxcbiAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgIH0pO1xuICAgICAgfVxuICAgKSxcbl07XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUZldGNoUmVzdWx0KHN0ZE91dDogc3RyaW5nLCBzdGRFcnI6IHN0cmluZyk6IEZldGNoUmVzdWx0IHtcbiAgIGNvbnN0IHJlc3VsdDogRmV0Y2hSZXN1bHQgPSB7XG4gICAgICByYXc6IHN0ZE91dCxcbiAgICAgIHJlbW90ZTogbnVsbCxcbiAgICAgIGJyYW5jaGVzOiBbXSxcbiAgICAgIHRhZ3M6IFtdLFxuICAgICAgdXBkYXRlZDogW10sXG4gICAgICBkZWxldGVkOiBbXSxcbiAgIH07XG4gICByZXR1cm4gcGFyc2VTdHJpbmdSZXNwb25zZShyZXN1bHQsIHBhcnNlcnMsIFtzdGRPdXQsIHN0ZEVycl0pO1xufVxuIiwgImltcG9ydCB7IEZldGNoUmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBwYXJzZUZldGNoUmVzdWx0IH0gZnJvbSAnLi4vcGFyc2Vycy9wYXJzZS1mZXRjaCc7XG5pbXBvcnQgeyBTdHJpbmdUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBjb25maWd1cmF0aW9uRXJyb3JUYXNrLCBFbXB0eVRhc2sgfSBmcm9tICcuL3Rhc2snO1xuXG5mdW5jdGlvbiBkaXNhbGxvd2VkQ29tbWFuZChjb21tYW5kOiBzdHJpbmcpIHtcbiAgIHJldHVybiAvXi0tdXBsb2FkLXBhY2soPXwkKS8udGVzdChjb21tYW5kKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZldGNoVGFzayhcbiAgIHJlbW90ZTogc3RyaW5nLFxuICAgYnJhbmNoOiBzdHJpbmcsXG4gICBjdXN0b21BcmdzOiBzdHJpbmdbXVxuKTogU3RyaW5nVGFzazxGZXRjaFJlc3VsdD4gfCBFbXB0eVRhc2sge1xuICAgY29uc3QgY29tbWFuZHMgPSBbJ2ZldGNoJywgLi4uY3VzdG9tQXJnc107XG4gICBpZiAocmVtb3RlICYmIGJyYW5jaCkge1xuICAgICAgY29tbWFuZHMucHVzaChyZW1vdGUsIGJyYW5jaCk7XG4gICB9XG5cbiAgIGNvbnN0IGJhbm5lZCA9IGNvbW1hbmRzLmZpbmQoZGlzYWxsb3dlZENvbW1hbmQpO1xuICAgaWYgKGJhbm5lZCkge1xuICAgICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25FcnJvclRhc2soYGdpdC5mZXRjaDogcG90ZW50aWFsIGV4cGxvaXQgYXJndW1lbnQgYmxvY2tlZC5gKTtcbiAgIH1cblxuICAgcmV0dXJuIHtcbiAgICAgIGNvbW1hbmRzLFxuICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgcGFyc2VyOiBwYXJzZUZldGNoUmVzdWx0LFxuICAgfTtcbn1cbiIsICJpbXBvcnQgeyBNb3ZlUmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBMaW5lUGFyc2VyLCBwYXJzZVN0cmluZ1Jlc3BvbnNlIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5jb25zdCBwYXJzZXJzOiBMaW5lUGFyc2VyPE1vdmVSZXN1bHQ+W10gPSBbXG4gICBuZXcgTGluZVBhcnNlcigvXlJlbmFtaW5nICguKykgdG8gKC4rKSQvLCAocmVzdWx0LCBbZnJvbSwgdG9dKSA9PiB7XG4gICAgICByZXN1bHQubW92ZXMucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgfSksXG5dO1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VNb3ZlUmVzdWx0KHN0ZE91dDogc3RyaW5nKTogTW92ZVJlc3VsdCB7XG4gICByZXR1cm4gcGFyc2VTdHJpbmdSZXNwb25zZSh7IG1vdmVzOiBbXSB9LCBwYXJzZXJzLCBzdGRPdXQpO1xufVxuIiwgImltcG9ydCB7IE1vdmVSZXN1bHQgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IHBhcnNlTW92ZVJlc3VsdCB9IGZyb20gJy4uL3BhcnNlcnMvcGFyc2UtbW92ZSc7XG5pbXBvcnQgeyBTdHJpbmdUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgYXNBcnJheSB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIG1vdmVUYXNrKGZyb206IHN0cmluZyB8IHN0cmluZ1tdLCB0bzogc3RyaW5nKTogU3RyaW5nVGFzazxNb3ZlUmVzdWx0PiB7XG4gICByZXR1cm4ge1xuICAgICAgY29tbWFuZHM6IFsnbXYnLCAnLXYnLCAuLi5hc0FycmF5KGZyb20pLCB0b10sXG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBwYXJzZXI6IHBhcnNlTW92ZVJlc3VsdCxcbiAgIH07XG59XG4iLCAiaW1wb3J0IHsgUHVsbFJlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuaW1wb3J0IHsgR2l0UmVzcG9uc2VFcnJvciB9IGZyb20gJy4uL2Vycm9ycy9naXQtcmVzcG9uc2UtZXJyb3InO1xuaW1wb3J0IHsgcGFyc2VQdWxsRXJyb3JSZXN1bHQsIHBhcnNlUHVsbFJlc3VsdCB9IGZyb20gJy4uL3BhcnNlcnMvcGFyc2UtcHVsbCc7XG5pbXBvcnQgeyBNYXliZSwgU3RyaW5nVGFzayB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGJ1ZmZlclRvU3RyaW5nIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gcHVsbFRhc2soXG4gICByZW1vdGU6IE1heWJlPHN0cmluZz4sXG4gICBicmFuY2g6IE1heWJlPHN0cmluZz4sXG4gICBjdXN0b21BcmdzOiBzdHJpbmdbXVxuKTogU3RyaW5nVGFzazxQdWxsUmVzdWx0PiB7XG4gICBjb25zdCBjb21tYW5kczogc3RyaW5nW10gPSBbJ3B1bGwnLCAuLi5jdXN0b21BcmdzXTtcbiAgIGlmIChyZW1vdGUgJiYgYnJhbmNoKSB7XG4gICAgICBjb21tYW5kcy5zcGxpY2UoMSwgMCwgcmVtb3RlLCBicmFuY2gpO1xuICAgfVxuXG4gICByZXR1cm4ge1xuICAgICAgY29tbWFuZHMsXG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBwYXJzZXIoc3RkT3V0LCBzdGRFcnIpOiBQdWxsUmVzdWx0IHtcbiAgICAgICAgIHJldHVybiBwYXJzZVB1bGxSZXN1bHQoc3RkT3V0LCBzdGRFcnIpO1xuICAgICAgfSxcbiAgICAgIG9uRXJyb3IocmVzdWx0LCBfZXJyb3IsIF9kb25lLCBmYWlsKSB7XG4gICAgICAgICBjb25zdCBwdWxsRXJyb3IgPSBwYXJzZVB1bGxFcnJvclJlc3VsdChcbiAgICAgICAgICAgIGJ1ZmZlclRvU3RyaW5nKHJlc3VsdC5zdGRPdXQpLFxuICAgICAgICAgICAgYnVmZmVyVG9TdHJpbmcocmVzdWx0LnN0ZEVycilcbiAgICAgICAgICk7XG4gICAgICAgICBpZiAocHVsbEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFpbChuZXcgR2l0UmVzcG9uc2VFcnJvcihwdWxsRXJyb3IpKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgZmFpbChfZXJyb3IpO1xuICAgICAgfSxcbiAgIH07XG59XG4iLCAiaW1wb3J0IHsgZm9yRWFjaExpbmVXaXRoQ29udGVudCB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGludGVyZmFjZSBSZW1vdGVXaXRob3V0UmVmcyB7XG4gICBuYW1lOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVtb3RlV2l0aFJlZnMgZXh0ZW5kcyBSZW1vdGVXaXRob3V0UmVmcyB7XG4gICByZWZzOiB7XG4gICAgICBmZXRjaDogc3RyaW5nO1xuICAgICAgcHVzaDogc3RyaW5nO1xuICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlR2V0UmVtb3Rlcyh0ZXh0OiBzdHJpbmcpOiBSZW1vdGVXaXRob3V0UmVmc1tdIHtcbiAgIGNvbnN0IHJlbW90ZXM6IHsgW25hbWU6IHN0cmluZ106IFJlbW90ZVdpdGhvdXRSZWZzIH0gPSB7fTtcblxuICAgZm9yRWFjaCh0ZXh0LCAoW25hbWVdKSA9PiAocmVtb3Rlc1tuYW1lXSA9IHsgbmFtZSB9KSk7XG5cbiAgIHJldHVybiBPYmplY3QudmFsdWVzKHJlbW90ZXMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VHZXRSZW1vdGVzVmVyYm9zZSh0ZXh0OiBzdHJpbmcpOiBSZW1vdGVXaXRoUmVmc1tdIHtcbiAgIGNvbnN0IHJlbW90ZXM6IHsgW25hbWU6IHN0cmluZ106IFJlbW90ZVdpdGhSZWZzIH0gPSB7fTtcblxuICAgZm9yRWFjaCh0ZXh0LCAoW25hbWUsIHVybCwgcHVycG9zZV0pID0+IHtcbiAgICAgIGlmICghcmVtb3Rlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgcmVtb3Rlc1tuYW1lXSA9IHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICByZWZzOiB7IGZldGNoOiAnJywgcHVzaDogJycgfSxcbiAgICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChwdXJwb3NlICYmIHVybCkge1xuICAgICAgICAgcmVtb3Rlc1tuYW1lXS5yZWZzW3B1cnBvc2UucmVwbGFjZSgvW15hLXpdL2csICcnKSBhcyBrZXlvZiBSZW1vdGVXaXRoUmVmc1sncmVmcyddXSA9IHVybDtcbiAgICAgIH1cbiAgIH0pO1xuXG4gICByZXR1cm4gT2JqZWN0LnZhbHVlcyhyZW1vdGVzKTtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaCh0ZXh0OiBzdHJpbmcsIGhhbmRsZXI6IChsaW5lOiBzdHJpbmdbXSkgPT4gdm9pZCkge1xuICAgZm9yRWFjaExpbmVXaXRoQ29udGVudCh0ZXh0LCAobGluZSkgPT4gaGFuZGxlcihsaW5lLnNwbGl0KC9cXHMrLykpKTtcbn1cbiIsICJpbXBvcnQgeyBwYXJzZUdldFJlbW90ZXMsIHBhcnNlR2V0UmVtb3Rlc1ZlcmJvc2UgfSBmcm9tICcuLi9yZXNwb25zZXMvR2V0UmVtb3RlU3VtbWFyeSc7XG5pbXBvcnQgeyBTdHJpbmdUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayB9IGZyb20gJy4vdGFzayc7XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRSZW1vdGVUYXNrKFxuICAgcmVtb3RlTmFtZTogc3RyaW5nLFxuICAgcmVtb3RlUmVwbzogc3RyaW5nLFxuICAgY3VzdG9tQXJnczogc3RyaW5nW11cbik6IFN0cmluZ1Rhc2s8c3RyaW5nPiB7XG4gICByZXR1cm4gc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhbJ3JlbW90ZScsICdhZGQnLCAuLi5jdXN0b21BcmdzLCByZW1vdGVOYW1lLCByZW1vdGVSZXBvXSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZW1vdGVzVGFzayh2ZXJib3NlOiBib29sZWFuKTogU3RyaW5nVGFzazxhbnk+IHtcbiAgIGNvbnN0IGNvbW1hbmRzID0gWydyZW1vdGUnXTtcbiAgIGlmICh2ZXJib3NlKSB7XG4gICAgICBjb21tYW5kcy5wdXNoKCctdicpO1xuICAgfVxuXG4gICByZXR1cm4ge1xuICAgICAgY29tbWFuZHMsXG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBwYXJzZXI6IHZlcmJvc2UgPyBwYXJzZUdldFJlbW90ZXNWZXJib3NlIDogcGFyc2VHZXRSZW1vdGVzLFxuICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxpc3RSZW1vdGVzVGFzayhjdXN0b21BcmdzOiBzdHJpbmdbXSk6IFN0cmluZ1Rhc2s8c3RyaW5nPiB7XG4gICBjb25zdCBjb21tYW5kcyA9IFsuLi5jdXN0b21BcmdzXTtcbiAgIGlmIChjb21tYW5kc1swXSAhPT0gJ2xzLXJlbW90ZScpIHtcbiAgICAgIGNvbW1hbmRzLnVuc2hpZnQoJ2xzLXJlbW90ZScpO1xuICAgfVxuXG4gICByZXR1cm4gc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhjb21tYW5kcyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdGVUYXNrKGN1c3RvbUFyZ3M6IHN0cmluZ1tdKTogU3RyaW5nVGFzazxzdHJpbmc+IHtcbiAgIGNvbnN0IGNvbW1hbmRzID0gWy4uLmN1c3RvbUFyZ3NdO1xuICAgaWYgKGNvbW1hbmRzWzBdICE9PSAncmVtb3RlJykge1xuICAgICAgY29tbWFuZHMudW5zaGlmdCgncmVtb3RlJyk7XG4gICB9XG5cbiAgIHJldHVybiBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKGNvbW1hbmRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVJlbW90ZVRhc2socmVtb3RlTmFtZTogc3RyaW5nKSB7XG4gICByZXR1cm4gc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhbJ3JlbW90ZScsICdyZW1vdmUnLCByZW1vdGVOYW1lXSk7XG59XG4iLCAiaW1wb3J0IHsgTG9nT3B0aW9ucywgTG9nUmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vdHlwaW5ncyc7XG5pbXBvcnQgeyBsb2dGb3JtYXRGcm9tQ29tbWFuZCB9IGZyb20gJy4uL2FyZ3MvbG9nLWZvcm1hdCc7XG5pbXBvcnQgeyBjcmVhdGVMaXN0TG9nU3VtbWFyeVBhcnNlciB9IGZyb20gJy4uL3BhcnNlcnMvcGFyc2UtbGlzdC1sb2ctc3VtbWFyeSc7XG5pbXBvcnQgdHlwZSB7IFN0cmluZ1Rhc2sgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyB2YWxpZGF0ZUxvZ0Zvcm1hdENvbmZpZyB9IGZyb20gJy4vZGlmZic7XG5pbXBvcnQgeyBwYXJzZUxvZ09wdGlvbnMgfSBmcm9tICcuL2xvZyc7XG5pbXBvcnQgdHlwZSB7IEVtcHR5VGFzayB9IGZyb20gJy4vdGFzayc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzdGFzaExpc3RUYXNrKFxuICAgb3B0OiBMb2dPcHRpb25zID0ge30sXG4gICBjdXN0b21BcmdzOiBzdHJpbmdbXVxuKTogRW1wdHlUYXNrIHwgU3RyaW5nVGFzazxMb2dSZXN1bHQ+IHtcbiAgIGNvbnN0IG9wdGlvbnMgPSBwYXJzZUxvZ09wdGlvbnM8YW55PihvcHQpO1xuICAgY29uc3QgY29tbWFuZHMgPSBbJ3N0YXNoJywgJ2xpc3QnLCAuLi5vcHRpb25zLmNvbW1hbmRzLCAuLi5jdXN0b21BcmdzXTtcbiAgIGNvbnN0IHBhcnNlciA9IGNyZWF0ZUxpc3RMb2dTdW1tYXJ5UGFyc2VyKFxuICAgICAgb3B0aW9ucy5zcGxpdHRlcixcbiAgICAgIG9wdGlvbnMuZmllbGRzLFxuICAgICAgbG9nRm9ybWF0RnJvbUNvbW1hbmQoY29tbWFuZHMpXG4gICApO1xuXG4gICByZXR1cm4gKFxuICAgICAgdmFsaWRhdGVMb2dGb3JtYXRDb25maWcoY29tbWFuZHMpIHx8IHtcbiAgICAgICAgIGNvbW1hbmRzLFxuICAgICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgICAgcGFyc2VyLFxuICAgICAgfVxuICAgKTtcbn1cbiIsICJpbXBvcnQgeyBTdHJpbmdUYXNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayB9IGZyb20gJy4vdGFzayc7XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRTdWJNb2R1bGVUYXNrKHJlcG86IHN0cmluZywgcGF0aDogc3RyaW5nKTogU3RyaW5nVGFzazxzdHJpbmc+IHtcbiAgIHJldHVybiBzdWJNb2R1bGVUYXNrKFsnYWRkJywgcmVwbywgcGF0aF0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdFN1Yk1vZHVsZVRhc2soY3VzdG9tQXJnczogc3RyaW5nW10pOiBTdHJpbmdUYXNrPHN0cmluZz4ge1xuICAgcmV0dXJuIHN1Yk1vZHVsZVRhc2soWydpbml0JywgLi4uY3VzdG9tQXJnc10pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3ViTW9kdWxlVGFzayhjdXN0b21BcmdzOiBzdHJpbmdbXSk6IFN0cmluZ1Rhc2s8c3RyaW5nPiB7XG4gICBjb25zdCBjb21tYW5kcyA9IFsuLi5jdXN0b21BcmdzXTtcbiAgIGlmIChjb21tYW5kc1swXSAhPT0gJ3N1Ym1vZHVsZScpIHtcbiAgICAgIGNvbW1hbmRzLnVuc2hpZnQoJ3N1Ym1vZHVsZScpO1xuICAgfVxuXG4gICByZXR1cm4gc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhjb21tYW5kcyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVTdWJNb2R1bGVUYXNrKGN1c3RvbUFyZ3M6IHN0cmluZ1tdKTogU3RyaW5nVGFzazxzdHJpbmc+IHtcbiAgIHJldHVybiBzdWJNb2R1bGVUYXNrKFsndXBkYXRlJywgLi4uY3VzdG9tQXJnc10pO1xufVxuIiwgImltcG9ydCB7IFRhZ1Jlc3VsdCB9IGZyb20gJy4uLy4uLy4uL3R5cGluZ3MnO1xuXG5leHBvcnQgY2xhc3MgVGFnTGlzdCBpbXBsZW1lbnRzIFRhZ1Jlc3VsdCB7XG4gICBjb25zdHJ1Y3RvcihcbiAgICAgIHB1YmxpYyByZWFkb25seSBhbGw6IHN0cmluZ1tdLFxuICAgICAgcHVibGljIHJlYWRvbmx5IGxhdGVzdDogc3RyaW5nIHwgdW5kZWZpbmVkXG4gICApIHt9XG59XG5cbmV4cG9ydCBjb25zdCBwYXJzZVRhZ0xpc3QgPSBmdW5jdGlvbiAoZGF0YTogc3RyaW5nLCBjdXN0b21Tb3J0ID0gZmFsc2UpIHtcbiAgIGNvbnN0IHRhZ3MgPSBkYXRhLnNwbGl0KCdcXG4nKS5tYXAodHJpbW1lZCkuZmlsdGVyKEJvb2xlYW4pO1xuXG4gICBpZiAoIWN1c3RvbVNvcnQpIHtcbiAgICAgIHRhZ3Muc29ydChmdW5jdGlvbiAodGFnQSwgdGFnQikge1xuICAgICAgICAgY29uc3QgcGFydHNBID0gdGFnQS5zcGxpdCgnLicpO1xuICAgICAgICAgY29uc3QgcGFydHNCID0gdGFnQi5zcGxpdCgnLicpO1xuXG4gICAgICAgICBpZiAocGFydHNBLmxlbmd0aCA9PT0gMSB8fCBwYXJ0c0IubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gc2luZ2xlU29ydGVkKHRvTnVtYmVyKHBhcnRzQVswXSksIHRvTnVtYmVyKHBhcnRzQlswXSkpO1xuICAgICAgICAgfVxuXG4gICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IE1hdGgubWF4KHBhcnRzQS5sZW5ndGgsIHBhcnRzQi5sZW5ndGgpOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBkaWZmID0gc29ydGVkKHRvTnVtYmVyKHBhcnRzQVtpXSksIHRvTnVtYmVyKHBhcnRzQltpXSkpO1xuXG4gICAgICAgICAgICBpZiAoZGlmZikge1xuICAgICAgICAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG5cbiAgICAgICAgIHJldHVybiAwO1xuICAgICAgfSk7XG4gICB9XG5cbiAgIGNvbnN0IGxhdGVzdCA9IGN1c3RvbVNvcnQgPyB0YWdzWzBdIDogWy4uLnRhZ3NdLnJldmVyc2UoKS5maW5kKCh0YWcpID0+IHRhZy5pbmRleE9mKCcuJykgPj0gMCk7XG5cbiAgIHJldHVybiBuZXcgVGFnTGlzdCh0YWdzLCBsYXRlc3QpO1xufTtcblxuZnVuY3Rpb24gc2luZ2xlU29ydGVkKGE6IG51bWJlciwgYjogbnVtYmVyKTogbnVtYmVyIHtcbiAgIGNvbnN0IGFJc051bSA9IGlzTmFOKGEpO1xuICAgY29uc3QgYklzTnVtID0gaXNOYU4oYik7XG5cbiAgIGlmIChhSXNOdW0gIT09IGJJc051bSkge1xuICAgICAgcmV0dXJuIGFJc051bSA/IDEgOiAtMTtcbiAgIH1cblxuICAgcmV0dXJuIGFJc051bSA/IHNvcnRlZChhLCBiKSA6IDA7XG59XG5cbmZ1bmN0aW9uIHNvcnRlZChhOiBudW1iZXIsIGI6IG51bWJlcikge1xuICAgcmV0dXJuIGEgPT09IGIgPyAwIDogYSA+IGIgPyAxIDogLTE7XG59XG5cbmZ1bmN0aW9uIHRyaW1tZWQoaW5wdXQ6IHN0cmluZykge1xuICAgcmV0dXJuIGlucHV0LnRyaW0oKTtcbn1cblxuZnVuY3Rpb24gdG9OdW1iZXIoaW5wdXQ6IHN0cmluZyB8IHVuZGVmaW5lZCkge1xuICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBwYXJzZUludChpbnB1dC5yZXBsYWNlKC9eXFxEKy9nLCAnJyksIDEwKSB8fCAwO1xuICAgfVxuXG4gICByZXR1cm4gMDtcbn1cbiIsICJpbXBvcnQgeyBUYWdSZXN1bHQgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcbmltcG9ydCB7IHBhcnNlVGFnTGlzdCB9IGZyb20gJy4uL3Jlc3BvbnNlcy9UYWdMaXN0JztcbmltcG9ydCB7IFN0cmluZ1Rhc2sgfSBmcm9tICcuLi90eXBlcyc7XG5cbi8qKlxuICogVGFzayB1c2VkIGJ5IGBnaXQudGFnc2BcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRhZ0xpc3RUYXNrKGN1c3RvbUFyZ3M6IHN0cmluZ1tdID0gW10pOiBTdHJpbmdUYXNrPFRhZ1Jlc3VsdD4ge1xuICAgY29uc3QgaGFzQ3VzdG9tU29ydCA9IGN1c3RvbUFyZ3Muc29tZSgob3B0aW9uKSA9PiAvXi0tc29ydD0vLnRlc3Qob3B0aW9uKSk7XG5cbiAgIHJldHVybiB7XG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBjb21tYW5kczogWyd0YWcnLCAnLWwnLCAuLi5jdXN0b21BcmdzXSxcbiAgICAgIHBhcnNlcih0ZXh0OiBzdHJpbmcpIHtcbiAgICAgICAgIHJldHVybiBwYXJzZVRhZ0xpc3QodGV4dCwgaGFzQ3VzdG9tU29ydCk7XG4gICAgICB9LFxuICAgfTtcbn1cblxuLyoqXG4gKiBUYXNrIHVzZWQgYnkgYGdpdC5hZGRUYWdgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRUYWdUYXNrKG5hbWU6IHN0cmluZyk6IFN0cmluZ1Rhc2s8eyBuYW1lOiBzdHJpbmcgfT4ge1xuICAgcmV0dXJuIHtcbiAgICAgIGZvcm1hdDogJ3V0Zi04JyxcbiAgICAgIGNvbW1hbmRzOiBbJ3RhZycsIG5hbWVdLFxuICAgICAgcGFyc2VyKCkge1xuICAgICAgICAgcmV0dXJuIHsgbmFtZSB9O1xuICAgICAgfSxcbiAgIH07XG59XG5cbi8qKlxuICogVGFzayB1c2VkIGJ5IGBnaXQuYWRkVGFnYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkQW5ub3RhdGVkVGFnVGFzayhcbiAgIG5hbWU6IHN0cmluZyxcbiAgIHRhZ01lc3NhZ2U6IHN0cmluZ1xuKTogU3RyaW5nVGFzazx7IG5hbWU6IHN0cmluZyB9PiB7XG4gICByZXR1cm4ge1xuICAgICAgZm9ybWF0OiAndXRmLTgnLFxuICAgICAgY29tbWFuZHM6IFsndGFnJywgJy1hJywgJy1tJywgdGFnTWVzc2FnZSwgbmFtZV0sXG4gICAgICBwYXJzZXIoKSB7XG4gICAgICAgICByZXR1cm4geyBuYW1lIH07XG4gICAgICB9LFxuICAgfTtcbn1cbiIsICJjb25zdCB7IEdpdEV4ZWN1dG9yIH0gPSByZXF1aXJlKCcuL2xpYi9ydW5uZXJzL2dpdC1leGVjdXRvcicpO1xuY29uc3QgeyBTaW1wbGVHaXRBcGkgfSA9IHJlcXVpcmUoJy4vbGliL3NpbXBsZS1naXQtYXBpJyk7XG5cbmNvbnN0IHsgU2NoZWR1bGVyIH0gPSByZXF1aXJlKCcuL2xpYi9ydW5uZXJzL3NjaGVkdWxlcicpO1xuY29uc3QgeyBjb25maWd1cmF0aW9uRXJyb3JUYXNrIH0gPSByZXF1aXJlKCcuL2xpYi90YXNrcy90YXNrJyk7XG5jb25zdCB7XG4gICBhc0FycmF5LFxuICAgZmlsdGVyQXJyYXksXG4gICBmaWx0ZXJQcmltaXRpdmVzLFxuICAgZmlsdGVyU3RyaW5nLFxuICAgZmlsdGVyU3RyaW5nT3JTdHJpbmdBcnJheSxcbiAgIGZpbHRlclR5cGUsXG4gICBnZXRUcmFpbGluZ09wdGlvbnMsXG4gICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQsXG4gICB0cmFpbGluZ09wdGlvbnNBcmd1bWVudCxcbn0gPSByZXF1aXJlKCcuL2xpYi91dGlscycpO1xuY29uc3QgeyBhcHBseVBhdGNoVGFzayB9ID0gcmVxdWlyZSgnLi9saWIvdGFza3MvYXBwbHktcGF0Y2gnKTtcbmNvbnN0IHtcbiAgIGJyYW5jaFRhc2ssXG4gICBicmFuY2hMb2NhbFRhc2ssXG4gICBkZWxldGVCcmFuY2hlc1Rhc2ssXG4gICBkZWxldGVCcmFuY2hUYXNrLFxufSA9IHJlcXVpcmUoJy4vbGliL3Rhc2tzL2JyYW5jaCcpO1xuY29uc3QgeyBjaGVja0lnbm9yZVRhc2sgfSA9IHJlcXVpcmUoJy4vbGliL3Rhc2tzL2NoZWNrLWlnbm9yZScpO1xuY29uc3QgeyBjaGVja0lzUmVwb1Rhc2sgfSA9IHJlcXVpcmUoJy4vbGliL3Rhc2tzL2NoZWNrLWlzLXJlcG8nKTtcbmNvbnN0IHsgY2xvbmVUYXNrLCBjbG9uZU1pcnJvclRhc2sgfSA9IHJlcXVpcmUoJy4vbGliL3Rhc2tzL2Nsb25lJyk7XG5jb25zdCB7IGNsZWFuV2l0aE9wdGlvbnNUYXNrLCBpc0NsZWFuT3B0aW9uc0FycmF5IH0gPSByZXF1aXJlKCcuL2xpYi90YXNrcy9jbGVhbicpO1xuY29uc3QgeyBkaWZmU3VtbWFyeVRhc2sgfSA9IHJlcXVpcmUoJy4vbGliL3Rhc2tzL2RpZmYnKTtcbmNvbnN0IHsgZmV0Y2hUYXNrIH0gPSByZXF1aXJlKCcuL2xpYi90YXNrcy9mZXRjaCcpO1xuY29uc3QgeyBtb3ZlVGFzayB9ID0gcmVxdWlyZSgnLi9saWIvdGFza3MvbW92ZScpO1xuY29uc3QgeyBwdWxsVGFzayB9ID0gcmVxdWlyZSgnLi9saWIvdGFza3MvcHVsbCcpO1xuY29uc3QgeyBwdXNoVGFnc1Rhc2sgfSA9IHJlcXVpcmUoJy4vbGliL3Rhc2tzL3B1c2gnKTtcbmNvbnN0IHtcbiAgIGFkZFJlbW90ZVRhc2ssXG4gICBnZXRSZW1vdGVzVGFzayxcbiAgIGxpc3RSZW1vdGVzVGFzayxcbiAgIHJlbW90ZVRhc2ssXG4gICByZW1vdmVSZW1vdGVUYXNrLFxufSA9IHJlcXVpcmUoJy4vbGliL3Rhc2tzL3JlbW90ZScpO1xuY29uc3QgeyBnZXRSZXNldE1vZGUsIHJlc2V0VGFzayB9ID0gcmVxdWlyZSgnLi9saWIvdGFza3MvcmVzZXQnKTtcbmNvbnN0IHsgc3Rhc2hMaXN0VGFzayB9ID0gcmVxdWlyZSgnLi9saWIvdGFza3Mvc3Rhc2gtbGlzdCcpO1xuY29uc3Qge1xuICAgYWRkU3ViTW9kdWxlVGFzayxcbiAgIGluaXRTdWJNb2R1bGVUYXNrLFxuICAgc3ViTW9kdWxlVGFzayxcbiAgIHVwZGF0ZVN1Yk1vZHVsZVRhc2ssXG59ID0gcmVxdWlyZSgnLi9saWIvdGFza3Mvc3ViLW1vZHVsZScpO1xuY29uc3QgeyBhZGRBbm5vdGF0ZWRUYWdUYXNrLCBhZGRUYWdUYXNrLCB0YWdMaXN0VGFzayB9ID0gcmVxdWlyZSgnLi9saWIvdGFza3MvdGFnJyk7XG5jb25zdCB7IHN0cmFpZ2h0VGhyb3VnaEJ1ZmZlclRhc2ssIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2sgfSA9IHJlcXVpcmUoJy4vbGliL3Rhc2tzL3Rhc2snKTtcblxuZnVuY3Rpb24gR2l0KG9wdGlvbnMsIHBsdWdpbnMpIHtcbiAgIHRoaXMuX3BsdWdpbnMgPSBwbHVnaW5zO1xuICAgdGhpcy5fZXhlY3V0b3IgPSBuZXcgR2l0RXhlY3V0b3IoXG4gICAgICBvcHRpb25zLmJhc2VEaXIsXG4gICAgICBuZXcgU2NoZWR1bGVyKG9wdGlvbnMubWF4Q29uY3VycmVudFByb2Nlc3NlcyksXG4gICAgICBwbHVnaW5zXG4gICApO1xuXG4gICB0aGlzLl90cmltbWVkID0gb3B0aW9ucy50cmltbWVkO1xufVxuXG4oR2l0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU2ltcGxlR2l0QXBpLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gR2l0O1xuXG4vKipcbiAqIFNldHMgdGhlIHBhdGggdG8gYSBjdXN0b20gZ2l0IGJpbmFyeSwgc2hvdWxkIGVpdGhlciBiZSBgZ2l0YCB3aGVuIHRoZXJlIGlzIGFuIGluc3RhbGxhdGlvbiBvZiBnaXQgYXZhaWxhYmxlIG9uXG4gKiB0aGUgc3lzdGVtIHBhdGgsIG9yIGEgZnVsbHkgcXVhbGlmaWVkIHBhdGggdG8gdGhlIGV4ZWN1dGFibGUuXG4gKi9cbkdpdC5wcm90b3R5cGUuY3VzdG9tQmluYXJ5ID0gZnVuY3Rpb24gKGNvbW1hbmQpIHtcbiAgIHRoaXMuX3BsdWdpbnMucmVjb25maWd1cmUoJ2JpbmFyeScsIGNvbW1hbmQpO1xuICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgYW4gZW52aXJvbm1lbnQgdmFyaWFibGUgZm9yIHRoZSBzcGF3bmVkIGNoaWxkIHByb2Nlc3MsIGVpdGhlciBzdXBwbHkgYm90aCBhIG5hbWUgYW5kIHZhbHVlIGFzIHN0cmluZ3Mgb3JcbiAqIGEgc2luZ2xlIG9iamVjdCB0byBlbnRpcmVseSByZXBsYWNlIHRoZSBjdXJyZW50IGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdmFsdWVdXG4gKiBAcmV0dXJucyB7R2l0fVxuICovXG5HaXQucHJvdG90eXBlLmVudiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgICB0aGlzLl9leGVjdXRvci5lbnYgPSBuYW1lO1xuICAgfSBlbHNlIHtcbiAgICAgICh0aGlzLl9leGVjdXRvci5lbnYgPSB0aGlzLl9leGVjdXRvci5lbnYgfHwge30pW25hbWVdID0gdmFsdWU7XG4gICB9XG5cbiAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBMaXN0IHRoZSBzdGFzaChzKSBvZiB0aGUgbG9jYWwgcmVwb1xuICovXG5HaXQucHJvdG90eXBlLnN0YXNoTGlzdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgIHN0YXNoTGlzdFRhc2soXG4gICAgICAgICB0cmFpbGluZ09wdGlvbnNBcmd1bWVudChhcmd1bWVudHMpIHx8IHt9LFxuICAgICAgICAgKGZpbHRlckFycmF5KG9wdGlvbnMpICYmIG9wdGlvbnMpIHx8IFtdXG4gICAgICApLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVDbG9uZVRhc2soYXBpLCB0YXNrLCByZXBvUGF0aCwgbG9jYWxQYXRoKSB7XG4gICBpZiAodHlwZW9mIHJlcG9QYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25FcnJvclRhc2soYGdpdC4ke2FwaX0oKSByZXF1aXJlcyBhIHN0cmluZyAncmVwb1BhdGgnYCk7XG4gICB9XG5cbiAgIHJldHVybiB0YXNrKHJlcG9QYXRoLCBmaWx0ZXJUeXBlKGxvY2FsUGF0aCwgZmlsdGVyU3RyaW5nKSwgZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cykpO1xufVxuXG4vKipcbiAqIENsb25lIGEgZ2l0IHJlcG9cbiAqL1xuR2l0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgY3JlYXRlQ2xvbmVUYXNrKCdjbG9uZScsIGNsb25lVGFzaywgLi4uYXJndW1lbnRzKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxuLyoqXG4gKiBNaXJyb3IgYSBnaXQgcmVwb1xuICovXG5HaXQucHJvdG90eXBlLm1pcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgY3JlYXRlQ2xvbmVUYXNrKCdtaXJyb3InLCBjbG9uZU1pcnJvclRhc2ssIC4uLmFyZ3VtZW50cyksXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgKTtcbn07XG5cbi8qKlxuICogTW92ZXMgb25lIG9yIG1vcmUgZmlsZXMgdG8gYSBuZXcgZGVzdGluYXRpb24uXG4gKlxuICogQHNlZSBodHRwczovL2dpdC1zY20uY29tL2RvY3MvZ2l0LW12XG4gKlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGZyb21cbiAqIEBwYXJhbSB7c3RyaW5nfSB0b1xuICovXG5HaXQucHJvdG90eXBlLm12ID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhtb3ZlVGFzayhmcm9tLCB0byksIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpKTtcbn07XG5cbi8qKlxuICogSW50ZXJuYWxseSB1c2VzIHB1bGwgYW5kIHRhZ3MgdG8gZ2V0IHRoZSBsaXN0IG9mIHRhZ3MgdGhlbiBjaGVja3Mgb3V0IHRoZSBsYXRlc3QgdGFnLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFt0aGVuXVxuICovXG5HaXQucHJvdG90eXBlLmNoZWNrb3V0TGF0ZXN0VGFnID0gZnVuY3Rpb24gKHRoZW4pIHtcbiAgIHZhciBnaXQgPSB0aGlzO1xuICAgcmV0dXJuIHRoaXMucHVsbChmdW5jdGlvbiAoKSB7XG4gICAgICBnaXQudGFncyhmdW5jdGlvbiAoZXJyLCB0YWdzKSB7XG4gICAgICAgICBnaXQuY2hlY2tvdXQodGFncy5sYXRlc3QsIHRoZW4pO1xuICAgICAgfSk7XG4gICB9KTtcbn07XG5cbi8qKlxuICogUHVsbCB0aGUgdXBkYXRlZCBjb250ZW50cyBvZiB0aGUgY3VycmVudCByZXBvXG4gKi9cbkdpdC5wcm90b3R5cGUucHVsbCA9IGZ1bmN0aW9uIChyZW1vdGUsIGJyYW5jaCwgb3B0aW9ucywgdGhlbikge1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICBwdWxsVGFzayhcbiAgICAgICAgIGZpbHRlclR5cGUocmVtb3RlLCBmaWx0ZXJTdHJpbmcpLFxuICAgICAgICAgZmlsdGVyVHlwZShicmFuY2gsIGZpbHRlclN0cmluZyksXG4gICAgICAgICBnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKVxuICAgICAgKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxuLyoqXG4gKiBGZXRjaCB0aGUgdXBkYXRlZCBjb250ZW50cyBvZiB0aGUgY3VycmVudCByZXBvLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgIC5mZXRjaCgndXBzdHJlYW0nLCAnbWFzdGVyJykgLy8gZmV0Y2hlcyBmcm9tIG1hc3RlciBvbiByZW1vdGUgbmFtZWQgdXBzdHJlYW1cbiAqICAgLmZldGNoKGZ1bmN0aW9uICgpIHt9KSAvLyBydW5zIGZldGNoIGFnYWluc3QgZGVmYXVsdCByZW1vdGUgYW5kIGJyYW5jaCBhbmQgY2FsbHMgZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3JlbW90ZV1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYnJhbmNoXVxuICovXG5HaXQucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24gKHJlbW90ZSwgYnJhbmNoKSB7XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgIGZldGNoVGFzayhcbiAgICAgICAgIGZpbHRlclR5cGUocmVtb3RlLCBmaWx0ZXJTdHJpbmcpLFxuICAgICAgICAgZmlsdGVyVHlwZShicmFuY2gsIGZpbHRlclN0cmluZyksXG4gICAgICAgICBnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKVxuICAgICAgKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxuLyoqXG4gKiBEaXNhYmxlcy9lbmFibGVzIHRoZSB1c2Ugb2YgdGhlIGNvbnNvbGUgZm9yIHByaW50aW5nIHdhcm5pbmdzIGFuZCBlcnJvcnMsIGJ5IGRlZmF1bHQgbWVzc2FnZXMgYXJlIG5vdCBzaG93biBpblxuICogYSBwcm9kdWN0aW9uIGVudmlyb25tZW50LlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2lsZW5jZVxuICogQHJldHVybnMge0dpdH1cbiAqL1xuR2l0LnByb3RvdHlwZS5zaWxlbnQgPSBmdW5jdGlvbiAoc2lsZW5jZSkge1xuICAgY29uc29sZS53YXJuKFxuICAgICAgJ3NpbXBsZS1naXQgZGVwcmVjYXRpb24gbm90aWNlOiBnaXQuc2lsZW50OiBsb2dnaW5nIHNob3VsZCBiZSBjb25maWd1cmVkIHVzaW5nIHRoZSBgZGVidWdgIGxpYnJhcnkgLyBgREVCVUdgIGVudmlyb25tZW50IHZhcmlhYmxlLCB0aGlzIHdpbGwgYmUgYW4gZXJyb3IgaW4gdmVyc2lvbiAzJ1xuICAgKTtcbiAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBMaXN0IGFsbCB0YWdzLiBXaGVuIHVzaW5nIGdpdCAyLjcuMCBvciBhYm92ZSwgaW5jbHVkZSBhbiBvcHRpb25zIG9iamVjdCB3aXRoIGBcIi0tc29ydFwiOiBcInByb3BlcnR5LW5hbWVcImAgdG9cbiAqIHNvcnQgdGhlIHRhZ3MgYnkgdGhhdCBwcm9wZXJ0eSBpbnN0ZWFkIG9mIHVzaW5nIHRoZSBkZWZhdWx0IHNlbWFudGljIHZlcnNpb25pbmcgc29ydC5cbiAqXG4gKiBOb3RlLCBzdXBwbHlpbmcgdGhpcyBvcHRpb24gd2hlbiBpdCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHlvdXIgR2l0IHZlcnNpb24gd2lsbCBjYXVzZSB0aGUgb3BlcmF0aW9uIHRvIGZhaWwuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3RoZW5dXG4gKi9cbkdpdC5wcm90b3R5cGUudGFncyA9IGZ1bmN0aW9uIChvcHRpb25zLCB0aGVuKSB7XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgIHRhZ0xpc3RUYXNrKGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxuLyoqXG4gKiBSZWJhc2VzIHRoZSBjdXJyZW50IHdvcmtpbmcgY29weS4gT3B0aW9ucyBjYW4gYmUgc3VwcGxpZWQgZWl0aGVyIGFzIGFuIGFycmF5IG9mIHN0cmluZyBwYXJhbWV0ZXJzXG4gKiB0byBiZSBzZW50IHRvIHRoZSBgZ2l0IHJlYmFzZWAgY29tbWFuZCwgb3IgYSBzdGFuZGFyZCBvcHRpb25zIG9iamVjdC5cbiAqL1xuR2l0LnByb3RvdHlwZS5yZWJhc2UgPSBmdW5jdGlvbiAoKSB7XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soWydyZWJhc2UnLCAuLi5nZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKV0pLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG4vKipcbiAqIFJlc2V0IGEgcmVwb1xuICovXG5HaXQucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKG1vZGUpIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgcmVzZXRUYXNrKGdldFJlc2V0TW9kZShtb2RlKSwgZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cykpLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG4vKipcbiAqIFJldmVydCBvbmUgb3IgbW9yZSBjb21taXRzIGluIHRoZSBsb2NhbCB3b3JraW5nIGNvcHlcbiAqL1xuR2l0LnByb3RvdHlwZS5yZXZlcnQgPSBmdW5jdGlvbiAoY29tbWl0KSB7XG4gICBjb25zdCBuZXh0ID0gdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cyk7XG5cbiAgIGlmICh0eXBlb2YgY29tbWl0ICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHRoaXMuX3J1blRhc2soY29uZmlndXJhdGlvbkVycm9yVGFzaygnQ29tbWl0IG11c3QgYmUgYSBzdHJpbmcnKSwgbmV4dCk7XG4gICB9XG5cbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhbJ3JldmVydCcsIC4uLmdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMsIDAsIHRydWUpLCBjb21taXRdKSxcbiAgICAgIG5leHRcbiAgICk7XG59O1xuXG4vKipcbiAqIEFkZCBhIGxpZ2h0d2VpZ2h0IHRhZyB0byB0aGUgaGVhZCBvZiB0aGUgY3VycmVudCBicmFuY2hcbiAqL1xuR2l0LnByb3RvdHlwZS5hZGRUYWcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgY29uc3QgdGFzayA9XG4gICAgICB0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZydcbiAgICAgICAgID8gYWRkVGFnVGFzayhuYW1lKVxuICAgICAgICAgOiBjb25maWd1cmF0aW9uRXJyb3JUYXNrKCdHaXQuYWRkVGFnIHJlcXVpcmVzIGEgdGFnIG5hbWUnKTtcblxuICAgcmV0dXJuIHRoaXMuX3J1blRhc2sodGFzaywgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cykpO1xufTtcblxuLyoqXG4gKiBBZGQgYW4gYW5ub3RhdGVkIHRhZyB0byB0aGUgaGVhZCBvZiB0aGUgY3VycmVudCBicmFuY2hcbiAqL1xuR2l0LnByb3RvdHlwZS5hZGRBbm5vdGF0ZWRUYWcgPSBmdW5jdGlvbiAodGFnTmFtZSwgdGFnTWVzc2FnZSkge1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICBhZGRBbm5vdGF0ZWRUYWdUYXNrKHRhZ05hbWUsIHRhZ01lc3NhZ2UpLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG4vKipcbiAqIERlbGV0ZSBhIGxvY2FsIGJyYW5jaFxuICovXG5HaXQucHJvdG90eXBlLmRlbGV0ZUxvY2FsQnJhbmNoID0gZnVuY3Rpb24gKGJyYW5jaE5hbWUsIGZvcmNlRGVsZXRlLCB0aGVuKSB7XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgIGRlbGV0ZUJyYW5jaFRhc2soYnJhbmNoTmFtZSwgdHlwZW9mIGZvcmNlRGVsZXRlID09PSAnYm9vbGVhbicgPyBmb3JjZURlbGV0ZSA6IGZhbHNlKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxuLyoqXG4gKiBEZWxldGUgb25lIG9yIG1vcmUgbG9jYWwgYnJhbmNoZXNcbiAqL1xuR2l0LnByb3RvdHlwZS5kZWxldGVMb2NhbEJyYW5jaGVzID0gZnVuY3Rpb24gKGJyYW5jaE5hbWVzLCBmb3JjZURlbGV0ZSwgdGhlbikge1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICBkZWxldGVCcmFuY2hlc1Rhc2soYnJhbmNoTmFtZXMsIHR5cGVvZiBmb3JjZURlbGV0ZSA9PT0gJ2Jvb2xlYW4nID8gZm9yY2VEZWxldGUgOiBmYWxzZSksXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgKTtcbn07XG5cbi8qKlxuICogTGlzdCBhbGwgYnJhbmNoZXNcbiAqXG4gKiBAcGFyYW0ge09iamVjdCB8IHN0cmluZ1tdfSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFt0aGVuXVxuICovXG5HaXQucHJvdG90eXBlLmJyYW5jaCA9IGZ1bmN0aW9uIChvcHRpb25zLCB0aGVuKSB7XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgIGJyYW5jaFRhc2soZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cykpLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG4vKipcbiAqIFJldHVybiBsaXN0IG9mIGxvY2FsIGJyYW5jaGVzXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3RoZW5dXG4gKi9cbkdpdC5wcm90b3R5cGUuYnJhbmNoTG9jYWwgPSBmdW5jdGlvbiAodGhlbikge1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soYnJhbmNoTG9jYWxUYXNrKCksIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpKTtcbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgYW55IGNvbW1hbmQgYWdhaW5zdCB0aGUgZ2l0IGJpbmFyeS5cbiAqL1xuR2l0LnByb3RvdHlwZS5yYXcgPSBmdW5jdGlvbiAoY29tbWFuZHMpIHtcbiAgIGNvbnN0IGNyZWF0ZVJlc3RDb21tYW5kcyA9ICFBcnJheS5pc0FycmF5KGNvbW1hbmRzKTtcbiAgIGNvbnN0IGNvbW1hbmQgPSBbXS5zbGljZS5jYWxsKGNyZWF0ZVJlc3RDb21tYW5kcyA/IGFyZ3VtZW50cyA6IGNvbW1hbmRzLCAwKTtcblxuICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb21tYW5kLmxlbmd0aCAmJiBjcmVhdGVSZXN0Q29tbWFuZHM7IGkrKykge1xuICAgICAgaWYgKCFmaWx0ZXJQcmltaXRpdmVzKGNvbW1hbmRbaV0pKSB7XG4gICAgICAgICBjb21tYW5kLnNwbGljZShpLCBjb21tYW5kLmxlbmd0aCAtIGkpO1xuICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICB9XG5cbiAgIGNvbW1hbmQucHVzaCguLi5nZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzLCAwLCB0cnVlKSk7XG5cbiAgIHZhciBuZXh0ID0gdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cyk7XG5cbiAgIGlmICghY29tbWFuZC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICAgY29uZmlndXJhdGlvbkVycm9yVGFzaygnUmF3OiBtdXN0IHN1cHBseSBvbmUgb3IgbW9yZSBjb21tYW5kIHRvIGV4ZWN1dGUnKSxcbiAgICAgICAgIG5leHRcbiAgICAgICk7XG4gICB9XG5cbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soY29tbWFuZCwgdGhpcy5fdHJpbW1lZCksIG5leHQpO1xufTtcblxuR2l0LnByb3RvdHlwZS5zdWJtb2R1bGVBZGQgPSBmdW5jdGlvbiAocmVwbywgcGF0aCwgdGhlbikge1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soYWRkU3ViTW9kdWxlVGFzayhyZXBvLCBwYXRoKSwgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cykpO1xufTtcblxuR2l0LnByb3RvdHlwZS5zdWJtb2R1bGVVcGRhdGUgPSBmdW5jdGlvbiAoYXJncywgdGhlbikge1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICB1cGRhdGVTdWJNb2R1bGVUYXNrKGdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMsIHRydWUpKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxuR2l0LnByb3RvdHlwZS5zdWJtb2R1bGVJbml0ID0gZnVuY3Rpb24gKGFyZ3MsIHRoZW4pIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgaW5pdFN1Yk1vZHVsZVRhc2soZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cywgdHJ1ZSkpLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG5HaXQucHJvdG90eXBlLnN1Yk1vZHVsZSA9IGZ1bmN0aW9uIChvcHRpb25zLCB0aGVuKSB7XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgIHN1Yk1vZHVsZVRhc2soZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cykpLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG5HaXQucHJvdG90eXBlLmxpc3RSZW1vdGUgPSBmdW5jdGlvbiAoKSB7XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgIGxpc3RSZW1vdGVzVGFzayhnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKSksXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgKTtcbn07XG5cbi8qKlxuICogQWRkcyBhIHJlbW90ZSB0byB0aGUgbGlzdCBvZiByZW1vdGVzLlxuICovXG5HaXQucHJvdG90eXBlLmFkZFJlbW90ZSA9IGZ1bmN0aW9uIChyZW1vdGVOYW1lLCByZW1vdGVSZXBvLCB0aGVuKSB7XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgIGFkZFJlbW90ZVRhc2socmVtb3RlTmFtZSwgcmVtb3RlUmVwbywgZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cykpLFxuICAgICAgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cylcbiAgICk7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYW4gZW50cnkgYnkgbmFtZSBmcm9tIHRoZSBsaXN0IG9mIHJlbW90ZXMuXG4gKi9cbkdpdC5wcm90b3R5cGUucmVtb3ZlUmVtb3RlID0gZnVuY3Rpb24gKHJlbW90ZU5hbWUsIHRoZW4pIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKHJlbW92ZVJlbW90ZVRhc2socmVtb3RlTmFtZSksIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpKTtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgY3VycmVudGx5IGF2YWlsYWJsZSByZW1vdGVzLCBzZXR0aW5nIHRoZSBvcHRpb25hbCB2ZXJib3NlIGFyZ3VtZW50IHRvIHRydWUgaW5jbHVkZXMgYWRkaXRpb25hbFxuICogZGV0YWlsIG9uIHRoZSByZW1vdGVzIHRoZW1zZWx2ZXMuXG4gKi9cbkdpdC5wcm90b3R5cGUuZ2V0UmVtb3RlcyA9IGZ1bmN0aW9uICh2ZXJib3NlLCB0aGVuKSB7XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhnZXRSZW1vdGVzVGFzayh2ZXJib3NlID09PSB0cnVlKSwgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cykpO1xufTtcblxuLyoqXG4gKiBDYWxsIGFueSBgZ2l0IHJlbW90ZWAgZnVuY3Rpb24gd2l0aCBhcmd1bWVudHMgcGFzc2VkIGFzIGFuIGFycmF5IG9mIHN0cmluZ3MuXG4gKlxuICogQHBhcmFtIHtzdHJpbmdbXX0gb3B0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW3RoZW5dXG4gKi9cbkdpdC5wcm90b3R5cGUucmVtb3RlID0gZnVuY3Rpb24gKG9wdGlvbnMsIHRoZW4pIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgcmVtb3RlVGFzayhnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKSksXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgKTtcbn07XG5cbi8qKlxuICogQ2FsbCBhbnkgYGdpdCB0YWdgIGZ1bmN0aW9uIHdpdGggYXJndW1lbnRzIHBhc3NlZCBhcyBhbiBhcnJheSBvZiBzdHJpbmdzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nW119IG9wdGlvbnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFt0aGVuXVxuICovXG5HaXQucHJvdG90eXBlLnRhZyA9IGZ1bmN0aW9uIChvcHRpb25zLCB0aGVuKSB7XG4gICBjb25zdCBjb21tYW5kID0gZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cyk7XG5cbiAgIGlmIChjb21tYW5kWzBdICE9PSAndGFnJykge1xuICAgICAgY29tbWFuZC51bnNoaWZ0KCd0YWcnKTtcbiAgIH1cblxuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhjb21tYW5kKSwgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cykpO1xufTtcblxuLyoqXG4gKiBVcGRhdGVzIHJlcG9zaXRvcnkgc2VydmVyIGluZm9cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbdGhlbl1cbiAqL1xuR2l0LnByb3RvdHlwZS51cGRhdGVTZXJ2ZXJJbmZvID0gZnVuY3Rpb24gKHRoZW4pIHtcbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhbJ3VwZGF0ZS1zZXJ2ZXItaW5mbyddKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxuLyoqXG4gKiBQdXNoZXMgdGhlIGN1cnJlbnQgdGFnIGNoYW5nZXMgdG8gYSByZW1vdGUgd2hpY2ggY2FuIGJlIGVpdGhlciBhIFVSTCBvciBuYW1lZCByZW1vdGUuIFdoZW4gbm90IHNwZWNpZmllZCB1c2VzIHRoZVxuICogZGVmYXVsdCBjb25maWd1cmVkIHJlbW90ZSBzcGVjLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcmVtb3RlXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3RoZW5dXG4gKi9cbkdpdC5wcm90b3R5cGUucHVzaFRhZ3MgPSBmdW5jdGlvbiAocmVtb3RlLCB0aGVuKSB7XG4gICBjb25zdCB0YXNrID0gcHVzaFRhZ3NUYXNrKFxuICAgICAgeyByZW1vdGU6IGZpbHRlclR5cGUocmVtb3RlLCBmaWx0ZXJTdHJpbmcpIH0sXG4gICAgICBnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzKVxuICAgKTtcblxuICAgcmV0dXJuIHRoaXMuX3J1blRhc2sodGFzaywgdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3VtZW50cykpO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBuYW1lZCBmaWxlcyBmcm9tIHNvdXJjZSBjb250cm9sLlxuICovXG5HaXQucHJvdG90eXBlLnJtID0gZnVuY3Rpb24gKGZpbGVzKSB7XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soWydybScsICctZicsIC4uLmFzQXJyYXkoZmlsZXMpXSksXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgbmFtZWQgZmlsZXMgZnJvbSBzb3VyY2UgY29udHJvbCBidXQga2VlcHMgdGhlbSBvbiBkaXNrIHJhdGhlciB0aGFuIGRlbGV0aW5nIHRoZW0gZW50aXJlbHkuIFRvXG4gKiBjb21wbGV0ZWx5IHJlbW92ZSB0aGUgZmlsZXMsIHVzZSBgcm1gLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBmaWxlc1xuICovXG5HaXQucHJvdG90eXBlLnJtS2VlcExvY2FsID0gZnVuY3Rpb24gKGZpbGVzKSB7XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgIHN0cmFpZ2h0VGhyb3VnaFN0cmluZ1Rhc2soWydybScsICctLWNhY2hlZCcsIC4uLmFzQXJyYXkoZmlsZXMpXSksXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGxpc3Qgb2Ygb2JqZWN0cyBpbiBhIHRyZWUgYmFzZWQgb24gY29tbWl0IGhhc2guIFBhc3NpbmcgaW4gYW4gb2JqZWN0IGhhc2ggcmV0dXJucyB0aGUgb2JqZWN0J3MgY29udGVudCxcbiAqIHNpemUsIGFuZCB0eXBlLlxuICpcbiAqIFBhc3NpbmcgXCItcFwiIHdpbGwgaW5zdHJ1Y3QgY2F0LWZpbGUgdG8gZGV0ZXJtaW5lIHRoZSBvYmplY3QgdHlwZSwgYW5kIGRpc3BsYXkgaXRzIGZvcm1hdHRlZCBjb250ZW50cy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFt0aGVuXVxuICovXG5HaXQucHJvdG90eXBlLmNhdEZpbGUgPSBmdW5jdGlvbiAob3B0aW9ucywgdGhlbikge1xuICAgcmV0dXJuIHRoaXMuX2NhdEZpbGUoJ3V0Zi04JywgYXJndW1lbnRzKTtcbn07XG5cbkdpdC5wcm90b3R5cGUuYmluYXJ5Q2F0RmlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgIHJldHVybiB0aGlzLl9jYXRGaWxlKCdidWZmZXInLCBhcmd1bWVudHMpO1xufTtcblxuR2l0LnByb3RvdHlwZS5fY2F0RmlsZSA9IGZ1bmN0aW9uIChmb3JtYXQsIGFyZ3MpIHtcbiAgIHZhciBoYW5kbGVyID0gdHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50KGFyZ3MpO1xuICAgdmFyIGNvbW1hbmQgPSBbJ2NhdC1maWxlJ107XG4gICB2YXIgb3B0aW9ucyA9IGFyZ3NbMF07XG5cbiAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgICAgY29uZmlndXJhdGlvbkVycm9yVGFzaygnR2l0LmNhdEZpbGU6IG9wdGlvbnMgbXVzdCBiZSBzdXBwbGllZCBhcyBhbiBhcnJheSBvZiBzdHJpbmdzJyksXG4gICAgICAgICBoYW5kbGVyXG4gICAgICApO1xuICAgfVxuXG4gICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgY29tbWFuZC5wdXNoLmFwcGx5KGNvbW1hbmQsIG9wdGlvbnMpO1xuICAgfVxuXG4gICBjb25zdCB0YXNrID1cbiAgICAgIGZvcm1hdCA9PT0gJ2J1ZmZlcicgPyBzdHJhaWdodFRocm91Z2hCdWZmZXJUYXNrKGNvbW1hbmQpIDogc3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayhjb21tYW5kKTtcblxuICAgcmV0dXJuIHRoaXMuX3J1blRhc2sodGFzaywgaGFuZGxlcik7XG59O1xuXG5HaXQucHJvdG90eXBlLmRpZmYgPSBmdW5jdGlvbiAob3B0aW9ucywgdGhlbikge1xuICAgY29uc3QgdGFzayA9IGZpbHRlclN0cmluZyhvcHRpb25zKVxuICAgICAgPyBjb25maWd1cmF0aW9uRXJyb3JUYXNrKFxuICAgICAgICAgICAnZ2l0LmRpZmY6IHN1cHBseWluZyBvcHRpb25zIGFzIGEgc2luZ2xlIHN0cmluZyBpcyBubyBsb25nZXIgc3VwcG9ydGVkLCBzd2l0Y2ggdG8gYW4gYXJyYXkgb2Ygc3RyaW5ncydcbiAgICAgICAgKVxuICAgICAgOiBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKFsnZGlmZicsIC4uLmdldFRyYWlsaW5nT3B0aW9ucyhhcmd1bWVudHMpXSk7XG5cbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKHRhc2ssIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpKTtcbn07XG5cbkdpdC5wcm90b3R5cGUuZGlmZlN1bW1hcnkgPSBmdW5jdGlvbiAoKSB7XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgIGRpZmZTdW1tYXJ5VGFzayhnZXRUcmFpbGluZ09wdGlvbnMoYXJndW1lbnRzLCAxKSksXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgKTtcbn07XG5cbkdpdC5wcm90b3R5cGUuYXBwbHlQYXRjaCA9IGZ1bmN0aW9uIChwYXRjaGVzKSB7XG4gICBjb25zdCB0YXNrID0gIWZpbHRlclN0cmluZ09yU3RyaW5nQXJyYXkocGF0Y2hlcylcbiAgICAgID8gY29uZmlndXJhdGlvbkVycm9yVGFzayhcbiAgICAgICAgICAgYGdpdC5hcHBseVBhdGNoIHJlcXVpcmVzIG9uZSBvciBtb3JlIHN0cmluZyBwYXRjaGVzIGFzIHRoZSBmaXJzdCBhcmd1bWVudGBcbiAgICAgICAgKVxuICAgICAgOiBhcHBseVBhdGNoVGFzayhhc0FycmF5KHBhdGNoZXMpLCBnZXRUcmFpbGluZ09wdGlvbnMoW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKSk7XG5cbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKHRhc2ssIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpKTtcbn07XG5cbkdpdC5wcm90b3R5cGUucmV2cGFyc2UgPSBmdW5jdGlvbiAoKSB7XG4gICBjb25zdCBjb21tYW5kcyA9IFsncmV2LXBhcnNlJywgLi4uZ2V0VHJhaWxpbmdPcHRpb25zKGFyZ3VtZW50cywgdHJ1ZSldO1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICBzdHJhaWdodFRocm91Z2hTdHJpbmdUYXNrKGNvbW1hbmRzLCB0cnVlKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxuLyoqXG4gKi9cbkdpdC5wcm90b3R5cGUuY2xlYW4gPSBmdW5jdGlvbiAobW9kZSwgb3B0aW9ucywgdGhlbikge1xuICAgY29uc3QgdXNpbmdDbGVhbk9wdGlvbnNBcnJheSA9IGlzQ2xlYW5PcHRpb25zQXJyYXkobW9kZSk7XG4gICBjb25zdCBjbGVhbk1vZGUgPVxuICAgICAgKHVzaW5nQ2xlYW5PcHRpb25zQXJyYXkgJiYgbW9kZS5qb2luKCcnKSkgfHwgZmlsdGVyVHlwZShtb2RlLCBmaWx0ZXJTdHJpbmcpIHx8ICcnO1xuICAgY29uc3QgY3VzdG9tQXJncyA9IGdldFRyYWlsaW5nT3B0aW9ucyhbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgdXNpbmdDbGVhbk9wdGlvbnNBcnJheSA/IDEgOiAwKSk7XG5cbiAgIHJldHVybiB0aGlzLl9ydW5UYXNrKFxuICAgICAgY2xlYW5XaXRoT3B0aW9uc1Rhc2soY2xlYW5Nb2RlLCBjdXN0b21BcmdzKSxcbiAgICAgIHRyYWlsaW5nRnVuY3Rpb25Bcmd1bWVudChhcmd1bWVudHMpXG4gICApO1xufTtcblxuR2l0LnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24gKHRoZW4pIHtcbiAgIGNvbnN0IHRhc2sgPSB7XG4gICAgICBjb21tYW5kczogW10sXG4gICAgICBmb3JtYXQ6ICd1dGYtOCcsXG4gICAgICBwYXJzZXIoKSB7XG4gICAgICAgICBpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoZW4oKTtcbiAgICAgICAgIH1cbiAgICAgIH0sXG4gICB9O1xuXG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayh0YXNrKTtcbn07XG5cbi8qKlxuICogQ2xlYXJzIHRoZSBxdWV1ZSBvZiBwZW5kaW5nIGNvbW1hbmRzIGFuZCByZXR1cm5zIHRoZSB3cmFwcGVyIGluc3RhbmNlIGZvciBjaGFpbmluZy5cbiAqXG4gKiBAcmV0dXJucyB7R2l0fVxuICovXG5HaXQucHJvdG90eXBlLmNsZWFyUXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAvLyBUT0RPOlxuICAgLy8gdGhpcy5fZXhlY3V0b3IuY2xlYXIoKTtcbiAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIHBhdGhuYW1lIG9yIHBhdGhuYW1lcyBhcmUgZXhjbHVkZWQgYnkgLmdpdGlnbm9yZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBwYXRobmFtZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFt0aGVuXVxuICovXG5HaXQucHJvdG90eXBlLmNoZWNrSWdub3JlID0gZnVuY3Rpb24gKHBhdGhuYW1lcywgdGhlbikge1xuICAgcmV0dXJuIHRoaXMuX3J1blRhc2soXG4gICAgICBjaGVja0lnbm9yZVRhc2soYXNBcnJheShmaWx0ZXJUeXBlKHBhdGhuYW1lcywgZmlsdGVyU3RyaW5nT3JTdHJpbmdBcnJheSwgW10pKSksXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgKTtcbn07XG5cbkdpdC5wcm90b3R5cGUuY2hlY2tJc1JlcG8gPSBmdW5jdGlvbiAoY2hlY2tUeXBlLCB0aGVuKSB7XG4gICByZXR1cm4gdGhpcy5fcnVuVGFzayhcbiAgICAgIGNoZWNrSXNSZXBvVGFzayhmaWx0ZXJUeXBlKGNoZWNrVHlwZSwgZmlsdGVyU3RyaW5nKSksXG4gICAgICB0cmFpbGluZ0Z1bmN0aW9uQXJndW1lbnQoYXJndW1lbnRzKVxuICAgKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR2l0O1xuIiwgImltcG9ydCB7IHBhdGhzcGVjIH0gZnJvbSAnLi9hcmdzL3BhdGhzcGVjJztcbmltcG9ydCB7IEdpdENvbnN0cnVjdEVycm9yIH0gZnJvbSAnLi9lcnJvcnMvZ2l0LWNvbnN0cnVjdC1lcnJvcic7XG5pbXBvcnQgeyBHaXRFcnJvciB9IGZyb20gJy4vZXJyb3JzL2dpdC1lcnJvcic7XG5pbXBvcnQgeyBHaXRQbHVnaW5FcnJvciB9IGZyb20gJy4vZXJyb3JzL2dpdC1wbHVnaW4tZXJyb3InO1xuaW1wb3J0IHsgR2l0UmVzcG9uc2VFcnJvciB9IGZyb20gJy4vZXJyb3JzL2dpdC1yZXNwb25zZS1lcnJvcic7XG5pbXBvcnQgeyBUYXNrQ29uZmlndXJhdGlvbkVycm9yIH0gZnJvbSAnLi9lcnJvcnMvdGFzay1jb25maWd1cmF0aW9uLWVycm9yJztcbmltcG9ydCB7IENoZWNrUmVwb0FjdGlvbnMgfSBmcm9tICcuL3Rhc2tzL2NoZWNrLWlzLXJlcG8nO1xuaW1wb3J0IHsgQ2xlYW5PcHRpb25zIH0gZnJvbSAnLi90YXNrcy9jbGVhbic7XG5pbXBvcnQgeyBHaXRDb25maWdTY29wZSB9IGZyb20gJy4vdGFza3MvY29uZmlnJztcbmltcG9ydCB7IERpZmZOYW1lU3RhdHVzIH0gZnJvbSAnLi90YXNrcy9kaWZmLW5hbWUtc3RhdHVzJztcbmltcG9ydCB7IGdyZXBRdWVyeUJ1aWxkZXIgfSBmcm9tICcuL3Rhc2tzL2dyZXAnO1xuaW1wb3J0IHsgUmVzZXRNb2RlIH0gZnJvbSAnLi90YXNrcy9yZXNldCc7XG5cbmV4cG9ydCB7XG4gICBDaGVja1JlcG9BY3Rpb25zLFxuICAgQ2xlYW5PcHRpb25zLFxuICAgRGlmZk5hbWVTdGF0dXMsXG4gICBHaXRDb25maWdTY29wZSxcbiAgIEdpdENvbnN0cnVjdEVycm9yLFxuICAgR2l0RXJyb3IsXG4gICBHaXRQbHVnaW5FcnJvcixcbiAgIEdpdFJlc3BvbnNlRXJyb3IsXG4gICBSZXNldE1vZGUsXG4gICBUYXNrQ29uZmlndXJhdGlvbkVycm9yLFxuICAgZ3JlcFF1ZXJ5QnVpbGRlcixcbiAgIHBhdGhzcGVjLFxufTtcbiIsICJpbXBvcnQgeyBHaXRFcnJvciB9IGZyb20gJy4vZ2l0LWVycm9yJztcbmltcG9ydCB7IFNpbXBsZUdpdE9wdGlvbnMgfSBmcm9tICcuLi90eXBlcyc7XG5cbi8qKlxuICogVGhlIGBHaXRDb25zdHJ1Y3RFcnJvcmAgaXMgdGhyb3duIHdoZW4gYW4gZXJyb3Igb2NjdXJzIGluIHRoZSBjb25zdHJ1Y3RvclxuICogb2YgdGhlIGBzaW1wbGUtZ2l0YCBpbnN0YW5jZSBpdHNlbGYuIE1vc3QgY29tbW9ubHkgYXMgYSByZXN1bHQgb2YgdXNpbmdcbiAqIGEgYGJhc2VEaXJgIG9wdGlvbiB0aGF0IHBvaW50cyB0byBhIGZvbGRlciB0aGF0IGVpdGhlciBkb2VzIG5vdCBleGlzdCxcbiAqIG9yIGNhbm5vdCBiZSByZWFkIGJ5IHRoZSB1c2VyIHRoZSBub2RlIHNjcmlwdCBpcyBydW5uaW5nIGFzLlxuICpcbiAqIENoZWNrIHRoZSBgLm1lc3NhZ2VgIHByb3BlcnR5IGZvciBtb3JlIGRldGFpbCBpbmNsdWRpbmcgdGhlIHByb3BlcnRpZXNcbiAqIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IuXG4gKi9cbmV4cG9ydCBjbGFzcyBHaXRDb25zdHJ1Y3RFcnJvciBleHRlbmRzIEdpdEVycm9yIHtcbiAgIGNvbnN0cnVjdG9yKFxuICAgICAgcHVibGljIHJlYWRvbmx5IGNvbmZpZzogU2ltcGxlR2l0T3B0aW9ucyxcbiAgICAgIG1lc3NhZ2U6IHN0cmluZ1xuICAgKSB7XG4gICAgICBzdXBlcih1bmRlZmluZWQsIG1lc3NhZ2UpO1xuICAgfVxufVxuIiwgImltcG9ydCB7IFNpbXBsZUdpdE9wdGlvbnMsIFNpbXBsZUdpdFRhc2sgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBHaXRFcnJvciB9IGZyb20gJy4vZ2l0LWVycm9yJztcblxuZXhwb3J0IGNsYXNzIEdpdFBsdWdpbkVycm9yIGV4dGVuZHMgR2l0RXJyb3Ige1xuICAgY29uc3RydWN0b3IoXG4gICAgICBwdWJsaWMgdGFzaz86IFNpbXBsZUdpdFRhc2s8YW55PixcbiAgICAgIHB1YmxpYyByZWFkb25seSBwbHVnaW4/OiBrZXlvZiBTaW1wbGVHaXRPcHRpb25zLFxuICAgICAgbWVzc2FnZT86IHN0cmluZ1xuICAgKSB7XG4gICAgICBzdXBlcih0YXNrLCBtZXNzYWdlKTtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7XG4gICB9XG59XG4iLCAiaW1wb3J0IHsgU2ltcGxlR2l0T3B0aW9ucyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IFNpbXBsZUdpdFBsdWdpbiB9IGZyb20gJy4vc2ltcGxlLWdpdC1wbHVnaW4nO1xuaW1wb3J0IHsgR2l0UGx1Z2luRXJyb3IgfSBmcm9tICcuLi9lcnJvcnMvZ2l0LXBsdWdpbi1lcnJvcic7XG5cbmV4cG9ydCBmdW5jdGlvbiBhYm9ydFBsdWdpbihzaWduYWw6IFNpbXBsZUdpdE9wdGlvbnNbJ2Fib3J0J10pIHtcbiAgIGlmICghc2lnbmFsKSB7XG4gICAgICByZXR1cm47XG4gICB9XG5cbiAgIGNvbnN0IG9uU3Bhd25BZnRlcjogU2ltcGxlR2l0UGx1Z2luPCdzcGF3bi5hZnRlcic+ID0ge1xuICAgICAgdHlwZTogJ3NwYXduLmFmdGVyJyxcbiAgICAgIGFjdGlvbihfZGF0YSwgY29udGV4dCkge1xuICAgICAgICAgZnVuY3Rpb24ga2lsbCgpIHtcbiAgICAgICAgICAgIGNvbnRleHQua2lsbChuZXcgR2l0UGx1Z2luRXJyb3IodW5kZWZpbmVkLCAnYWJvcnQnLCAnQWJvcnQgc2lnbmFsIHJlY2VpdmVkJykpO1xuICAgICAgICAgfVxuXG4gICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBraWxsKTtcblxuICAgICAgICAgY29udGV4dC5zcGF3bmVkLm9uKCdjbG9zZScsICgpID0+IHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGtpbGwpKTtcbiAgICAgIH0sXG4gICB9O1xuXG4gICBjb25zdCBvblNwYXduQmVmb3JlOiBTaW1wbGVHaXRQbHVnaW48J3NwYXduLmJlZm9yZSc+ID0ge1xuICAgICAgdHlwZTogJ3NwYXduLmJlZm9yZScsXG4gICAgICBhY3Rpb24oX2RhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgY29udGV4dC5raWxsKG5ldyBHaXRQbHVnaW5FcnJvcih1bmRlZmluZWQsICdhYm9ydCcsICdBYm9ydCBhbHJlYWR5IHNpZ25hbGVkJykpO1xuICAgICAgICAgfVxuICAgICAgfSxcbiAgIH07XG5cbiAgIHJldHVybiBbb25TcGF3bkJlZm9yZSwgb25TcGF3bkFmdGVyXTtcbn1cbiIsICJpbXBvcnQgdHlwZSB7IFNpbXBsZUdpdFBsdWdpbiB9IGZyb20gJy4vc2ltcGxlLWdpdC1wbHVnaW4nO1xuXG5pbXBvcnQgeyBHaXRQbHVnaW5FcnJvciB9IGZyb20gJy4uL2Vycm9ycy9naXQtcGx1Z2luLWVycm9yJztcbmltcG9ydCB0eXBlIHsgU2ltcGxlR2l0UGx1Z2luQ29uZmlnIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5mdW5jdGlvbiBpc0NvbmZpZ1N3aXRjaChhcmc6IHN0cmluZyB8IHVua25vd24pIHtcbiAgIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyAmJiBhcmcudHJpbSgpLnRvTG93ZXJDYXNlKCkgPT09ICctYyc7XG59XG5cbmZ1bmN0aW9uIHByZXZlbnRQcm90b2NvbE92ZXJyaWRlKGFyZzogc3RyaW5nLCBuZXh0OiBzdHJpbmcpIHtcbiAgIGlmICghaXNDb25maWdTd2l0Y2goYXJnKSkge1xuICAgICAgcmV0dXJuO1xuICAgfVxuXG4gICBpZiAoIS9eXFxzKnByb3RvY29sKC5bYS16XSspPy5hbGxvdy8udGVzdChuZXh0KSkge1xuICAgICAgcmV0dXJuO1xuICAgfVxuXG4gICB0aHJvdyBuZXcgR2l0UGx1Z2luRXJyb3IoXG4gICAgICB1bmRlZmluZWQsXG4gICAgICAndW5zYWZlJyxcbiAgICAgICdDb25maWd1cmluZyBwcm90b2NvbC5hbGxvdyBpcyBub3QgcGVybWl0dGVkIHdpdGhvdXQgZW5hYmxpbmcgYWxsb3dVbnNhZmVFeHRQcm90b2NvbCdcbiAgICk7XG59XG5cbmZ1bmN0aW9uIHByZXZlbnRVcGxvYWRQYWNrKGFyZzogc3RyaW5nLCBtZXRob2Q6IHN0cmluZykge1xuICAgaWYgKC9eXFxzKi0tKHVwbG9hZHxyZWNlaXZlKS1wYWNrLy50ZXN0KGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBHaXRQbHVnaW5FcnJvcihcbiAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICd1bnNhZmUnLFxuICAgICAgICAgYFVzZSBvZiAtLXVwbG9hZC1wYWNrIG9yIC0tcmVjZWl2ZS1wYWNrIGlzIG5vdCBwZXJtaXR0ZWQgd2l0aG91dCBlbmFibGluZyBhbGxvd1Vuc2FmZVBhY2tgXG4gICAgICApO1xuICAgfVxuXG4gICBpZiAobWV0aG9kID09PSAnY2xvbmUnICYmIC9eXFxzKi11XFxiLy50ZXN0KGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBHaXRQbHVnaW5FcnJvcihcbiAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICd1bnNhZmUnLFxuICAgICAgICAgYFVzZSBvZiBjbG9uZSB3aXRoIG9wdGlvbiAtdSBpcyBub3QgcGVybWl0dGVkIHdpdGhvdXQgZW5hYmxpbmcgYWxsb3dVbnNhZmVQYWNrYFxuICAgICAgKTtcbiAgIH1cblxuICAgaWYgKG1ldGhvZCA9PT0gJ3B1c2gnICYmIC9eXFxzKi0tZXhlY1xcYi8udGVzdChhcmcpKSB7XG4gICAgICB0aHJvdyBuZXcgR2l0UGx1Z2luRXJyb3IoXG4gICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAndW5zYWZlJyxcbiAgICAgICAgIGBVc2Ugb2YgcHVzaCB3aXRoIG9wdGlvbiAtLWV4ZWMgaXMgbm90IHBlcm1pdHRlZCB3aXRob3V0IGVuYWJsaW5nIGFsbG93VW5zYWZlUGFja2BcbiAgICAgICk7XG4gICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBibG9ja1Vuc2FmZU9wZXJhdGlvbnNQbHVnaW4oe1xuICAgYWxsb3dVbnNhZmVQcm90b2NvbE92ZXJyaWRlID0gZmFsc2UsXG4gICBhbGxvd1Vuc2FmZVBhY2sgPSBmYWxzZSxcbn06IFNpbXBsZUdpdFBsdWdpbkNvbmZpZ1sndW5zYWZlJ10gPSB7fSk6IFNpbXBsZUdpdFBsdWdpbjwnc3Bhd24uYXJncyc+IHtcbiAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnc3Bhd24uYXJncycsXG4gICAgICBhY3Rpb24oYXJncywgY29udGV4dCkge1xuICAgICAgICAgYXJncy5mb3JFYWNoKChjdXJyZW50LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IGluZGV4IDwgYXJncy5sZW5ndGggPyBhcmdzW2luZGV4ICsgMV0gOiAnJztcblxuICAgICAgICAgICAgYWxsb3dVbnNhZmVQcm90b2NvbE92ZXJyaWRlIHx8IHByZXZlbnRQcm90b2NvbE92ZXJyaWRlKGN1cnJlbnQsIG5leHQpO1xuICAgICAgICAgICAgYWxsb3dVbnNhZmVQYWNrIHx8IHByZXZlbnRVcGxvYWRQYWNrKGN1cnJlbnQsIGNvbnRleHQubWV0aG9kKTtcbiAgICAgICAgIH0pO1xuXG4gICAgICAgICByZXR1cm4gYXJncztcbiAgICAgIH0sXG4gICB9O1xufVxuIiwgImltcG9ydCB7IHByZWZpeGVkQXJyYXkgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBTaW1wbGVHaXRQbHVnaW4gfSBmcm9tICcuL3NpbXBsZS1naXQtcGx1Z2luJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbW1hbmRDb25maWdQcmVmaXhpbmdQbHVnaW4oXG4gICBjb25maWd1cmF0aW9uOiBzdHJpbmdbXVxuKTogU2ltcGxlR2l0UGx1Z2luPCdzcGF3bi5hcmdzJz4ge1xuICAgY29uc3QgcHJlZml4ID0gcHJlZml4ZWRBcnJheShjb25maWd1cmF0aW9uLCAnLWMnKTtcblxuICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdzcGF3bi5hcmdzJyxcbiAgICAgIGFjdGlvbihkYXRhKSB7XG4gICAgICAgICByZXR1cm4gWy4uLnByZWZpeCwgLi4uZGF0YV07XG4gICAgICB9LFxuICAgfTtcbn1cbiIsICJpbXBvcnQgeyBkZWZlcnJlZCwgRGVmZXJyZWRQcm9taXNlIH0gZnJvbSAnQGt3c2l0ZXMvcHJvbWlzZS1kZWZlcnJlZCc7XG5pbXBvcnQgeyBTaW1wbGVHaXRQbHVnaW5Db25maWcgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBkZWxheSB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IFNpbXBsZUdpdFBsdWdpbiB9IGZyb20gJy4vc2ltcGxlLWdpdC1wbHVnaW4nO1xuXG5jb25zdCBuZXZlciA9IGRlZmVycmVkKCkucHJvbWlzZTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBsZXRpb25EZXRlY3Rpb25QbHVnaW4oe1xuICAgb25DbG9zZSA9IHRydWUsXG4gICBvbkV4aXQgPSA1MCxcbn06IFNpbXBsZUdpdFBsdWdpbkNvbmZpZ1snY29tcGxldGlvbiddID0ge30pOiBTaW1wbGVHaXRQbHVnaW48J3NwYXduLmFmdGVyJz4ge1xuICAgZnVuY3Rpb24gY3JlYXRlRXZlbnRzKCkge1xuICAgICAgbGV0IGV4aXRDb2RlID0gLTE7XG4gICAgICBjb25zdCBldmVudHMgPSB7XG4gICAgICAgICBjbG9zZTogZGVmZXJyZWQoKSxcbiAgICAgICAgIGNsb3NlVGltZW91dDogZGVmZXJyZWQoKSxcbiAgICAgICAgIGV4aXQ6IGRlZmVycmVkKCksXG4gICAgICAgICBleGl0VGltZW91dDogZGVmZXJyZWQoKSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IFByb21pc2UucmFjZShbXG4gICAgICAgICBvbkNsb3NlID09PSBmYWxzZSA/IG5ldmVyIDogZXZlbnRzLmNsb3NlVGltZW91dC5wcm9taXNlLFxuICAgICAgICAgb25FeGl0ID09PSBmYWxzZSA/IG5ldmVyIDogZXZlbnRzLmV4aXRUaW1lb3V0LnByb21pc2UsXG4gICAgICBdKTtcblxuICAgICAgY29uZmlndXJlVGltZW91dChvbkNsb3NlLCBldmVudHMuY2xvc2UsIGV2ZW50cy5jbG9zZVRpbWVvdXQpO1xuICAgICAgY29uZmlndXJlVGltZW91dChvbkV4aXQsIGV2ZW50cy5leGl0LCBldmVudHMuZXhpdFRpbWVvdXQpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAgY2xvc2UoY29kZTogbnVtYmVyKSB7XG4gICAgICAgICAgICBleGl0Q29kZSA9IGNvZGU7XG4gICAgICAgICAgICBldmVudHMuY2xvc2UuZG9uZSgpO1xuICAgICAgICAgfSxcbiAgICAgICAgIGV4aXQoY29kZTogbnVtYmVyKSB7XG4gICAgICAgICAgICBleGl0Q29kZSA9IGNvZGU7XG4gICAgICAgICAgICBldmVudHMuZXhpdC5kb25lKCk7XG4gICAgICAgICB9LFxuICAgICAgICAgZ2V0IGV4aXRDb2RlKCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4aXRDb2RlO1xuICAgICAgICAgfSxcbiAgICAgICAgIHJlc3VsdCxcbiAgICAgIH07XG4gICB9XG5cbiAgIGZ1bmN0aW9uIGNvbmZpZ3VyZVRpbWVvdXQoXG4gICAgICBmbGFnOiBib29sZWFuIHwgbnVtYmVyLFxuICAgICAgZXZlbnQ6IERlZmVycmVkUHJvbWlzZTx2b2lkPixcbiAgICAgIHRpbWVvdXQ6IERlZmVycmVkUHJvbWlzZTx2b2lkPlxuICAgKSB7XG4gICAgICBpZiAoZmxhZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgKGZsYWcgPT09IHRydWUgPyBldmVudC5wcm9taXNlIDogZXZlbnQucHJvbWlzZS50aGVuKCgpID0+IGRlbGF5KGZsYWcpKSkudGhlbih0aW1lb3V0LmRvbmUpO1xuICAgfVxuXG4gICByZXR1cm4ge1xuICAgICAgdHlwZTogJ3NwYXduLmFmdGVyJyxcbiAgICAgIGFzeW5jIGFjdGlvbihfZGF0YSwgeyBzcGF3bmVkLCBjbG9zZSB9KSB7XG4gICAgICAgICBjb25zdCBldmVudHMgPSBjcmVhdGVFdmVudHMoKTtcblxuICAgICAgICAgbGV0IGRlZmVyQ2xvc2UgPSB0cnVlO1xuICAgICAgICAgbGV0IHF1aWNrQ2xvc2UgPSAoKSA9PiB2b2lkIChkZWZlckNsb3NlID0gZmFsc2UpO1xuXG4gICAgICAgICBzcGF3bmVkLnN0ZG91dD8ub24oJ2RhdGEnLCBxdWlja0Nsb3NlKTtcbiAgICAgICAgIHNwYXduZWQuc3RkZXJyPy5vbignZGF0YScsIHF1aWNrQ2xvc2UpO1xuICAgICAgICAgc3Bhd25lZC5vbignZXJyb3InLCBxdWlja0Nsb3NlKTtcblxuICAgICAgICAgc3Bhd25lZC5vbignY2xvc2UnLCAoY29kZTogbnVtYmVyKSA9PiBldmVudHMuY2xvc2UoY29kZSkpO1xuICAgICAgICAgc3Bhd25lZC5vbignZXhpdCcsIChjb2RlOiBudW1iZXIpID0+IGV2ZW50cy5leGl0KGNvZGUpKTtcblxuICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGV2ZW50cy5yZXN1bHQ7XG4gICAgICAgICAgICBpZiAoZGVmZXJDbG9zZSkge1xuICAgICAgICAgICAgICAgYXdhaXQgZGVsYXkoNTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xvc2UoZXZlbnRzLmV4aXRDb2RlKTtcbiAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY2xvc2UoZXZlbnRzLmV4aXRDb2RlLCBlcnIgYXMgRXJyb3IpO1xuICAgICAgICAgfVxuICAgICAgfSxcbiAgIH07XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBTaW1wbGVHaXRPcHRpb25zIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQgeyBHaXRQbHVnaW5FcnJvciB9IGZyb20gJy4uL2Vycm9ycy9naXQtcGx1Z2luLWVycm9yJztcbmltcG9ydCB7IGFzQXJyYXkgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBQbHVnaW5TdG9yZSB9IGZyb20gJy4vcGx1Z2luLXN0b3JlJztcblxuY29uc3QgV1JPTkdfTlVNQkVSX0VSUiA9IGBJbnZhbGlkIHZhbHVlIHN1cHBsaWVkIGZvciBjdXN0b20gYmluYXJ5LCByZXF1aXJlcyBhIHNpbmdsZSBzdHJpbmcgb3IgYW4gYXJyYXkgY29udGFpbmluZyBlaXRoZXIgb25lIG9yIHR3byBzdHJpbmdzYDtcbmNvbnN0IFdST05HX0NIQVJTX0VSUiA9IGBJbnZhbGlkIHZhbHVlIHN1cHBsaWVkIGZvciBjdXN0b20gYmluYXJ5LCByZXN0cmljdGVkIGNoYXJhY3RlcnMgbXVzdCBiZSByZW1vdmVkIG9yIHN1cHBseSB0aGUgdW5zYWZlLmFsbG93VW5zYWZlQ3VzdG9tQmluYXJ5IG9wdGlvbmA7XG5cbmZ1bmN0aW9uIGlzQmFkQXJndW1lbnQoYXJnOiBzdHJpbmcpIHtcbiAgIHJldHVybiAhYXJnIHx8ICEvXihbYS16XTopPyhbYS16MC05Ly5cXFxcXy1dKykkL2kudGVzdChhcmcpO1xufVxuXG5mdW5jdGlvbiB0b0JpbmFyeUNvbmZpZyhcbiAgIGlucHV0OiBzdHJpbmdbXSxcbiAgIGFsbG93VW5zYWZlOiBib29sZWFuXG4pOiB7IGJpbmFyeTogc3RyaW5nOyBwcmVmaXg/OiBzdHJpbmcgfSB7XG4gICBpZiAoaW5wdXQubGVuZ3RoIDwgMSB8fCBpbnB1dC5sZW5ndGggPiAyKSB7XG4gICAgICB0aHJvdyBuZXcgR2l0UGx1Z2luRXJyb3IodW5kZWZpbmVkLCAnYmluYXJ5JywgV1JPTkdfTlVNQkVSX0VSUik7XG4gICB9XG5cbiAgIGNvbnN0IGlzQmFkID0gaW5wdXQuc29tZShpc0JhZEFyZ3VtZW50KTtcbiAgIGlmIChpc0JhZCkge1xuICAgICAgaWYgKGFsbG93VW5zYWZlKSB7XG4gICAgICAgICBjb25zb2xlLndhcm4oV1JPTkdfQ0hBUlNfRVJSKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICB0aHJvdyBuZXcgR2l0UGx1Z2luRXJyb3IodW5kZWZpbmVkLCAnYmluYXJ5JywgV1JPTkdfQ0hBUlNfRVJSKTtcbiAgICAgIH1cbiAgIH1cblxuICAgY29uc3QgW2JpbmFyeSwgcHJlZml4XSA9IGlucHV0O1xuICAgcmV0dXJuIHtcbiAgICAgIGJpbmFyeSxcbiAgICAgIHByZWZpeCxcbiAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjdXN0b21CaW5hcnlQbHVnaW4oXG4gICBwbHVnaW5zOiBQbHVnaW5TdG9yZSxcbiAgIGlucHV0OiBTaW1wbGVHaXRPcHRpb25zWydiaW5hcnknXSA9IFsnZ2l0J10sXG4gICBhbGxvd1Vuc2FmZSA9IGZhbHNlXG4pIHtcbiAgIGxldCBjb25maWcgPSB0b0JpbmFyeUNvbmZpZyhhc0FycmF5KGlucHV0KSwgYWxsb3dVbnNhZmUpO1xuXG4gICBwbHVnaW5zLm9uKCdiaW5hcnknLCAoaW5wdXQpID0+IHtcbiAgICAgIGNvbmZpZyA9IHRvQmluYXJ5Q29uZmlnKGFzQXJyYXkoaW5wdXQpLCBhbGxvd1Vuc2FmZSk7XG4gICB9KTtcblxuICAgcGx1Z2lucy5hcHBlbmQoJ3NwYXduLmJpbmFyeScsICgpID0+IHtcbiAgICAgIHJldHVybiBjb25maWcuYmluYXJ5O1xuICAgfSk7XG5cbiAgIHBsdWdpbnMuYXBwZW5kKCdzcGF3bi5hcmdzJywgKGRhdGEpID0+IHtcbiAgICAgIHJldHVybiBjb25maWcucHJlZml4ID8gW2NvbmZpZy5wcmVmaXgsIC4uLmRhdGFdIDogZGF0YTtcbiAgIH0pO1xufVxuIiwgImltcG9ydCB7IEdpdEVycm9yIH0gZnJvbSAnLi4vZXJyb3JzL2dpdC1lcnJvcic7XG5pbXBvcnQgeyBHaXRFeGVjdXRvclJlc3VsdCwgU2ltcGxlR2l0UGx1Z2luQ29uZmlnIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgU2ltcGxlR2l0UGx1Z2luIH0gZnJvbSAnLi9zaW1wbGUtZ2l0LXBsdWdpbic7XG5cbnR5cGUgVGFza1Jlc3VsdCA9IE9taXQ8R2l0RXhlY3V0b3JSZXN1bHQsICdyZWplY3Rpb24nPjtcblxuZnVuY3Rpb24gaXNUYXNrRXJyb3IocmVzdWx0OiBUYXNrUmVzdWx0KSB7XG4gICByZXR1cm4gISEocmVzdWx0LmV4aXRDb2RlICYmIHJlc3VsdC5zdGRFcnIubGVuZ3RoKTtcbn1cblxuZnVuY3Rpb24gZ2V0RXJyb3JNZXNzYWdlKHJlc3VsdDogVGFza1Jlc3VsdCkge1xuICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoWy4uLnJlc3VsdC5zdGRPdXQsIC4uLnJlc3VsdC5zdGRFcnJdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVycm9yRGV0ZWN0aW9uSGFuZGxlcihcbiAgIG92ZXJ3cml0ZSA9IGZhbHNlLFxuICAgaXNFcnJvciA9IGlzVGFza0Vycm9yLFxuICAgZXJyb3JNZXNzYWdlOiAocmVzdWx0OiBUYXNrUmVzdWx0KSA9PiBCdWZmZXIgfCBFcnJvciA9IGdldEVycm9yTWVzc2FnZVxuKSB7XG4gICByZXR1cm4gKGVycm9yOiBCdWZmZXIgfCBFcnJvciB8IHVuZGVmaW5lZCwgcmVzdWx0OiBUYXNrUmVzdWx0KSA9PiB7XG4gICAgICBpZiAoKCFvdmVyd3JpdGUgJiYgZXJyb3IpIHx8ICFpc0Vycm9yKHJlc3VsdCkpIHtcbiAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVycm9yTWVzc2FnZShyZXN1bHQpO1xuICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVycm9yRGV0ZWN0aW9uUGx1Z2luKFxuICAgY29uZmlnOiBTaW1wbGVHaXRQbHVnaW5Db25maWdbJ2Vycm9ycyddXG4pOiBTaW1wbGVHaXRQbHVnaW48J3Rhc2suZXJyb3InPiB7XG4gICByZXR1cm4ge1xuICAgICAgdHlwZTogJ3Rhc2suZXJyb3InLFxuICAgICAgYWN0aW9uKGRhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgIGNvbnN0IGVycm9yID0gY29uZmlnKGRhdGEuZXJyb3IsIHtcbiAgICAgICAgICAgIHN0ZEVycjogY29udGV4dC5zdGRFcnIsXG4gICAgICAgICAgICBzdGRPdXQ6IGNvbnRleHQuc3RkT3V0LFxuICAgICAgICAgICAgZXhpdENvZGU6IGNvbnRleHQuZXhpdENvZGUsXG4gICAgICAgICB9KTtcblxuICAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihlcnJvcikpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yOiBuZXcgR2l0RXJyb3IodW5kZWZpbmVkLCBlcnJvci50b1N0cmluZygndXRmLTgnKSkgfTtcbiAgICAgICAgIH1cblxuICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgfTtcbiAgICAgIH0sXG4gICB9O1xufVxuIiwgImltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ25vZGU6ZXZlbnRzJztcblxuaW1wb3J0IHR5cGUge1xuICAgU2ltcGxlR2l0UGx1Z2luLFxuICAgU2ltcGxlR2l0UGx1Z2luVHlwZSxcbiAgIFNpbXBsZUdpdFBsdWdpblR5cGVzLFxufSBmcm9tICcuL3NpbXBsZS1naXQtcGx1Z2luJztcbmltcG9ydCB7IGFwcGVuZCwgYXNBcnJheSB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB0eXBlIHsgU2ltcGxlR2l0UGx1Z2luQ29uZmlnIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgUGx1Z2luU3RvcmUge1xuICAgcHJpdmF0ZSBwbHVnaW5zOiBTZXQ8U2ltcGxlR2l0UGx1Z2luPFNpbXBsZUdpdFBsdWdpblR5cGU+PiA9IG5ldyBTZXQoKTtcbiAgIHByaXZhdGUgZXZlbnRzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICBvbjxLIGV4dGVuZHMga2V5b2YgU2ltcGxlR2l0UGx1Z2luQ29uZmlnPihcbiAgICAgIHR5cGU6IEssXG4gICAgICBsaXN0ZW5lcjogKGRhdGE6IFNpbXBsZUdpdFBsdWdpbkNvbmZpZ1tLXSkgPT4gdm9pZFxuICAgKSB7XG4gICAgICB0aGlzLmV2ZW50cy5vbih0eXBlLCBsaXN0ZW5lcik7XG4gICB9XG5cbiAgIHJlY29uZmlndXJlPEsgZXh0ZW5kcyBrZXlvZiBTaW1wbGVHaXRQbHVnaW5Db25maWc+KHR5cGU6IEssIGRhdGE6IFNpbXBsZUdpdFBsdWdpbkNvbmZpZ1tLXSkge1xuICAgICAgdGhpcy5ldmVudHMuZW1pdCh0eXBlLCBkYXRhKTtcbiAgIH1cblxuICAgcHVibGljIGFwcGVuZDxUIGV4dGVuZHMgU2ltcGxlR2l0UGx1Z2luVHlwZT4odHlwZTogVCwgYWN0aW9uOiBTaW1wbGVHaXRQbHVnaW48VD5bJ2FjdGlvbiddKSB7XG4gICAgICBjb25zdCBwbHVnaW4gPSBhcHBlbmQodGhpcy5wbHVnaW5zLCB7IHR5cGUsIGFjdGlvbiB9KTtcblxuICAgICAgcmV0dXJuICgpID0+IHRoaXMucGx1Z2lucy5kZWxldGUocGx1Z2luKTtcbiAgIH1cblxuICAgcHVibGljIGFkZDxUIGV4dGVuZHMgU2ltcGxlR2l0UGx1Z2luVHlwZT4oXG4gICAgICBwbHVnaW46IHZvaWQgfCBTaW1wbGVHaXRQbHVnaW48VD4gfCBTaW1wbGVHaXRQbHVnaW48VD5bXVxuICAgKSB7XG4gICAgICBjb25zdCBwbHVnaW5zOiBTaW1wbGVHaXRQbHVnaW48VD5bXSA9IFtdO1xuXG4gICAgICBhc0FycmF5KHBsdWdpbikuZm9yRWFjaCgocGx1Z2luKSA9PiBwbHVnaW4gJiYgdGhpcy5wbHVnaW5zLmFkZChhcHBlbmQocGx1Z2lucywgcGx1Z2luKSkpO1xuXG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgcGx1Z2lucy5mb3JFYWNoKChwbHVnaW4pID0+IHRoaXMucGx1Z2lucy5kZWxldGUocGx1Z2luKSk7XG4gICAgICB9O1xuICAgfVxuXG4gICBwdWJsaWMgZXhlYzxUIGV4dGVuZHMgU2ltcGxlR2l0UGx1Z2luVHlwZT4oXG4gICAgICB0eXBlOiBULFxuICAgICAgZGF0YTogU2ltcGxlR2l0UGx1Z2luVHlwZXNbVF1bJ2RhdGEnXSxcbiAgICAgIGNvbnRleHQ6IFNpbXBsZUdpdFBsdWdpblR5cGVzW1RdWydjb250ZXh0J11cbiAgICk6IHR5cGVvZiBkYXRhIHtcbiAgICAgIGxldCBvdXRwdXQgPSBkYXRhO1xuICAgICAgY29uc3QgY29udGV4dHVhbCA9IE9iamVjdC5mcmVlemUoT2JqZWN0LmNyZWF0ZShjb250ZXh0KSk7XG5cbiAgICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIHRoaXMucGx1Z2lucykge1xuICAgICAgICAgaWYgKHBsdWdpbi50eXBlID09PSB0eXBlKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBwbHVnaW4uYWN0aW9uKG91dHB1dCwgY29udGV4dHVhbCk7XG4gICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICB9XG59XG4iLCAiaW1wb3J0IHsgU2ltcGxlR2l0T3B0aW9ucyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IGFzTnVtYmVyLCBpbmNsdWRpbmcgfSBmcm9tICcuLi91dGlscyc7XG5cbmltcG9ydCB7IFNpbXBsZUdpdFBsdWdpbiB9IGZyb20gJy4vc2ltcGxlLWdpdC1wbHVnaW4nO1xuXG5leHBvcnQgZnVuY3Rpb24gcHJvZ3Jlc3NNb25pdG9yUGx1Z2luKHByb2dyZXNzOiBFeGNsdWRlPFNpbXBsZUdpdE9wdGlvbnNbJ3Byb2dyZXNzJ10sIHZvaWQ+KSB7XG4gICBjb25zdCBwcm9ncmVzc0NvbW1hbmQgPSAnLS1wcm9ncmVzcyc7XG4gICBjb25zdCBwcm9ncmVzc01ldGhvZHMgPSBbJ2NoZWNrb3V0JywgJ2Nsb25lJywgJ2ZldGNoJywgJ3B1bGwnLCAncHVzaCddO1xuXG4gICBjb25zdCBvblByb2dyZXNzOiBTaW1wbGVHaXRQbHVnaW48J3NwYXduLmFmdGVyJz4gPSB7XG4gICAgICB0eXBlOiAnc3Bhd24uYWZ0ZXInLFxuICAgICAgYWN0aW9uKF9kYXRhLCBjb250ZXh0KSB7XG4gICAgICAgICBpZiAoIWNvbnRleHQuY29tbWFuZHMuaW5jbHVkZXMocHJvZ3Jlc3NDb21tYW5kKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgfVxuXG4gICAgICAgICBjb250ZXh0LnNwYXduZWQuc3RkZXJyPy5vbignZGF0YScsIChjaHVuazogQnVmZmVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gL14oW1xcc1xcU10rPyk6XFxzKihcXGQrKSUgXFwoKFxcZCspXFwvKFxcZCspXFwpLy5leGVjKGNodW5rLnRvU3RyaW5nKCd1dGY4JykpO1xuICAgICAgICAgICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByb2dyZXNzKHtcbiAgICAgICAgICAgICAgIG1ldGhvZDogY29udGV4dC5tZXRob2QsXG4gICAgICAgICAgICAgICBzdGFnZTogcHJvZ3Jlc3NFdmVudFN0YWdlKG1lc3NhZ2VbMV0pLFxuICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IGFzTnVtYmVyKG1lc3NhZ2VbMl0pLFxuICAgICAgICAgICAgICAgcHJvY2Vzc2VkOiBhc051bWJlcihtZXNzYWdlWzNdKSxcbiAgICAgICAgICAgICAgIHRvdGFsOiBhc051bWJlcihtZXNzYWdlWzRdKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgfSk7XG4gICAgICB9LFxuICAgfTtcblxuICAgY29uc3Qgb25BcmdzOiBTaW1wbGVHaXRQbHVnaW48J3NwYXduLmFyZ3MnPiA9IHtcbiAgICAgIHR5cGU6ICdzcGF3bi5hcmdzJyxcbiAgICAgIGFjdGlvbihhcmdzLCBjb250ZXh0KSB7XG4gICAgICAgICBpZiAoIXByb2dyZXNzTWV0aG9kcy5pbmNsdWRlcyhjb250ZXh0Lm1ldGhvZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgICAgfVxuXG4gICAgICAgICByZXR1cm4gaW5jbHVkaW5nKGFyZ3MsIHByb2dyZXNzQ29tbWFuZCk7XG4gICAgICB9LFxuICAgfTtcblxuICAgcmV0dXJuIFtvbkFyZ3MsIG9uUHJvZ3Jlc3NdO1xufVxuXG5mdW5jdGlvbiBwcm9ncmVzc0V2ZW50U3RhZ2UoaW5wdXQ6IHN0cmluZykge1xuICAgcmV0dXJuIFN0cmluZyhpbnB1dC50b0xvd2VyQ2FzZSgpLnNwbGl0KCcgJywgMSkpIHx8ICd1bmtub3duJztcbn1cbiIsICJpbXBvcnQgeyBTcGF3bk9wdGlvbnMgfSBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCB7IHBpY2sgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgeyBTaW1wbGVHaXRQbHVnaW4gfSBmcm9tICcuL3NpbXBsZS1naXQtcGx1Z2luJztcblxuZXhwb3J0IGZ1bmN0aW9uIHNwYXduT3B0aW9uc1BsdWdpbihcbiAgIHNwYXduT3B0aW9uczogUGFydGlhbDxTcGF3bk9wdGlvbnM+XG4pOiBTaW1wbGVHaXRQbHVnaW48J3NwYXduLm9wdGlvbnMnPiB7XG4gICBjb25zdCBvcHRpb25zID0gcGljayhzcGF3bk9wdGlvbnMsIFsndWlkJywgJ2dpZCddKTtcblxuICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdzcGF3bi5vcHRpb25zJyxcbiAgICAgIGFjdGlvbihkYXRhKSB7XG4gICAgICAgICByZXR1cm4geyAuLi5vcHRpb25zLCAuLi5kYXRhIH07XG4gICAgICB9LFxuICAgfTtcbn1cbiIsICJpbXBvcnQgdHlwZSB7IFNpbXBsZUdpdFBsdWdpbiB9IGZyb20gJy4vc2ltcGxlLWdpdC1wbHVnaW4nO1xuXG5pbXBvcnQgdHlwZSB7IFNpbXBsZUdpdE9wdGlvbnMgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBHaXRQbHVnaW5FcnJvciB9IGZyb20gJy4uL2Vycm9ycy9naXQtcGx1Z2luLWVycm9yJztcblxuZXhwb3J0IGZ1bmN0aW9uIHRpbWVvdXRQbHVnaW4oe1xuICAgYmxvY2ssXG4gICBzdGRFcnIgPSB0cnVlLFxuICAgc3RkT3V0ID0gdHJ1ZSxcbn06IEV4Y2x1ZGU8U2ltcGxlR2l0T3B0aW9uc1sndGltZW91dCddLCB1bmRlZmluZWQ+KTogU2ltcGxlR2l0UGx1Z2luPCdzcGF3bi5hZnRlcic+IHwgdm9pZCB7XG4gICBpZiAoYmxvY2sgPiAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgdHlwZTogJ3NwYXduLmFmdGVyJyxcbiAgICAgICAgIGFjdGlvbihfZGF0YSwgY29udGV4dCkge1xuICAgICAgICAgICAgbGV0IHRpbWVvdXQ6IE5vZGVKUy5UaW1lb3V0O1xuXG4gICAgICAgICAgICBmdW5jdGlvbiB3YWl0KCkge1xuICAgICAgICAgICAgICAgdGltZW91dCAmJiBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChraWxsLCBibG9jayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICAgICAgICAgICBjb250ZXh0LnNwYXduZWQuc3Rkb3V0Py5vZmYoJ2RhdGEnLCB3YWl0KTtcbiAgICAgICAgICAgICAgIGNvbnRleHQuc3Bhd25lZC5zdGRlcnI/Lm9mZignZGF0YScsIHdhaXQpO1xuICAgICAgICAgICAgICAgY29udGV4dC5zcGF3bmVkLm9mZignZXhpdCcsIHN0b3ApO1xuICAgICAgICAgICAgICAgY29udGV4dC5zcGF3bmVkLm9mZignY2xvc2UnLCBzdG9wKTtcbiAgICAgICAgICAgICAgIHRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBraWxsKCkge1xuICAgICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICAgICAgICAgY29udGV4dC5raWxsKG5ldyBHaXRQbHVnaW5FcnJvcih1bmRlZmluZWQsICd0aW1lb3V0JywgYGJsb2NrIHRpbWVvdXQgcmVhY2hlZGApKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RkT3V0ICYmIGNvbnRleHQuc3Bhd25lZC5zdGRvdXQ/Lm9uKCdkYXRhJywgd2FpdCk7XG4gICAgICAgICAgICBzdGRFcnIgJiYgY29udGV4dC5zcGF3bmVkLnN0ZGVycj8ub24oJ2RhdGEnLCB3YWl0KTtcbiAgICAgICAgICAgIGNvbnRleHQuc3Bhd25lZC5vbignZXhpdCcsIHN0b3ApO1xuICAgICAgICAgICAgY29udGV4dC5zcGF3bmVkLm9uKCdjbG9zZScsIHN0b3ApO1xuXG4gICAgICAgICAgICB3YWl0KCk7XG4gICAgICAgICB9LFxuICAgICAgfTtcbiAgIH1cbn1cbiIsICJpbXBvcnQgeyBTaW1wbGVHaXRQbHVnaW4gfSBmcm9tICcuL3NpbXBsZS1naXQtcGx1Z2luJztcbmltcG9ydCB7IGlzUGF0aFNwZWMsIHRvUGF0aHMgfSBmcm9tICcuLi9hcmdzL3BhdGhzcGVjJztcblxuZXhwb3J0IGZ1bmN0aW9uIHN1ZmZpeFBhdGhzUGx1Z2luKCk6IFNpbXBsZUdpdFBsdWdpbjwnc3Bhd24uYXJncyc+IHtcbiAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnc3Bhd24uYXJncycsXG4gICAgICBhY3Rpb24oZGF0YSkge1xuICAgICAgICAgY29uc3QgcHJlZml4OiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICAgbGV0IHN1ZmZpeDogdW5kZWZpbmVkIHwgc3RyaW5nW107XG4gICAgICAgICBmdW5jdGlvbiBhcHBlbmQoYXJnczogc3RyaW5nW10pIHtcbiAgICAgICAgICAgIChzdWZmaXggPSBzdWZmaXggfHwgW10pLnB1c2goLi4uYXJncyk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcGFyYW0gPSBkYXRhW2ldO1xuXG4gICAgICAgICAgICBpZiAoaXNQYXRoU3BlYyhwYXJhbSkpIHtcbiAgICAgICAgICAgICAgIGFwcGVuZCh0b1BhdGhzKHBhcmFtKSk7XG4gICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBhcmFtID09PSAnLS0nKSB7XG4gICAgICAgICAgICAgICBhcHBlbmQoXG4gICAgICAgICAgICAgICAgICBkYXRhLnNsaWNlKGkgKyAxKS5mbGF0TWFwKChpdGVtKSA9PiAoaXNQYXRoU3BlYyhpdGVtKSAmJiB0b1BhdGhzKGl0ZW0pKSB8fCBpdGVtKVxuICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcmVmaXgucHVzaChwYXJhbSk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHJldHVybiAhc3VmZml4ID8gcHJlZml4IDogWy4uLnByZWZpeCwgJy0tJywgLi4uc3VmZml4Lm1hcChTdHJpbmcpXTtcbiAgICAgIH0sXG4gICB9O1xufVxuIiwgImltcG9ydCB7IFNpbXBsZUdpdEZhY3RvcnkgfSBmcm9tICcuLi8uLi90eXBpbmdzJztcblxuaW1wb3J0ICogYXMgYXBpIGZyb20gJy4vYXBpJztcbmltcG9ydCB7XG4gICBhYm9ydFBsdWdpbixcbiAgIGJsb2NrVW5zYWZlT3BlcmF0aW9uc1BsdWdpbixcbiAgIGNvbW1hbmRDb25maWdQcmVmaXhpbmdQbHVnaW4sXG4gICBjb21wbGV0aW9uRGV0ZWN0aW9uUGx1Z2luLFxuICAgY3VzdG9tQmluYXJ5UGx1Z2luLFxuICAgZXJyb3JEZXRlY3Rpb25IYW5kbGVyLFxuICAgZXJyb3JEZXRlY3Rpb25QbHVnaW4sXG4gICBQbHVnaW5TdG9yZSxcbiAgIHByb2dyZXNzTW9uaXRvclBsdWdpbixcbiAgIHNwYXduT3B0aW9uc1BsdWdpbixcbiAgIHRpbWVvdXRQbHVnaW4sXG59IGZyb20gJy4vcGx1Z2lucyc7XG5pbXBvcnQgeyBzdWZmaXhQYXRoc1BsdWdpbiB9IGZyb20gJy4vcGx1Z2lucy9zdWZmaXgtcGF0aHMucGx1Z2luJztcbmltcG9ydCB7IGNyZWF0ZUluc3RhbmNlQ29uZmlnLCBmb2xkZXJFeGlzdHMgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IFNpbXBsZUdpdE9wdGlvbnMgfSBmcm9tICcuL3R5cGVzJztcblxuY29uc3QgR2l0ID0gcmVxdWlyZSgnLi4vZ2l0Jyk7XG5cbi8qKlxuICogQWRkcyB0aGUgbmVjZXNzYXJ5IHByb3BlcnRpZXMgdG8gdGhlIHN1cHBsaWVkIG9iamVjdCB0byBlbmFibGUgaXQgZm9yIHVzZSBhc1xuICogdGhlIGRlZmF1bHQgZXhwb3J0IG9mIGEgbW9kdWxlLlxuICpcbiAqIEVnOiBgbW9kdWxlLmV4cG9ydHMgPSBlc01vZHVsZUZhY3RvcnkoeyBzb21ldGhpbmcgKCkge30gfSlgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlc01vZHVsZUZhY3Rvcnk8VD4oZGVmYXVsdEV4cG9ydDogVCkge1xuICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGRlZmF1bHRFeHBvcnQsIHtcbiAgICAgIF9fZXNNb2R1bGU6IHsgdmFsdWU6IHRydWUgfSxcbiAgICAgIGRlZmF1bHQ6IHsgdmFsdWU6IGRlZmF1bHRFeHBvcnQgfSxcbiAgIH0pIGFzIFQgJiB7IF9fZXNNb2R1bGU6IHRydWU7IGRlZmF1bHQ6IFQgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdpdEV4cG9ydEZhY3RvcnkoZmFjdG9yeTogU2ltcGxlR2l0RmFjdG9yeSkge1xuICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZmFjdG9yeS5iaW5kKG51bGwpLCBhcGkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2l0SW5zdGFuY2VGYWN0b3J5KFxuICAgYmFzZURpcj86IHN0cmluZyB8IFBhcnRpYWw8U2ltcGxlR2l0T3B0aW9ucz4sXG4gICBvcHRpb25zPzogUGFydGlhbDxTaW1wbGVHaXRPcHRpb25zPlxuKSB7XG4gICBjb25zdCBwbHVnaW5zID0gbmV3IFBsdWdpblN0b3JlKCk7XG4gICBjb25zdCBjb25maWcgPSBjcmVhdGVJbnN0YW5jZUNvbmZpZyhcbiAgICAgIChiYXNlRGlyICYmICh0eXBlb2YgYmFzZURpciA9PT0gJ3N0cmluZycgPyB7IGJhc2VEaXIgfSA6IGJhc2VEaXIpKSB8fCB7fSxcbiAgICAgIG9wdGlvbnNcbiAgICk7XG5cbiAgIGlmICghZm9sZGVyRXhpc3RzKGNvbmZpZy5iYXNlRGlyKSkge1xuICAgICAgdGhyb3cgbmV3IGFwaS5HaXRDb25zdHJ1Y3RFcnJvcihcbiAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgIGBDYW5ub3QgdXNlIHNpbXBsZS1naXQgb24gYSBkaXJlY3RvcnkgdGhhdCBkb2VzIG5vdCBleGlzdGBcbiAgICAgICk7XG4gICB9XG5cbiAgIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZy5jb25maWcpKSB7XG4gICAgICBwbHVnaW5zLmFkZChjb21tYW5kQ29uZmlnUHJlZml4aW5nUGx1Z2luKGNvbmZpZy5jb25maWcpKTtcbiAgIH1cblxuICAgcGx1Z2lucy5hZGQoYmxvY2tVbnNhZmVPcGVyYXRpb25zUGx1Z2luKGNvbmZpZy51bnNhZmUpKTtcbiAgIHBsdWdpbnMuYWRkKHN1ZmZpeFBhdGhzUGx1Z2luKCkpO1xuICAgcGx1Z2lucy5hZGQoY29tcGxldGlvbkRldGVjdGlvblBsdWdpbihjb25maWcuY29tcGxldGlvbikpO1xuICAgY29uZmlnLmFib3J0ICYmIHBsdWdpbnMuYWRkKGFib3J0UGx1Z2luKGNvbmZpZy5hYm9ydCkpO1xuICAgY29uZmlnLnByb2dyZXNzICYmIHBsdWdpbnMuYWRkKHByb2dyZXNzTW9uaXRvclBsdWdpbihjb25maWcucHJvZ3Jlc3MpKTtcbiAgIGNvbmZpZy50aW1lb3V0ICYmIHBsdWdpbnMuYWRkKHRpbWVvdXRQbHVnaW4oY29uZmlnLnRpbWVvdXQpKTtcbiAgIGNvbmZpZy5zcGF3bk9wdGlvbnMgJiYgcGx1Z2lucy5hZGQoc3Bhd25PcHRpb25zUGx1Z2luKGNvbmZpZy5zcGF3bk9wdGlvbnMpKTtcblxuICAgcGx1Z2lucy5hZGQoZXJyb3JEZXRlY3Rpb25QbHVnaW4oZXJyb3JEZXRlY3Rpb25IYW5kbGVyKHRydWUpKSk7XG4gICBjb25maWcuZXJyb3JzICYmIHBsdWdpbnMuYWRkKGVycm9yRGV0ZWN0aW9uUGx1Z2luKGNvbmZpZy5lcnJvcnMpKTtcblxuICAgY3VzdG9tQmluYXJ5UGx1Z2luKHBsdWdpbnMsIGNvbmZpZy5iaW5hcnksIGNvbmZpZy51bnNhZmU/LmFsbG93VW5zYWZlQ3VzdG9tQmluYXJ5KTtcblxuICAgcmV0dXJuIG5ldyBHaXQoY29uZmlnLCBwbHVnaW5zKTtcbn1cbiIsICJpbXBvcnQgeyBTaW1wbGVHaXQsIFNpbXBsZUdpdE9wdGlvbnMgfSBmcm9tICcuLi8uLi8uLi90eXBpbmdzJztcblxuaW1wb3J0IHsgR2l0UmVzcG9uc2VFcnJvciB9IGZyb20gJy4uL2Vycm9ycy9naXQtcmVzcG9uc2UtZXJyb3InO1xuaW1wb3J0IHsgZ2l0SW5zdGFuY2VGYWN0b3J5IH0gZnJvbSAnLi4vZ2l0LWZhY3RvcnknO1xuaW1wb3J0IHsgU2ltcGxlR2l0VGFza0NhbGxiYWNrIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5jb25zdCBmdW5jdGlvbk5hbWVzQnVpbGRlckFwaSA9IFsnY3VzdG9tQmluYXJ5JywgJ2VudicsICdvdXRwdXRIYW5kbGVyJywgJ3NpbGVudCddO1xuXG5jb25zdCBmdW5jdGlvbk5hbWVzUHJvbWlzZUFwaSA9IFtcbiAgICdhZGQnLFxuICAgJ2FkZEFubm90YXRlZFRhZycsXG4gICAnYWRkQ29uZmlnJyxcbiAgICdhZGRSZW1vdGUnLFxuICAgJ2FkZFRhZycsXG4gICAnYXBwbHlQYXRjaCcsXG4gICAnYmluYXJ5Q2F0RmlsZScsXG4gICAnYnJhbmNoJyxcbiAgICdicmFuY2hMb2NhbCcsXG4gICAnY2F0RmlsZScsXG4gICAnY2hlY2tJZ25vcmUnLFxuICAgJ2NoZWNrSXNSZXBvJyxcbiAgICdjaGVja291dCcsXG4gICAnY2hlY2tvdXRCcmFuY2gnLFxuICAgJ2NoZWNrb3V0TGF0ZXN0VGFnJyxcbiAgICdjaGVja291dExvY2FsQnJhbmNoJyxcbiAgICdjbGVhbicsXG4gICAnY2xvbmUnLFxuICAgJ2NvbW1pdCcsXG4gICAnY3dkJyxcbiAgICdkZWxldGVMb2NhbEJyYW5jaCcsXG4gICAnZGVsZXRlTG9jYWxCcmFuY2hlcycsXG4gICAnZGlmZicsXG4gICAnZGlmZlN1bW1hcnknLFxuICAgJ2V4ZWMnLFxuICAgJ2ZldGNoJyxcbiAgICdnZXRSZW1vdGVzJyxcbiAgICdpbml0JyxcbiAgICdsaXN0Q29uZmlnJyxcbiAgICdsaXN0UmVtb3RlJyxcbiAgICdsb2cnLFxuICAgJ21lcmdlJyxcbiAgICdtZXJnZUZyb21UbycsXG4gICAnbWlycm9yJyxcbiAgICdtdicsXG4gICAncHVsbCcsXG4gICAncHVzaCcsXG4gICAncHVzaFRhZ3MnLFxuICAgJ3JhdycsXG4gICAncmViYXNlJyxcbiAgICdyZW1vdGUnLFxuICAgJ3JlbW92ZVJlbW90ZScsXG4gICAncmVzZXQnLFxuICAgJ3JldmVydCcsXG4gICAncmV2cGFyc2UnLFxuICAgJ3JtJyxcbiAgICdybUtlZXBMb2NhbCcsXG4gICAnc2hvdycsXG4gICAnc3Rhc2gnLFxuICAgJ3N0YXNoTGlzdCcsXG4gICAnc3RhdHVzJyxcbiAgICdzdWJNb2R1bGUnLFxuICAgJ3N1Ym1vZHVsZUFkZCcsXG4gICAnc3VibW9kdWxlSW5pdCcsXG4gICAnc3VibW9kdWxlVXBkYXRlJyxcbiAgICd0YWcnLFxuICAgJ3RhZ3MnLFxuICAgJ3VwZGF0ZVNlcnZlckluZm8nLFxuXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdpdFAoXG4gICAuLi5hcmdzOiBbXSB8IFtzdHJpbmddIHwgW1BhcnRpYWw8U2ltcGxlR2l0T3B0aW9ucz5dIHwgW3N0cmluZywgUGFydGlhbDxTaW1wbGVHaXRPcHRpb25zPl1cbik6IFNpbXBsZUdpdCB7XG4gICBsZXQgZ2l0OiBhbnk7XG5cbiAgIGxldCBjaGFpbiA9IFByb21pc2UucmVzb2x2ZSgpO1xuXG4gICB0cnkge1xuICAgICAgZ2l0ID0gZ2l0SW5zdGFuY2VGYWN0b3J5KC4uLmFyZ3MpO1xuICAgfSBjYXRjaCAoZSkge1xuICAgICAgY2hhaW4gPSBQcm9taXNlLnJlamVjdChlKTtcbiAgIH1cblxuICAgZnVuY3Rpb24gYnVpbGRlclJldHVybigpIHtcbiAgICAgIHJldHVybiBwcm9taXNlQXBpO1xuICAgfVxuXG4gICBmdW5jdGlvbiBjaGFpblJldHVybigpIHtcbiAgICAgIHJldHVybiBjaGFpbjtcbiAgIH1cblxuICAgY29uc3QgcHJvbWlzZUFwaSA9IFsuLi5mdW5jdGlvbk5hbWVzQnVpbGRlckFwaSwgLi4uZnVuY3Rpb25OYW1lc1Byb21pc2VBcGldLnJlZHVjZShcbiAgICAgIChhcGk6IGFueSwgbmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICAgICBjb25zdCBpc0FzeW5jID0gZnVuY3Rpb25OYW1lc1Byb21pc2VBcGkuaW5jbHVkZXMobmFtZSk7XG5cbiAgICAgICAgIGNvbnN0IHZhbGlkID0gaXNBc3luYyA/IGFzeW5jV3JhcHBlcihuYW1lLCBnaXQpIDogc3luY1dyYXBwZXIobmFtZSwgZ2l0LCBhcGkpO1xuICAgICAgICAgY29uc3QgYWx0ZXJuYXRpdmUgPSBpc0FzeW5jID8gY2hhaW5SZXR1cm4gOiBidWlsZGVyUmV0dXJuO1xuXG4gICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXBpLCBuYW1lLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogZ2l0ID8gdmFsaWQgOiBhbHRlcm5hdGl2ZSxcbiAgICAgICAgIH0pO1xuXG4gICAgICAgICByZXR1cm4gYXBpO1xuICAgICAgfSxcbiAgICAgIHt9XG4gICApO1xuXG4gICByZXR1cm4gcHJvbWlzZUFwaSBhcyBTaW1wbGVHaXQ7XG5cbiAgIGZ1bmN0aW9uIGFzeW5jV3JhcHBlcihmbjogc3RyaW5nLCBnaXQ6IGFueSk6ICguLi5hcmdzOiBhbnlbXSkgPT4gUHJvbWlzZTxhbnk+IHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJnczogYW55W10pIHtcbiAgICAgICAgIGlmICh0eXBlb2YgYXJnc1thcmdzLmxlbmd0aF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAnUHJvbWlzZSBpbnRlcmZhY2UgcmVxdWlyZXMgdGhhdCBoYW5kbGVycyBhcmUgbm90IHN1cHBsaWVkIGlubGluZSwgJyArXG4gICAgICAgICAgICAgICAgICAndHJhaWxpbmcgZnVuY3Rpb24gbm90IGFsbG93ZWQgaW4gY2FsbCB0byAnICtcbiAgICAgICAgICAgICAgICAgIGZuXG4gICAgICAgICAgICApO1xuICAgICAgICAgfVxuXG4gICAgICAgICByZXR1cm4gY2hhaW4udGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgY29uc3QgY2FsbGJhY2s6IFNpbXBsZUdpdFRhc2tDYWxsYmFjayA9IChlcnI6IEVycm9yIHwgbnVsbCwgcmVzdWx0PzogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KHRvRXJyb3IoZXJyKSk7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICBhcmdzLnB1c2goY2FsbGJhY2spO1xuXG4gICAgICAgICAgICAgICBnaXRbZm5dLmFwcGx5KGdpdCwgYXJncyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgIH0pO1xuICAgICAgfTtcbiAgIH1cblxuICAgZnVuY3Rpb24gc3luY1dyYXBwZXIoZm46IHN0cmluZywgZ2l0OiBhbnksIGFwaTogU2ltcGxlR2l0KSB7XG4gICAgICByZXR1cm4gKC4uLmFyZ3M6IGFueVtdKSA9PiB7XG4gICAgICAgICBnaXRbZm5dKC4uLmFyZ3MpO1xuXG4gICAgICAgICByZXR1cm4gYXBpO1xuICAgICAgfTtcbiAgIH1cbn1cblxuZnVuY3Rpb24gdG9FcnJvcihlcnJvcjogRXJyb3IgfCBzdHJpbmcgfCBhbnkpOiBFcnJvciB7XG4gICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgfVxuXG4gICBpZiAodHlwZW9mIGVycm9yID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcihlcnJvcik7XG4gICB9XG5cbiAgIHJldHVybiBuZXcgR2l0UmVzcG9uc2VFcnJvcihlcnJvcik7XG59XG4iLCAiaW1wb3J0IHsgZ2l0SW5zdGFuY2VGYWN0b3J5IH0gZnJvbSAnLi9saWIvZ2l0LWZhY3RvcnknO1xuXG5leHBvcnQgeyBnaXRQIH0gZnJvbSAnLi9saWIvcnVubmVycy9wcm9taXNlLXdyYXBwZWQnO1xuZXhwb3J0ICogZnJvbSAnLi9saWIvYXBpJztcblxuZXhwb3J0IGNvbnN0IHNpbXBsZUdpdCA9IGdpdEluc3RhbmNlRmFjdG9yeTtcblxuZXhwb3J0IGRlZmF1bHQgZ2l0SW5zdGFuY2VGYWN0b3J5O1xuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUEsc0NBQUFBLFNBQUE7QUFJQSxRQUFJLElBQUk7QUFDUixRQUFJLElBQUksSUFBSTtBQUNaLFFBQUksSUFBSSxJQUFJO0FBQ1osUUFBSSxJQUFJLElBQUk7QUFDWixRQUFJLElBQUksSUFBSTtBQUNaLFFBQUksSUFBSSxJQUFJO0FBZ0JaLElBQUFBLFFBQU8sVUFBVSxTQUFVLEtBQUssU0FBUztBQUN2QyxnQkFBVSxXQUFXLENBQUM7QUFDdEIsVUFBSSxPQUFPLE9BQU87QUFDbEIsVUFBSSxTQUFTLFlBQVksSUFBSSxTQUFTLEdBQUc7QUFDdkMsZUFBTyxNQUFNLEdBQUc7QUFBQSxNQUNsQixXQUFXLFNBQVMsWUFBWSxTQUFTLEdBQUcsR0FBRztBQUM3QyxlQUFPLFFBQVEsT0FBTyxRQUFRLEdBQUcsSUFBSSxTQUFTLEdBQUc7QUFBQSxNQUNuRDtBQUNBLFlBQU0sSUFBSTtBQUFBLFFBQ1IsMERBQ0UsS0FBSyxVQUFVLEdBQUc7QUFBQSxNQUN0QjtBQUFBLElBQ0Y7QUFVQSxhQUFTLE1BQU0sS0FBSztBQUNsQixZQUFNLE9BQU8sR0FBRztBQUNoQixVQUFJLElBQUksU0FBUyxLQUFLO0FBQ3BCO0FBQUEsTUFDRjtBQUNBLFVBQUksUUFBUSxtSUFBbUk7QUFBQSxRQUM3STtBQUFBLE1BQ0Y7QUFDQSxVQUFJLENBQUMsT0FBTztBQUNWO0FBQUEsTUFDRjtBQUNBLFVBQUksSUFBSSxXQUFXLE1BQU0sQ0FBQyxDQUFDO0FBQzNCLFVBQUksUUFBUSxNQUFNLENBQUMsS0FBSyxNQUFNLFlBQVk7QUFDMUMsY0FBUSxNQUFNO0FBQUEsUUFDWixLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQ0gsaUJBQU8sSUFBSTtBQUFBLFFBQ2IsS0FBSztBQUFBLFFBQ0wsS0FBSztBQUFBLFFBQ0wsS0FBSztBQUNILGlCQUFPLElBQUk7QUFBQSxRQUNiLEtBQUs7QUFBQSxRQUNMLEtBQUs7QUFBQSxRQUNMLEtBQUs7QUFDSCxpQkFBTyxJQUFJO0FBQUEsUUFDYixLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQ0gsaUJBQU8sSUFBSTtBQUFBLFFBQ2IsS0FBSztBQUFBLFFBQ0wsS0FBSztBQUFBLFFBQ0wsS0FBSztBQUFBLFFBQ0wsS0FBSztBQUFBLFFBQ0wsS0FBSztBQUNILGlCQUFPLElBQUk7QUFBQSxRQUNiLEtBQUs7QUFBQSxRQUNMLEtBQUs7QUFBQSxRQUNMLEtBQUs7QUFBQSxRQUNMLEtBQUs7QUFBQSxRQUNMLEtBQUs7QUFDSCxpQkFBTyxJQUFJO0FBQUEsUUFDYixLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQ0gsaUJBQU87QUFBQSxRQUNUO0FBQ0UsaUJBQU87QUFBQSxNQUNYO0FBQUEsSUFDRjtBQVVBLGFBQVMsU0FBUyxJQUFJO0FBQ3BCLFVBQUksUUFBUSxLQUFLLElBQUksRUFBRTtBQUN2QixVQUFJLFNBQVMsR0FBRztBQUNkLGVBQU8sS0FBSyxNQUFNLEtBQUssQ0FBQyxJQUFJO0FBQUEsTUFDOUI7QUFDQSxVQUFJLFNBQVMsR0FBRztBQUNkLGVBQU8sS0FBSyxNQUFNLEtBQUssQ0FBQyxJQUFJO0FBQUEsTUFDOUI7QUFDQSxVQUFJLFNBQVMsR0FBRztBQUNkLGVBQU8sS0FBSyxNQUFNLEtBQUssQ0FBQyxJQUFJO0FBQUEsTUFDOUI7QUFDQSxVQUFJLFNBQVMsR0FBRztBQUNkLGVBQU8sS0FBSyxNQUFNLEtBQUssQ0FBQyxJQUFJO0FBQUEsTUFDOUI7QUFDQSxhQUFPLEtBQUs7QUFBQSxJQUNkO0FBVUEsYUFBUyxRQUFRLElBQUk7QUFDbkIsVUFBSSxRQUFRLEtBQUssSUFBSSxFQUFFO0FBQ3ZCLFVBQUksU0FBUyxHQUFHO0FBQ2QsZUFBTyxPQUFPLElBQUksT0FBTyxHQUFHLEtBQUs7QUFBQSxNQUNuQztBQUNBLFVBQUksU0FBUyxHQUFHO0FBQ2QsZUFBTyxPQUFPLElBQUksT0FBTyxHQUFHLE1BQU07QUFBQSxNQUNwQztBQUNBLFVBQUksU0FBUyxHQUFHO0FBQ2QsZUFBTyxPQUFPLElBQUksT0FBTyxHQUFHLFFBQVE7QUFBQSxNQUN0QztBQUNBLFVBQUksU0FBUyxHQUFHO0FBQ2QsZUFBTyxPQUFPLElBQUksT0FBTyxHQUFHLFFBQVE7QUFBQSxNQUN0QztBQUNBLGFBQU8sS0FBSztBQUFBLElBQ2Q7QUFNQSxhQUFTLE9BQU8sSUFBSSxPQUFPLEdBQUcsTUFBTTtBQUNsQyxVQUFJLFdBQVcsU0FBUyxJQUFJO0FBQzVCLGFBQU8sS0FBSyxNQUFNLEtBQUssQ0FBQyxJQUFJLE1BQU0sUUFBUSxXQUFXLE1BQU07QUFBQSxJQUM3RDtBQUFBO0FBQUE7OztBQ2pLQTtBQUFBLDhDQUFBQyxTQUFBO0FBTUEsYUFBUyxNQUFNLEtBQUs7QUFDbkIsa0JBQVksUUFBUTtBQUNwQixrQkFBWSxVQUFVO0FBQ3RCLGtCQUFZLFNBQVM7QUFDckIsa0JBQVksVUFBVTtBQUN0QixrQkFBWSxTQUFTO0FBQ3JCLGtCQUFZLFVBQVU7QUFDdEIsa0JBQVksV0FBVztBQUN2QixrQkFBWSxVQUFVO0FBRXRCLGFBQU8sS0FBSyxHQUFHLEVBQUUsUUFBUSxTQUFPO0FBQy9CLG9CQUFZLEdBQUcsSUFBSSxJQUFJLEdBQUc7QUFBQSxNQUMzQixDQUFDO0FBTUQsa0JBQVksUUFBUSxDQUFDO0FBQ3JCLGtCQUFZLFFBQVEsQ0FBQztBQU9yQixrQkFBWSxhQUFhLENBQUM7QUFRMUIsZUFBUyxZQUFZLFdBQVc7QUFDL0IsWUFBSSxPQUFPO0FBRVgsaUJBQVMsSUFBSSxHQUFHLElBQUksVUFBVSxRQUFRLEtBQUs7QUFDMUMsa0JBQVMsUUFBUSxLQUFLLE9BQVEsVUFBVSxXQUFXLENBQUM7QUFDcEQsa0JBQVE7QUFBQSxRQUNUO0FBRUEsZUFBTyxZQUFZLE9BQU8sS0FBSyxJQUFJLElBQUksSUFBSSxZQUFZLE9BQU8sTUFBTTtBQUFBLE1BQ3JFO0FBQ0Esa0JBQVksY0FBYztBQVMxQixlQUFTLFlBQVksV0FBVztBQUMvQixZQUFJO0FBQ0osWUFBSSxpQkFBaUI7QUFDckIsWUFBSTtBQUNKLFlBQUk7QUFFSixpQkFBU0MsVUFBUyxNQUFNO0FBRXZCLGNBQUksQ0FBQ0EsT0FBTSxTQUFTO0FBQ25CO0FBQUEsVUFDRDtBQUVBLGdCQUFNLE9BQU9BO0FBR2IsZ0JBQU0sT0FBTyxPQUFPLElBQUksS0FBSyxDQUFDO0FBQzlCLGdCQUFNLEtBQUssUUFBUSxZQUFZO0FBQy9CLGVBQUssT0FBTztBQUNaLGVBQUssT0FBTztBQUNaLGVBQUssT0FBTztBQUNaLHFCQUFXO0FBRVgsZUFBSyxDQUFDLElBQUksWUFBWSxPQUFPLEtBQUssQ0FBQyxDQUFDO0FBRXBDLGNBQUksT0FBTyxLQUFLLENBQUMsTUFBTSxVQUFVO0FBRWhDLGlCQUFLLFFBQVEsSUFBSTtBQUFBLFVBQ2xCO0FBR0EsY0FBSSxRQUFRO0FBQ1osZUFBSyxDQUFDLElBQUksS0FBSyxDQUFDLEVBQUUsUUFBUSxpQkFBaUIsQ0FBQyxPQUFPLFdBQVc7QUFFN0QsZ0JBQUksVUFBVSxNQUFNO0FBQ25CLHFCQUFPO0FBQUEsWUFDUjtBQUNBO0FBQ0Esa0JBQU0sWUFBWSxZQUFZLFdBQVcsTUFBTTtBQUMvQyxnQkFBSSxPQUFPLGNBQWMsWUFBWTtBQUNwQyxvQkFBTSxNQUFNLEtBQUssS0FBSztBQUN0QixzQkFBUSxVQUFVLEtBQUssTUFBTSxHQUFHO0FBR2hDLG1CQUFLLE9BQU8sT0FBTyxDQUFDO0FBQ3BCO0FBQUEsWUFDRDtBQUNBLG1CQUFPO0FBQUEsVUFDUixDQUFDO0FBR0Qsc0JBQVksV0FBVyxLQUFLLE1BQU0sSUFBSTtBQUV0QyxnQkFBTSxRQUFRLEtBQUssT0FBTyxZQUFZO0FBQ3RDLGdCQUFNLE1BQU0sTUFBTSxJQUFJO0FBQUEsUUFDdkI7QUFFQSxRQUFBQSxPQUFNLFlBQVk7QUFDbEIsUUFBQUEsT0FBTSxZQUFZLFlBQVksVUFBVTtBQUN4QyxRQUFBQSxPQUFNLFFBQVEsWUFBWSxZQUFZLFNBQVM7QUFDL0MsUUFBQUEsT0FBTSxTQUFTO0FBQ2YsUUFBQUEsT0FBTSxVQUFVLFlBQVk7QUFFNUIsZUFBTyxlQUFlQSxRQUFPLFdBQVc7QUFBQSxVQUN2QyxZQUFZO0FBQUEsVUFDWixjQUFjO0FBQUEsVUFDZCxLQUFLLE1BQU07QUFDVixnQkFBSSxtQkFBbUIsTUFBTTtBQUM1QixxQkFBTztBQUFBLFlBQ1I7QUFDQSxnQkFBSSxvQkFBb0IsWUFBWSxZQUFZO0FBQy9DLGdDQUFrQixZQUFZO0FBQzlCLDZCQUFlLFlBQVksUUFBUSxTQUFTO0FBQUEsWUFDN0M7QUFFQSxtQkFBTztBQUFBLFVBQ1I7QUFBQSxVQUNBLEtBQUssT0FBSztBQUNULDZCQUFpQjtBQUFBLFVBQ2xCO0FBQUEsUUFDRCxDQUFDO0FBR0QsWUFBSSxPQUFPLFlBQVksU0FBUyxZQUFZO0FBQzNDLHNCQUFZLEtBQUtBLE1BQUs7QUFBQSxRQUN2QjtBQUVBLGVBQU9BO0FBQUEsTUFDUjtBQUVBLGVBQVMsT0FBTyxXQUFXLFdBQVc7QUFDckMsY0FBTSxXQUFXLFlBQVksS0FBSyxhQUFhLE9BQU8sY0FBYyxjQUFjLE1BQU0sYUFBYSxTQUFTO0FBQzlHLGlCQUFTLE1BQU0sS0FBSztBQUNwQixlQUFPO0FBQUEsTUFDUjtBQVNBLGVBQVMsT0FBTyxZQUFZO0FBQzNCLG9CQUFZLEtBQUssVUFBVTtBQUMzQixvQkFBWSxhQUFhO0FBRXpCLG9CQUFZLFFBQVEsQ0FBQztBQUNyQixvQkFBWSxRQUFRLENBQUM7QUFFckIsY0FBTSxTQUFTLE9BQU8sZUFBZSxXQUFXLGFBQWEsSUFDM0QsS0FBSyxFQUNMLFFBQVEsUUFBUSxHQUFHLEVBQ25CLE1BQU0sR0FBRyxFQUNULE9BQU8sT0FBTztBQUVoQixtQkFBVyxNQUFNLE9BQU87QUFDdkIsY0FBSSxHQUFHLENBQUMsTUFBTSxLQUFLO0FBQ2xCLHdCQUFZLE1BQU0sS0FBSyxHQUFHLE1BQU0sQ0FBQyxDQUFDO0FBQUEsVUFDbkMsT0FBTztBQUNOLHdCQUFZLE1BQU0sS0FBSyxFQUFFO0FBQUEsVUFDMUI7QUFBQSxRQUNEO0FBQUEsTUFDRDtBQVVBLGVBQVMsZ0JBQWdCLFFBQVEsVUFBVTtBQUMxQyxZQUFJLGNBQWM7QUFDbEIsWUFBSSxnQkFBZ0I7QUFDcEIsWUFBSSxZQUFZO0FBQ2hCLFlBQUksYUFBYTtBQUVqQixlQUFPLGNBQWMsT0FBTyxRQUFRO0FBQ25DLGNBQUksZ0JBQWdCLFNBQVMsV0FBVyxTQUFTLGFBQWEsTUFBTSxPQUFPLFdBQVcsS0FBSyxTQUFTLGFBQWEsTUFBTSxNQUFNO0FBRTVILGdCQUFJLFNBQVMsYUFBYSxNQUFNLEtBQUs7QUFDcEMsMEJBQVk7QUFDWiwyQkFBYTtBQUNiO0FBQUEsWUFDRCxPQUFPO0FBQ047QUFDQTtBQUFBLFlBQ0Q7QUFBQSxVQUNELFdBQVcsY0FBYyxJQUFJO0FBRTVCLDRCQUFnQixZQUFZO0FBQzVCO0FBQ0EsMEJBQWM7QUFBQSxVQUNmLE9BQU87QUFDTixtQkFBTztBQUFBLFVBQ1I7QUFBQSxRQUNEO0FBR0EsZUFBTyxnQkFBZ0IsU0FBUyxVQUFVLFNBQVMsYUFBYSxNQUFNLEtBQUs7QUFDMUU7QUFBQSxRQUNEO0FBRUEsZUFBTyxrQkFBa0IsU0FBUztBQUFBLE1BQ25DO0FBUUEsZUFBUyxVQUFVO0FBQ2xCLGNBQU0sYUFBYTtBQUFBLFVBQ2xCLEdBQUcsWUFBWTtBQUFBLFVBQ2YsR0FBRyxZQUFZLE1BQU0sSUFBSSxlQUFhLE1BQU0sU0FBUztBQUFBLFFBQ3RELEVBQUUsS0FBSyxHQUFHO0FBQ1Ysb0JBQVksT0FBTyxFQUFFO0FBQ3JCLGVBQU87QUFBQSxNQUNSO0FBU0EsZUFBUyxRQUFRLE1BQU07QUFDdEIsbUJBQVcsUUFBUSxZQUFZLE9BQU87QUFDckMsY0FBSSxnQkFBZ0IsTUFBTSxJQUFJLEdBQUc7QUFDaEMsbUJBQU87QUFBQSxVQUNSO0FBQUEsUUFDRDtBQUVBLG1CQUFXLE1BQU0sWUFBWSxPQUFPO0FBQ25DLGNBQUksZ0JBQWdCLE1BQU0sRUFBRSxHQUFHO0FBQzlCLG1CQUFPO0FBQUEsVUFDUjtBQUFBLFFBQ0Q7QUFFQSxlQUFPO0FBQUEsTUFDUjtBQVNBLGVBQVMsT0FBTyxLQUFLO0FBQ3BCLFlBQUksZUFBZSxPQUFPO0FBQ3pCLGlCQUFPLElBQUksU0FBUyxJQUFJO0FBQUEsUUFDekI7QUFDQSxlQUFPO0FBQUEsTUFDUjtBQU1BLGVBQVMsVUFBVTtBQUNsQixnQkFBUSxLQUFLLHVJQUF1STtBQUFBLE1BQ3JKO0FBRUEsa0JBQVksT0FBTyxZQUFZLEtBQUssQ0FBQztBQUVyQyxhQUFPO0FBQUEsSUFDUjtBQUVBLElBQUFELFFBQU8sVUFBVTtBQUFBO0FBQUE7OztBQ25TakI7QUFBQSwrQ0FBQUUsU0FBQTtBQU1BLFlBQVEsYUFBYTtBQUNyQixZQUFRLE9BQU87QUFDZixZQUFRLE9BQU87QUFDZixZQUFRLFlBQVk7QUFDcEIsWUFBUSxVQUFVLGFBQWE7QUFDL0IsWUFBUSxXQUFXLE1BQU07QUFDeEIsVUFBSSxTQUFTO0FBRWIsYUFBTyxNQUFNO0FBQ1osWUFBSSxDQUFDLFFBQVE7QUFDWixtQkFBUztBQUNULGtCQUFRLEtBQUssdUlBQXVJO0FBQUEsUUFDcko7QUFBQSxNQUNEO0FBQUEsSUFDRCxHQUFHO0FBTUgsWUFBUSxTQUFTO0FBQUEsTUFDaEI7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxJQUNEO0FBV0EsYUFBUyxZQUFZO0FBSXBCLFVBQUksT0FBTyxXQUFXLGVBQWUsT0FBTyxZQUFZLE9BQU8sUUFBUSxTQUFTLGNBQWMsT0FBTyxRQUFRLFNBQVM7QUFDckgsZUFBTztBQUFBLE1BQ1I7QUFHQSxVQUFJLE9BQU8sY0FBYyxlQUFlLFVBQVUsYUFBYSxVQUFVLFVBQVUsWUFBWSxFQUFFLE1BQU0sdUJBQXVCLEdBQUc7QUFDaEksZUFBTztBQUFBLE1BQ1I7QUFFQSxVQUFJO0FBS0osYUFBUSxPQUFPLGFBQWEsZUFBZSxTQUFTLG1CQUFtQixTQUFTLGdCQUFnQixTQUFTLFNBQVMsZ0JBQWdCLE1BQU07QUFBQSxNQUV0SSxPQUFPLFdBQVcsZUFBZSxPQUFPLFlBQVksT0FBTyxRQUFRLFdBQVksT0FBTyxRQUFRLGFBQWEsT0FBTyxRQUFRO0FBQUE7QUFBQSxNQUcxSCxPQUFPLGNBQWMsZUFBZSxVQUFVLGNBQWMsSUFBSSxVQUFVLFVBQVUsWUFBWSxFQUFFLE1BQU0sZ0JBQWdCLE1BQU0sU0FBUyxFQUFFLENBQUMsR0FBRyxFQUFFLEtBQUs7QUFBQSxNQUVwSixPQUFPLGNBQWMsZUFBZSxVQUFVLGFBQWEsVUFBVSxVQUFVLFlBQVksRUFBRSxNQUFNLG9CQUFvQjtBQUFBLElBQzFIO0FBUUEsYUFBUyxXQUFXLE1BQU07QUFDekIsV0FBSyxDQUFDLEtBQUssS0FBSyxZQUFZLE9BQU8sTUFDbEMsS0FBSyxhQUNKLEtBQUssWUFBWSxRQUFRLE9BQzFCLEtBQUssQ0FBQyxLQUNMLEtBQUssWUFBWSxRQUFRLE9BQzFCLE1BQU1BLFFBQU8sUUFBUSxTQUFTLEtBQUssSUFBSTtBQUV4QyxVQUFJLENBQUMsS0FBSyxXQUFXO0FBQ3BCO0FBQUEsTUFDRDtBQUVBLFlBQU0sSUFBSSxZQUFZLEtBQUs7QUFDM0IsV0FBSyxPQUFPLEdBQUcsR0FBRyxHQUFHLGdCQUFnQjtBQUtyQyxVQUFJLFFBQVE7QUFDWixVQUFJLFFBQVE7QUFDWixXQUFLLENBQUMsRUFBRSxRQUFRLGVBQWUsV0FBUztBQUN2QyxZQUFJLFVBQVUsTUFBTTtBQUNuQjtBQUFBLFFBQ0Q7QUFDQTtBQUNBLFlBQUksVUFBVSxNQUFNO0FBR25CLGtCQUFRO0FBQUEsUUFDVDtBQUFBLE1BQ0QsQ0FBQztBQUVELFdBQUssT0FBTyxPQUFPLEdBQUcsQ0FBQztBQUFBLElBQ3hCO0FBVUEsWUFBUSxNQUFNLFFBQVEsU0FBUyxRQUFRLFFBQVEsTUFBTTtBQUFBLElBQUM7QUFRdEQsYUFBUyxLQUFLLFlBQVk7QUFDekIsVUFBSTtBQUNILFlBQUksWUFBWTtBQUNmLGtCQUFRLFFBQVEsUUFBUSxTQUFTLFVBQVU7QUFBQSxRQUM1QyxPQUFPO0FBQ04sa0JBQVEsUUFBUSxXQUFXLE9BQU87QUFBQSxRQUNuQztBQUFBLE1BQ0QsU0FBUyxPQUFQO0FBQUEsTUFHRjtBQUFBLElBQ0Q7QUFRQSxhQUFTLE9BQU87QUFDZixVQUFJO0FBQ0osVUFBSTtBQUNILFlBQUksUUFBUSxRQUFRLFFBQVEsT0FBTyxLQUFLLFFBQVEsUUFBUSxRQUFRLE9BQU87QUFBQSxNQUN4RSxTQUFTLE9BQVA7QUFBQSxNQUdGO0FBR0EsVUFBSSxDQUFDLEtBQUssT0FBTyxZQUFZLGVBQWUsU0FBUyxTQUFTO0FBQzdELFlBQUksUUFBUSxJQUFJO0FBQUEsTUFDakI7QUFFQSxhQUFPO0FBQUEsSUFDUjtBQWFBLGFBQVMsZUFBZTtBQUN2QixVQUFJO0FBR0gsZUFBTztBQUFBLE1BQ1IsU0FBUyxPQUFQO0FBQUEsTUFHRjtBQUFBLElBQ0Q7QUFFQSxJQUFBQSxRQUFPLFVBQVUsaUJBQW9CLE9BQU87QUFFNUMsUUFBTSxFQUFDLFdBQVUsSUFBSUEsUUFBTztBQU01QixlQUFXLElBQUksU0FBVSxHQUFHO0FBQzNCLFVBQUk7QUFDSCxlQUFPLEtBQUssVUFBVSxDQUFDO0FBQUEsTUFDeEIsU0FBUyxPQUFQO0FBQ0QsZUFBTyxpQ0FBaUMsTUFBTTtBQUFBLE1BQy9DO0FBQUEsSUFDRDtBQUFBO0FBQUE7OztBQy9RQTtBQUFBLDRDQUFBQyxTQUFBO0FBQUE7QUFFQSxJQUFBQSxRQUFPLFVBQVUsQ0FBQyxNQUFNLE9BQU8sUUFBUSxTQUFTO0FBQy9DLFlBQU0sU0FBUyxLQUFLLFdBQVcsR0FBRyxJQUFJLEtBQU0sS0FBSyxXQUFXLElBQUksTUFBTTtBQUN0RSxZQUFNLFdBQVcsS0FBSyxRQUFRLFNBQVMsSUFBSTtBQUMzQyxZQUFNLHFCQUFxQixLQUFLLFFBQVEsSUFBSTtBQUM1QyxhQUFPLGFBQWEsT0FBTyx1QkFBdUIsTUFBTSxXQUFXO0FBQUEsSUFDcEU7QUFBQTtBQUFBOzs7QUNQQTtBQUFBLGtEQUFBQyxTQUFBO0FBQUE7QUFDQSxRQUFNLEtBQUssUUFBUSxJQUFJO0FBQ3ZCLFFBQU0sTUFBTSxRQUFRLEtBQUs7QUFDekIsUUFBTSxVQUFVO0FBRWhCLFFBQU0sRUFBQyxJQUFHLElBQUk7QUFFZCxRQUFJO0FBQ0osUUFBSSxRQUFRLFVBQVUsS0FDckIsUUFBUSxXQUFXLEtBQ25CLFFBQVEsYUFBYSxLQUNyQixRQUFRLGFBQWEsR0FBRztBQUN4QixtQkFBYTtBQUFBLElBQ2QsV0FBVyxRQUFRLE9BQU8sS0FDekIsUUFBUSxRQUFRLEtBQ2hCLFFBQVEsWUFBWSxLQUNwQixRQUFRLGNBQWMsR0FBRztBQUN6QixtQkFBYTtBQUFBLElBQ2Q7QUFFQSxRQUFJLGlCQUFpQixLQUFLO0FBQ3pCLFVBQUksSUFBSSxnQkFBZ0IsUUFBUTtBQUMvQixxQkFBYTtBQUFBLE1BQ2QsV0FBVyxJQUFJLGdCQUFnQixTQUFTO0FBQ3ZDLHFCQUFhO0FBQUEsTUFDZCxPQUFPO0FBQ04scUJBQWEsSUFBSSxZQUFZLFdBQVcsSUFBSSxJQUFJLEtBQUssSUFBSSxTQUFTLElBQUksYUFBYSxFQUFFLEdBQUcsQ0FBQztBQUFBLE1BQzFGO0FBQUEsSUFDRDtBQUVBLGFBQVMsZUFBZSxPQUFPO0FBQzlCLFVBQUksVUFBVSxHQUFHO0FBQ2hCLGVBQU87QUFBQSxNQUNSO0FBRUEsYUFBTztBQUFBLFFBQ047QUFBQSxRQUNBLFVBQVU7QUFBQSxRQUNWLFFBQVEsU0FBUztBQUFBLFFBQ2pCLFFBQVEsU0FBUztBQUFBLE1BQ2xCO0FBQUEsSUFDRDtBQUVBLGFBQVMsY0FBYyxZQUFZLGFBQWE7QUFDL0MsVUFBSSxlQUFlLEdBQUc7QUFDckIsZUFBTztBQUFBLE1BQ1I7QUFFQSxVQUFJLFFBQVEsV0FBVyxLQUN0QixRQUFRLFlBQVksS0FDcEIsUUFBUSxpQkFBaUIsR0FBRztBQUM1QixlQUFPO0FBQUEsTUFDUjtBQUVBLFVBQUksUUFBUSxXQUFXLEdBQUc7QUFDekIsZUFBTztBQUFBLE1BQ1I7QUFFQSxVQUFJLGNBQWMsQ0FBQyxlQUFlLGVBQWUsUUFBVztBQUMzRCxlQUFPO0FBQUEsTUFDUjtBQUVBLFlBQU0sTUFBTSxjQUFjO0FBRTFCLFVBQUksSUFBSSxTQUFTLFFBQVE7QUFDeEIsZUFBTztBQUFBLE1BQ1I7QUFFQSxVQUFJLFFBQVEsYUFBYSxTQUFTO0FBR2pDLGNBQU0sWUFBWSxHQUFHLFFBQVEsRUFBRSxNQUFNLEdBQUc7QUFDeEMsWUFDQyxPQUFPLFVBQVUsQ0FBQyxDQUFDLEtBQUssTUFDeEIsT0FBTyxVQUFVLENBQUMsQ0FBQyxLQUFLLE9BQ3ZCO0FBQ0QsaUJBQU8sT0FBTyxVQUFVLENBQUMsQ0FBQyxLQUFLLFFBQVEsSUFBSTtBQUFBLFFBQzVDO0FBRUEsZUFBTztBQUFBLE1BQ1I7QUFFQSxVQUFJLFFBQVEsS0FBSztBQUNoQixZQUFJLENBQUMsVUFBVSxZQUFZLFlBQVksYUFBYSxrQkFBa0IsV0FBVyxFQUFFLEtBQUssVUFBUSxRQUFRLEdBQUcsS0FBSyxJQUFJLFlBQVksWUFBWTtBQUMzSSxpQkFBTztBQUFBLFFBQ1I7QUFFQSxlQUFPO0FBQUEsTUFDUjtBQUVBLFVBQUksc0JBQXNCLEtBQUs7QUFDOUIsZUFBTyxnQ0FBZ0MsS0FBSyxJQUFJLGdCQUFnQixJQUFJLElBQUk7QUFBQSxNQUN6RTtBQUVBLFVBQUksSUFBSSxjQUFjLGFBQWE7QUFDbEMsZUFBTztBQUFBLE1BQ1I7QUFFQSxVQUFJLGtCQUFrQixLQUFLO0FBQzFCLGNBQU0sVUFBVSxVQUFVLElBQUksd0JBQXdCLElBQUksTUFBTSxHQUFHLEVBQUUsQ0FBQyxHQUFHLEVBQUU7QUFFM0UsZ0JBQVEsSUFBSSxjQUFjO0FBQUEsVUFDekIsS0FBSztBQUNKLG1CQUFPLFdBQVcsSUFBSSxJQUFJO0FBQUEsVUFDM0IsS0FBSztBQUNKLG1CQUFPO0FBQUEsUUFFVDtBQUFBLE1BQ0Q7QUFFQSxVQUFJLGlCQUFpQixLQUFLLElBQUksSUFBSSxHQUFHO0FBQ3BDLGVBQU87QUFBQSxNQUNSO0FBRUEsVUFBSSw4REFBOEQsS0FBSyxJQUFJLElBQUksR0FBRztBQUNqRixlQUFPO0FBQUEsTUFDUjtBQUVBLFVBQUksZUFBZSxLQUFLO0FBQ3ZCLGVBQU87QUFBQSxNQUNSO0FBRUEsYUFBTztBQUFBLElBQ1I7QUFFQSxhQUFTLGdCQUFnQixRQUFRO0FBQ2hDLFlBQU0sUUFBUSxjQUFjLFFBQVEsVUFBVSxPQUFPLEtBQUs7QUFDMUQsYUFBTyxlQUFlLEtBQUs7QUFBQSxJQUM1QjtBQUVBLElBQUFBLFFBQU8sVUFBVTtBQUFBLE1BQ2hCLGVBQWU7QUFBQSxNQUNmLFFBQVEsZUFBZSxjQUFjLE1BQU0sSUFBSSxPQUFPLENBQUMsQ0FBQyxDQUFDO0FBQUEsTUFDekQsUUFBUSxlQUFlLGNBQWMsTUFBTSxJQUFJLE9BQU8sQ0FBQyxDQUFDLENBQUM7QUFBQSxJQUMxRDtBQUFBO0FBQUE7OztBQ3RJQTtBQUFBLDRDQUFBQyxTQUFBO0FBSUEsUUFBTSxNQUFNLFFBQVEsS0FBSztBQUN6QixRQUFNLE9BQU8sUUFBUSxNQUFNO0FBTTNCLFlBQVEsT0FBTztBQUNmLFlBQVEsTUFBTTtBQUNkLFlBQVEsYUFBYTtBQUNyQixZQUFRLE9BQU87QUFDZixZQUFRLE9BQU87QUFDZixZQUFRLFlBQVk7QUFDcEIsWUFBUSxVQUFVLEtBQUs7QUFBQSxNQUN0QixNQUFNO0FBQUEsTUFBQztBQUFBLE1BQ1A7QUFBQSxJQUNEO0FBTUEsWUFBUSxTQUFTLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7QUFFbEMsUUFBSTtBQUdILFlBQU0sZ0JBQWdCO0FBRXRCLFVBQUksa0JBQWtCLGNBQWMsVUFBVSxlQUFlLFNBQVMsR0FBRztBQUN4RSxnQkFBUSxTQUFTO0FBQUEsVUFDaEI7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxRQUNEO0FBQUEsTUFDRDtBQUFBLElBQ0QsU0FBUyxPQUFQO0FBQUEsSUFFRjtBQVFBLFlBQVEsY0FBYyxPQUFPLEtBQUssUUFBUSxHQUFHLEVBQUUsT0FBTyxTQUFPO0FBQzVELGFBQU8sV0FBVyxLQUFLLEdBQUc7QUFBQSxJQUMzQixDQUFDLEVBQUUsT0FBTyxDQUFDLEtBQUssUUFBUTtBQUV2QixZQUFNLE9BQU8sSUFDWCxVQUFVLENBQUMsRUFDWCxZQUFZLEVBQ1osUUFBUSxhQUFhLENBQUMsR0FBRyxNQUFNO0FBQy9CLGVBQU8sRUFBRSxZQUFZO0FBQUEsTUFDdEIsQ0FBQztBQUdGLFVBQUksTUFBTSxRQUFRLElBQUksR0FBRztBQUN6QixVQUFJLDJCQUEyQixLQUFLLEdBQUcsR0FBRztBQUN6QyxjQUFNO0FBQUEsTUFDUCxXQUFXLDZCQUE2QixLQUFLLEdBQUcsR0FBRztBQUNsRCxjQUFNO0FBQUEsTUFDUCxXQUFXLFFBQVEsUUFBUTtBQUMxQixjQUFNO0FBQUEsTUFDUCxPQUFPO0FBQ04sY0FBTSxPQUFPLEdBQUc7QUFBQSxNQUNqQjtBQUVBLFVBQUksSUFBSSxJQUFJO0FBQ1osYUFBTztBQUFBLElBQ1IsR0FBRyxDQUFDLENBQUM7QUFNTCxhQUFTLFlBQVk7QUFDcEIsYUFBTyxZQUFZLFFBQVEsY0FDMUIsUUFBUSxRQUFRLFlBQVksTUFBTSxJQUNsQyxJQUFJLE9BQU8sUUFBUSxPQUFPLEVBQUU7QUFBQSxJQUM5QjtBQVFBLGFBQVMsV0FBVyxNQUFNO0FBQ3pCLFlBQU0sRUFBQyxXQUFXLE1BQU0sV0FBQUMsV0FBUyxJQUFJO0FBRXJDLFVBQUlBLFlBQVc7QUFDZCxjQUFNLElBQUksS0FBSztBQUNmLGNBQU0sWUFBWSxZQUFjLElBQUksSUFBSSxJQUFJLFNBQVM7QUFDckQsY0FBTSxTQUFTLEtBQUssZUFBZTtBQUVuQyxhQUFLLENBQUMsSUFBSSxTQUFTLEtBQUssQ0FBQyxFQUFFLE1BQU0sSUFBSSxFQUFFLEtBQUssT0FBTyxNQUFNO0FBQ3pELGFBQUssS0FBSyxZQUFZLE9BQU9ELFFBQU8sUUFBUSxTQUFTLEtBQUssSUFBSSxJQUFJLFNBQVc7QUFBQSxNQUM5RSxPQUFPO0FBQ04sYUFBSyxDQUFDLElBQUksUUFBUSxJQUFJLE9BQU8sTUFBTSxLQUFLLENBQUM7QUFBQSxNQUMxQztBQUFBLElBQ0Q7QUFFQSxhQUFTLFVBQVU7QUFDbEIsVUFBSSxRQUFRLFlBQVksVUFBVTtBQUNqQyxlQUFPO0FBQUEsTUFDUjtBQUNBLGFBQU8sSUFBSSxLQUFLLEVBQUUsWUFBWSxJQUFJO0FBQUEsSUFDbkM7QUFNQSxhQUFTLE9BQU8sTUFBTTtBQUNyQixhQUFPLFFBQVEsT0FBTyxNQUFNLEtBQUssa0JBQWtCLFFBQVEsYUFBYSxHQUFHLElBQUksSUFBSSxJQUFJO0FBQUEsSUFDeEY7QUFRQSxhQUFTLEtBQUssWUFBWTtBQUN6QixVQUFJLFlBQVk7QUFDZixnQkFBUSxJQUFJLFFBQVE7QUFBQSxNQUNyQixPQUFPO0FBR04sZUFBTyxRQUFRLElBQUk7QUFBQSxNQUNwQjtBQUFBLElBQ0Q7QUFTQSxhQUFTLE9BQU87QUFDZixhQUFPLFFBQVEsSUFBSTtBQUFBLElBQ3BCO0FBU0EsYUFBUyxLQUFLRSxRQUFPO0FBQ3BCLE1BQUFBLE9BQU0sY0FBYyxDQUFDO0FBRXJCLFlBQU0sT0FBTyxPQUFPLEtBQUssUUFBUSxXQUFXO0FBQzVDLGVBQVMsSUFBSSxHQUFHLElBQUksS0FBSyxRQUFRLEtBQUs7QUFDckMsUUFBQUEsT0FBTSxZQUFZLEtBQUssQ0FBQyxDQUFDLElBQUksUUFBUSxZQUFZLEtBQUssQ0FBQyxDQUFDO0FBQUEsTUFDekQ7QUFBQSxJQUNEO0FBRUEsSUFBQUYsUUFBTyxVQUFVLGlCQUFvQixPQUFPO0FBRTVDLFFBQU0sRUFBQyxXQUFVLElBQUlBLFFBQU87QUFNNUIsZUFBVyxJQUFJLFNBQVUsR0FBRztBQUMzQixXQUFLLFlBQVksU0FBUyxLQUFLO0FBQy9CLGFBQU8sS0FBSyxRQUFRLEdBQUcsS0FBSyxXQUFXLEVBQ3JDLE1BQU0sSUFBSSxFQUNWLElBQUksU0FBTyxJQUFJLEtBQUssQ0FBQyxFQUNyQixLQUFLLEdBQUc7QUFBQSxJQUNYO0FBTUEsZUFBVyxJQUFJLFNBQVUsR0FBRztBQUMzQixXQUFLLFlBQVksU0FBUyxLQUFLO0FBQy9CLGFBQU8sS0FBSyxRQUFRLEdBQUcsS0FBSyxXQUFXO0FBQUEsSUFDeEM7QUFBQTtBQUFBOzs7QUN0UUE7QUFBQSw2Q0FBQUcsU0FBQTtBQUtBLFFBQUksT0FBTyxZQUFZLGVBQWUsUUFBUSxTQUFTLGNBQWMsUUFBUSxZQUFZLFFBQVEsUUFBUSxRQUFRO0FBQ2hILE1BQUFBLFFBQU8sVUFBVTtBQUFBLElBQ2xCLE9BQU87QUFDTixNQUFBQSxRQUFPLFVBQVU7QUFBQSxJQUNsQjtBQUFBO0FBQUE7Ozs7Ozs7Ozs7QUNUQSxRQUFBLE9BQUEsUUFBQSxJQUFBO0FBQ0EsUUFBQSxVQUFBLGdCQUFBLGFBQUE7QUFFQSxRQUFNLE1BQU0sUUFBQSxRQUFNLHNCQUFzQjtBQUV4QyxhQUFTLE1BQU0sTUFBYyxRQUFpQixhQUFvQjtBQUMvRCxVQUFJLGVBQWUsSUFBSTtBQUV2QixVQUFJO0FBQ0QsY0FBTSxPQUFPLEtBQUEsU0FBUyxJQUFJO0FBRTFCLFlBQUksS0FBSyxPQUFNLEtBQU0sUUFBUTtBQUMxQixjQUFJLDZCQUE2QjtBQUNqQyxpQkFBTzs7QUFHVixZQUFJLEtBQUssWUFBVyxLQUFNLGFBQWE7QUFDcEMsY0FBSSxrQ0FBa0M7QUFDdEMsaUJBQU87O0FBR1YsWUFBSSxpRUFBaUU7QUFDckUsZUFBTztlQUNELEdBQVA7QUFDQyxZQUFJLEVBQUUsU0FBUyxVQUFVO0FBQ3RCLGNBQUkscUNBQXFDLENBQUM7QUFDMUMsaUJBQU87O0FBR1YsWUFBSSxjQUFjLENBQUM7QUFDbkIsY0FBTTs7SUFFWjtBQVFBLGFBQWdCQyxRQUFPLE1BQWMsT0FBZSxRQUFBLFVBQVE7QUFDekQsYUFBTyxNQUFNLE9BQU8sT0FBTyxRQUFBLFFBQVEsSUFBSSxPQUFPLFFBQUEsVUFBVSxDQUFDO0lBQzVEO0FBRkEsWUFBQSxTQUFBQTtBQU9hLFlBQUEsT0FBTztBQUtQLFlBQUEsU0FBUztBQUtULFlBQUEsV0FBVyxRQUFBLE9BQU8sUUFBQTs7Ozs7Ozs7Ozs7Ozs7QUN4RC9CLElBQUFDLFVBQUEsY0FBQTs7Ozs7Ozs7OztBQ2dDQSxhQUFnQkMsWUFBUTtBQUNyQixVQUFJO0FBQ0osVUFBSTtBQUNKLFVBQUksU0FBZ0M7QUFFcEMsWUFBTSxVQUFzQixJQUFJLFFBQVcsQ0FBQyxPQUFPLFVBQVM7QUFDekQsZUFBTztBQUNQLGVBQU87TUFDVixDQUFDO0FBRUQsYUFBTztRQUNKO1FBQ0EsS0FBTSxRQUFNO0FBQ1QsY0FBSSxXQUFXLFdBQVc7QUFDdkIscUJBQVM7QUFDVCxpQkFBSyxNQUFNOztRQUVqQjtRQUNBLEtBQU0sT0FBSztBQUNSLGNBQUksV0FBVyxXQUFXO0FBQ3ZCLHFCQUFTO0FBQ1QsaUJBQUssS0FBSzs7UUFFaEI7UUFDQSxJQUFJLFlBQVM7QUFDVixpQkFBTyxXQUFXO1FBQ3JCO1FBQ0EsSUFBSSxTQUFNO0FBQ1AsaUJBQU87UUFDVjs7SUFFTjtBQS9CQSxZQUFBLFdBQUFBO0FBeUNhLFlBQUEsaUJBQWlCQTtBQVM5QixZQUFBLFVBQWVBOzs7OztBQ25GZjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsc0JBVU87OztBS1ZQLHlCQUErQjtBa0JBL0IsbUJBQWdDO0FFQWhDLDJCQUFvQztBaUNDcEMsOEJBQWdEO0E0QkRoRCxJQUFBQywyQkFBMEM7QUdBMUMseUJBQTZCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0F4RkV0QixTQUFTLFlBQVksT0FBaUI7QUFDMUMsUUFBTSxNQUFNLElBQUksT0FBTyxLQUFLO0FBQzVCLFFBQU0sSUFBSSxLQUFLLEtBQUs7QUFFcEIsU0FBTztBQUNWO0FBRU8sU0FBUyxXQUFXLE1BQXdDO0FBQ2hFLFNBQU8sZ0JBQWdCLFVBQVUsTUFBTSxJQUFJLElBQUk7QUFDbEQ7QUFFTyxTQUFTLFFBQVEsVUFBNEI7QUFDakQsU0FBTyxNQUFNLElBQUksUUFBUSxLQUFLLENBQUM7QUFDbEM7QUFmQSxJQUFNO0FBQU4sSUFBQSxnQkFBQSxNQUFBO0VBQUEsNkJBQUE7QUFBQTtBQUFNLFlBQVEsb0JBQUksUUFBMEI7RUFBQTtBQUFBLENBQUE7QUNBNUMsSUEyQmE7QUEzQmIsSUFBQSxpQkFBQSxNQUFBO0VBQUEsZ0NBQUE7QUFBQTtBQTJCYSxlQUFOLGNBQXVCLE1BQU07TUFDakMsWUFDVSxNQUNQLFNBQ0Q7QUFDQyxjQUFNLE9BQU87QUFITixhQUFBLE9BQUE7QUFJUCxlQUFPLGVBQWUsTUFBTSxXQUFXLFNBQVM7TUFDbkQ7SUFDSDtFQUFBO0FBQUEsQ0FBQTtBQ25DQSxJQXNCYTtBQXRCYixJQUFBLDBCQUFBLE1BQUE7RUFBQSx5Q0FBQTtBQUFBO0FBQUEsbUJBQUE7QUFzQmEsdUJBQU4sY0FBd0MsU0FBUztNQUNyRCxZQUltQixLQUNoQixTQUNEO0FBQ0MsY0FBTSxRQUFXLFdBQVcsT0FBTyxHQUFHLENBQUM7QUFIdkIsYUFBQSxNQUFBO01BSW5CO0lBQ0g7RUFBQTtBQUFBLENBQUE7QUNoQ0EsSUFVYTtBQVZiLElBQUEsZ0NBQUEsTUFBQTtFQUFBLCtDQUFBO0FBQUE7QUFBQSxtQkFBQTtBQVVhLDZCQUFOLGNBQXFDLFNBQVM7TUFDbEQsWUFBWSxTQUFrQjtBQUMzQixjQUFNLFFBQVcsT0FBTztNQUMzQjtJQUNIO0VBQUE7QUFBQSxDQUFBO0FDSE8sU0FBUyxXQUFnQyxRQUFvQjtBQUNqRSxTQUFPLE9BQU8sV0FBVyxhQUFhLFNBQVM7QUFDbEQ7QUFNTyxTQUFTLGVBQW1DLFFBQThCO0FBQzlFLFNBQU8sT0FBTyxXQUFXLGNBQWMsV0FBVztBQUNyRDtBQUVPLFNBQVMsUUFBUSxPQUFlLE1BQWdDO0FBQ3BFLFFBQU0sUUFBUSxNQUFNLFFBQVEsSUFBSTtBQUNoQyxNQUFJLFNBQVMsR0FBRztBQUNiLFdBQU8sQ0FBQyxPQUFPLEVBQUU7RUFDcEI7QUFFQSxTQUFPLENBQUMsTUFBTSxPQUFPLEdBQUcsS0FBSyxHQUFHLE1BQU0sT0FBTyxRQUFRLENBQUMsQ0FBQztBQUMxRDtBQUlPLFNBQVMsTUFBTSxPQUEyQixTQUFTLEdBQW1CO0FBQzFFLFNBQU8sWUFBWSxLQUFLLEtBQUssTUFBTSxTQUFTLFNBQVMsTUFBTSxNQUFBLElBQVU7QUFDeEU7QUFLTyxTQUFTLEtBQUssT0FBZ0IsU0FBUyxHQUFHO0FBQzlDLE1BQUksWUFBWSxLQUFLLEtBQUssTUFBTSxTQUFTLFFBQVE7QUFDOUMsV0FBTyxNQUFNLE1BQU0sU0FBUyxJQUFJLE1BQUE7RUFDbkM7QUFDSDtBQUlBLFNBQVMsWUFBWSxPQUFnQztBQUNsRCxTQUFPLENBQUMsRUFBRSxTQUFTLE9BQU8sTUFBTSxXQUFXO0FBQzlDO0FBRU8sU0FBUyxtQkFBbUIsUUFBUSxJQUFJQyxXQUFVLE1BQU0sWUFBWSxNQUFnQjtBQUN4RixTQUFPLE1BQU0sTUFBTSxTQUFTLEVBQUUsT0FBTyxDQUFDLFFBQVEsU0FBUztBQUNwRCxVQUFNLGNBQWNBLFdBQVUsS0FBSyxLQUFLLElBQUk7QUFDNUMsUUFBSSxhQUFhO0FBQ2QsYUFBTyxLQUFLLFdBQVc7SUFDMUI7QUFDQSxXQUFPO0VBQ1YsR0FBRyxDQUFDLENBQWE7QUFDcEI7QUFJTyxTQUFTLHVCQUNiLE9BQ0EsVUFDSTtBQUNKLFNBQU8sbUJBQW1CLE9BQU8sSUFBSSxFQUFFLElBQUksQ0FBQyxTQUFTLFNBQVMsSUFBSSxDQUFDO0FBQ3RFO0FBRU8sU0FBUyxhQUFhLE1BQXVCO0FBQ2pELGFBQU8sMkJBQU8sTUFBTSx5QkFBTTtBQUM3QjtBQUtPLFNBQVMsT0FBVSxRQUFzQixNQUFzQjtBQUNuRSxNQUFJLE1BQU0sUUFBUSxNQUFNLEdBQUc7QUFDeEIsUUFBSSxDQUFDLE9BQU8sU0FBUyxJQUFJLEdBQUc7QUFDekIsYUFBTyxLQUFLLElBQUk7SUFDbkI7RUFDSCxPQUFPO0FBQ0osV0FBTyxJQUFJLElBQUk7RUFDbEI7QUFDQSxTQUFPO0FBQ1Y7QUFLTyxTQUFTLFVBQWEsUUFBYSxNQUF3QjtBQUMvRCxNQUFJLE1BQU0sUUFBUSxNQUFNLEtBQUssQ0FBQyxPQUFPLFNBQVMsSUFBSSxHQUFHO0FBQ2xELFdBQU8sS0FBSyxJQUFJO0VBQ25CO0FBRUEsU0FBTztBQUNWO0FBRU8sU0FBUyxPQUFVLFFBQXNCLE1BQVk7QUFDekQsTUFBSSxNQUFNLFFBQVEsTUFBTSxHQUFHO0FBQ3hCLFVBQU0sUUFBUSxPQUFPLFFBQVEsSUFBSTtBQUNqQyxRQUFJLFNBQVMsR0FBRztBQUNiLGFBQU8sT0FBTyxPQUFPLENBQUM7SUFDekI7RUFDSCxPQUFPO0FBQ0osV0FBTyxPQUFPLElBQUk7RUFDckI7QUFDQSxTQUFPO0FBQ1Y7QUFNTyxTQUFTLFFBQVcsUUFBc0I7QUFDOUMsU0FBTyxNQUFNLFFBQVEsTUFBTSxJQUFJLFNBQVMsQ0FBQyxNQUFNO0FBQ2xEO0FBRU8sU0FBUyxZQUFZLEtBQWE7QUFDdEMsU0FBTyxJQUFJLFFBQVEsY0FBYyxDQUFDLE1BQU0sUUFBUTtBQUM3QyxXQUFPLElBQUksWUFBWTtFQUMxQixDQUFDO0FBQ0o7QUFFTyxTQUFTLGNBQWlCLFFBQTJCO0FBQ3pELFNBQU8sUUFBUSxNQUFNLEVBQUUsSUFBSSxNQUFNO0FBQ3BDO0FBRU8sU0FBUyxTQUFTLFFBQW1DLFFBQVEsR0FBRztBQUNwRSxNQUFJLFVBQVUsTUFBTTtBQUNqQixXQUFPO0VBQ1Y7QUFFQSxRQUFNLE1BQU0sU0FBUyxRQUFRLEVBQUU7QUFDL0IsU0FBTyxNQUFNLEdBQUcsSUFBSSxRQUFRO0FBQy9CO0FBRU8sU0FBUyxjQUFpQixPQUFZLFFBQWdCO0FBQzFELFFBQU0sU0FBYyxDQUFDO0FBQ3JCLFdBQVMsSUFBSSxHQUFHLE1BQU0sTUFBTSxRQUFRLElBQUksS0FBSyxLQUFLO0FBQy9DLFdBQU8sS0FBSyxRQUFRLE1BQU0sQ0FBQSxDQUFFO0VBQy9CO0FBQ0EsU0FBTztBQUNWO0FBRU8sU0FBUyxlQUFlLE9BQWtDO0FBQzlELFVBQVEsTUFBTSxRQUFRLEtBQUssSUFBSSxPQUFPLE9BQU8sS0FBSyxJQUFJLE9BQU8sU0FBUyxPQUFPO0FBQ2hGO0FBS08sU0FBUyxLQUFLLFFBQTZCLFlBQXNCO0FBQ3JFLFNBQU8sT0FBTztJQUNYLENBQUM7SUFDRCxHQUFHLFdBQVcsSUFBSSxDQUFDLGFBQWMsWUFBWSxTQUFTLEVBQUUsQ0FBQyxRQUFBLEdBQVcsT0FBTyxRQUFBLEVBQVUsSUFBSSxDQUFDLENBQUU7RUFDL0Y7QUFDSDtBQUVPLFNBQVMsTUFBTSxXQUFXLEdBQWtCO0FBQ2hELFNBQU8sSUFBSSxRQUFRLENBQUMsU0FBUyxXQUFXLE1BQU0sUUFBUSxDQUFDO0FBQzFEO0FBRU8sU0FBUyxPQUFVLE9BQWtCO0FBQ3pDLE1BQUksVUFBVSxPQUFPO0FBQ2xCLFdBQU87RUFDVjtBQUNBLFNBQU87QUFDVjtBQTNLQSxJQUdhO0FBSGIsSUFLYTtBQUxiLElBaUhhO0FBakhiLElBQUEsWUFBQSxNQUFBO0VBQUEsMEJBQUE7QUFBQTtBQUdhLFdBQU87QUFFUCxXQUFpQyxNQUFNO0lBQUM7QUE0R3hDLHFCQUFpQixPQUFPLFVBQVUsU0FBUyxLQUFLLEtBQUssT0FBTyxVQUFVLFFBQVE7RUFBQTtBQUFBLENBQUE7QUNwR3BGLFNBQVMsV0FBaUIsT0FBVSxRQUFvQyxLQUFtQjtBQUMvRixNQUFJLE9BQU8sS0FBSyxHQUFHO0FBQ2hCLFdBQU87RUFDVjtBQUNBLFNBQU8sVUFBVSxTQUFTLElBQUksTUFBTTtBQUN2QztBQU1PLFNBQVMsaUJBQ2IsT0FDQSxNQUNvQjtBQUNwQixRQUFNLE9BQU8sV0FBVyxLQUFLLElBQUksV0FBVyxPQUFPO0FBRW5ELFNBQ0csd0JBQXdCLEtBQUssSUFBSSxNQUNoQyxDQUFDLFFBQVEsQ0FBQyxLQUFLLFNBQVMsSUFBdUM7QUFFdEU7QUFpQk8sU0FBUyxrQkFBb0MsT0FBZ0M7QUFDakYsU0FBTyxDQUFDLENBQUMsU0FBUyxlQUFlLEtBQUssTUFBTTtBQUMvQztBQUVPLFNBQVMsZUFBZSxPQUFtQztBQUMvRCxTQUFPLE9BQU8sVUFBVTtBQUMzQjtBQXpEQSxJQW9CYTtBQXBCYixJQW9DYTtBQXBDYixJQXdDYTtBQXhDYixJQTRDYTtBQTVDYixJQTJEYTtBQTNEYixJQUFBLHdCQUFBLE1BQUE7RUFBQSxzQ0FBQTtBQUFBO0FBQ0EsY0FBQTtBQUNBLGtCQUFBO0FBa0JhLGtCQUFtRCxDQUFDLFVBQStCO0FBQzdGLGFBQU8sTUFBTSxRQUFRLEtBQUs7SUFDN0I7QUFjYSxtQkFBZ0QsQ0FBQyxVQUEyQjtBQUN0RixhQUFPLE9BQU8sVUFBVTtJQUMzQjtBQUVhLHdCQUF1RCxDQUFDLFVBQTZCO0FBQy9GLGFBQU8sTUFBTSxRQUFRLEtBQUssS0FBSyxNQUFNLE1BQU0sWUFBWTtJQUMxRDtBQUVhLGdDQUF3RSxDQUNsRixVQUM4QjtBQUM5QixhQUFPLGFBQWEsS0FBSyxLQUFNLE1BQU0sUUFBUSxLQUFLLEtBQUssTUFBTSxNQUFNLFlBQVk7SUFDbEY7QUFXYSxzQkFBK0QsQ0FDekUsVUFDK0I7QUFDL0IsVUFBSSxTQUFTLFFBQVEsMEJBQTBCLFNBQVMsT0FBTyxLQUFLLEdBQUc7QUFDcEUsZUFBTztNQUNWO0FBQ0EsYUFBTyxNQUFNLFFBQVEsS0FBSyxLQUFLLE9BQU8sVUFBVSxZQUFZLE9BQU8sTUFBTSxXQUFXO0lBQ3ZGO0VBQUE7QUFBQSxDQUFBO0FDbEVBLElBSVk7QUFKWixJQUFBLGtCQUFBLE1BQUE7RUFBQSxnQ0FBQTtBQUFBO0FBSVksZ0JBQUwsa0JBQUtDLGVBQUw7QUFDSkEsaUJBQUFBLFdBQUEsU0FBQSxJQUFBLENBQUEsSUFBQTtBQUNBQSxpQkFBQUEsV0FBQSxPQUFBLElBQUEsQ0FBQSxJQUFBO0FBQ0FBLGlCQUFBQSxXQUFBLFdBQUEsSUFBWSxFQUFBLElBQVo7QUFDQUEsaUJBQUFBLFdBQUEsU0FBQSxJQUFVLEdBQUEsSUFBVjtBQUpTLGFBQUFBO0lBQUEsR0FBQSxhQUFBLENBQUEsQ0FBQTtFQUFBO0FBQUEsQ0FBQTtBQ0paLElBRWE7QUFGYixJQUFBLDBCQUFBLE1BQUE7RUFBQSx3Q0FBQTtBQUFBO0FBRWEsdUJBQU4sTUFBOEQ7TUFDbEUsWUFDbUIsUUFDQSxRQUNqQjtBQUZpQixhQUFBLFNBQUE7QUFDQSxhQUFBLFNBQUE7TUFDaEI7TUFFSCxZQUFzQztBQUNuQyxlQUFPLElBQUksaUJBQWlCLEtBQUssT0FBTyxTQUFTLE1BQU0sR0FBRyxLQUFLLE9BQU8sU0FBUyxNQUFNLENBQUM7TUFDekY7SUFDSDtFQUFBO0FBQUEsQ0FBQTtBQ1hBLElBQWE7QUFBYixJQW9EYTtBQXBEYixJQUFBLG1CQUFBLE1BQUE7RUFBQSxpQ0FBQTtBQUFBO0FBQWEsaUJBQU4sTUFBb0I7TUFLeEIsWUFDRyxRQUNBLFlBQ0Q7QUFQRixhQUFVLFVBQW9CLENBQUM7QUFjL0IsYUFBQSxRQUFRLENBQUMsTUFBOEMsV0FBdUI7QUFDM0UsZUFBSyxhQUFhO0FBRWxCLGNBQUksQ0FBQyxLQUFLLFFBQVEsTUFBTSxDQUFDLEtBQUssVUFBVSxLQUFLLFNBQVMsS0FBSyxPQUFPLEtBQUssS0FBSyxDQUFDLENBQUMsR0FBRztBQUM5RSxtQkFBTztVQUNWO0FBRUEsaUJBQU8sS0FBSyxXQUFXLFFBQVEsS0FBSyxlQUFlLENBQUMsTUFBTTtRQUM3RDtBQWRHLGFBQUssVUFBVSxNQUFNLFFBQVEsTUFBTSxJQUFJLFNBQVMsQ0FBQyxNQUFNO0FBQ3ZELFlBQUksWUFBWTtBQUNiLGVBQUssYUFBYTtRQUNyQjtNQUNIO01BYVUsV0FBVyxRQUFXLE9BQWlDO0FBQzlELGNBQU0sSUFBSSxNQUFNLHVDQUF1QztNQUMxRDtNQUVVLGVBQWU7QUFDdEIsYUFBSyxRQUFRLFNBQVM7TUFDekI7TUFFVSxpQkFBaUI7QUFDeEIsZUFBTyxLQUFLO01BQ2Y7TUFFVSxTQUFTLEtBQWEsT0FBZSxNQUFlO0FBQzNELGNBQU0sVUFBVSxRQUFRLElBQUksS0FBSyxJQUFJO0FBQ3JDLFlBQUksU0FBUztBQUNWLGVBQUssVUFBVSxPQUFPLE9BQU87UUFDaEM7QUFFQSxlQUFPLENBQUMsQ0FBQztNQUNaO01BRVUsVUFBVSxRQUFnQixTQUFtQjtBQUNwRCxhQUFLLFFBQVEsS0FBSyxHQUFHLFFBQVEsTUFBTSxDQUFDLENBQUM7TUFDeEM7SUFDSDtBQUVhLHVCQUFOLGNBQWtDLFdBQWM7TUFDMUMsU0FBUyxLQUFhLE9BQWUsTUFBd0I7QUFDcEUsZUFBTyxhQUFhLEtBQUssT0FBTyxJQUFJLENBQUMsS0FBSyxNQUFNLFNBQVMsS0FBSyxPQUFPLElBQUk7TUFDNUU7TUFFVSxVQUFVLE9BQWUsU0FBbUI7QUFDbkQsWUFBSSxRQUFRLEtBQUssUUFBUSxTQUFTLEdBQUc7QUFDbEMsZ0JBQU0sVUFBVSxPQUFPLE9BQU87UUFDakM7TUFDSDtJQUNIO0VBQUE7QUFBQSxDQUFBO0FDckRPLFNBQVMsd0JBQ1YsU0FDYztBQUNqQixRQUFNLFVBQVUsUUFBUSxJQUFJO0FBQzVCLFFBQU0sU0FBMkIsT0FBTztJQUNyQyxlQUFBLEVBQUUsUUFBQSxHQUFZLGNBQUE7SUFDZCxHQUFHLFFBQVEsT0FBTyxDQUFDLE1BQU0sT0FBTyxNQUFNLFlBQVksQ0FBQztFQUN0RDtBQUVBLFNBQU8sVUFBVSxPQUFPLFdBQVc7QUFDbkMsU0FBTyxVQUFVLE9BQU8sWUFBWTtBQUVwQyxTQUFPO0FBQ1Y7QUF0QkEsSUFFTTtBQUZOLElBQUEsMEJBQUEsTUFBQTtFQUFBLHdDQUFBO0FBQUE7QUFFTSxxQkFBb0Q7TUFDdkQsUUFBUTtNQUNSLHdCQUF3QjtNQUN4QixRQUFRLENBQUM7TUFDVCxTQUFTO0lBQ1o7RUFBQTtBQUFBLENBQUE7QUNJTyxTQUFTLGtCQUNiLFNBQ0EsV0FBcUIsQ0FBQyxHQUNiO0FBQ1QsTUFBSSxDQUFDLGtCQUEyQixPQUFPLEdBQUc7QUFDdkMsV0FBTztFQUNWO0FBRUEsU0FBTyxPQUFPLEtBQUssT0FBTyxFQUFFLE9BQU8sQ0FBQ0MsV0FBb0IsUUFBZ0I7QUFDckUsVUFBTSxRQUF1QixRQUFRLEdBQUE7QUFFckMsUUFBSSxXQUFXLEtBQUssR0FBRztBQUNwQkEsZ0JBQVMsS0FBSyxLQUFLO0lBQ3RCLFdBQVcsaUJBQWlCLE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRztBQUM5Q0EsZ0JBQVMsS0FBSyxNQUFNLE1BQU0sS0FBSztJQUNsQyxPQUFPO0FBQ0pBLGdCQUFTLEtBQUssR0FBRztJQUNwQjtBQUVBLFdBQU9BO0VBQ1YsR0FBRyxRQUFRO0FBQ2Q7QUFFTyxTQUFTLG1CQUNiLE1BQ0EsbUJBQW1CLEdBQ25CLGFBQWEsT0FDSjtBQUNULFFBQU0sVUFBb0IsQ0FBQztBQUUzQixXQUFTLElBQUksR0FBRyxNQUFNLG1CQUFtQixJQUFJLEtBQUssU0FBUyxrQkFBa0IsSUFBSSxLQUFLLEtBQUs7QUFDeEYsUUFBSSxnQkFBZ0IsU0FBUyxPQUFPLEtBQUssQ0FBQSxDQUFFLEdBQUc7QUFDM0MsY0FBUSxLQUFLLE9BQU8sS0FBSyxDQUFBLENBQUUsQ0FBQztJQUMvQjtFQUNIO0FBRUEsb0JBQWtCLHdCQUF3QixJQUFJLEdBQUcsT0FBTztBQUN4RCxNQUFJLENBQUMsWUFBWTtBQUNkLFlBQVEsS0FBSyxHQUFHLHNCQUFzQixJQUFJLENBQUM7RUFDOUM7QUFFQSxTQUFPO0FBQ1Y7QUFFQSxTQUFTLHNCQUFzQixNQUFrQjtBQUM5QyxRQUFNLHNCQUFzQixPQUFPLEtBQUssSUFBSSxNQUFNO0FBQ2xELFNBQU8sV0FBVyxLQUFLLE1BQU0sc0JBQXNCLElBQUksQ0FBQyxHQUFHLGFBQWEsQ0FBQyxDQUFDO0FBQzdFO0FBTU8sU0FBUyx3QkFBd0IsTUFBa0M7QUFDdkUsUUFBTSxzQkFBc0IsZUFBZSxLQUFLLElBQUksQ0FBQztBQUNyRCxTQUFPLFdBQVcsS0FBSyxNQUFNLHNCQUFzQixJQUFJLENBQUMsR0FBRyxpQkFBaUI7QUFDL0U7QUFNTyxTQUFTLHlCQUNiLE1BQ0EsY0FBYyxNQUNxQjtBQUNuQyxRQUFNLFdBQVcsV0FBVyxLQUFLLElBQUksQ0FBQztBQUN0QyxTQUFPLGVBQWUsZUFBZSxRQUFRLElBQUksV0FBVztBQUMvRDtBQS9FQSxJQUFBLG9CQUFBLE1BQUE7RUFBQSxrQ0FBQTtBQUFBO0FBQUEsMEJBQUE7QUFPQSxjQUFBO0FBRUEsa0JBQUE7RUFBQTtBQUFBLENBQUE7QUNKTyxTQUFTLGVBQ2JDLFNBQ0EsU0FDRDtBQUNDLFNBQU9BLFFBQU8sUUFBUSxRQUFRLFFBQVEsTUFBTTtBQUMvQztBQUVPLFNBQVMsb0JBQ2IsUUFDQUMsV0FDQSxPQUNBLE9BQU8sTUFDTDtBQUNGLFVBQVEsS0FBSyxFQUFFLFFBQVEsQ0FBQyxTQUFTO0FBQzlCLGFBQVMsUUFBUSxtQkFBbUIsTUFBTSxJQUFJLEdBQUcsSUFBSSxHQUFHLE1BQU0sTUFBTSxRQUFRLElBQUksS0FBSyxLQUFLO0FBQ3ZGLFlBQU0sT0FBTyxDQUFDLFNBQVMsTUFBTTtBQUMxQixZQUFJLElBQUksVUFBVSxLQUFLO0FBQ3BCO1FBQ0g7QUFDQSxlQUFPLE1BQU0sSUFBSSxNQUFBO01BQ3BCO0FBRUFBLGdCQUFRLEtBQUssQ0FBQyxFQUFFLE1BQU0sTUFBTSxNQUFNLE1BQU0sTUFBTSxDQUFDO0lBQ2xEO0VBQ0gsQ0FBQztBQUVELFNBQU87QUFDVjtBQWhDQSxJQUFBLG1CQUFBLE1BQUE7RUFBQSxpQ0FBQTtBQUFBO0FBR0EsY0FBQTtFQUFBO0FBQUEsQ0FBQTtBQ0hBLElBQUEsZ0JBQUEsQ0FBQTtBQUFBQyxVQUFBLGVBQUE7RUFBQSxXQUFBLE1BQUE7RUFBQSxrQkFBQSxNQUFBO0VBQUEsWUFBQSxNQUFBO0VBQUEsTUFBQSxNQUFBO0VBQUEsTUFBQSxNQUFBO0VBQUEsa0JBQUEsTUFBQTtFQUFBLFFBQUEsTUFBQTtFQUFBLG1CQUFBLE1BQUE7RUFBQSxTQUFBLE1BQUE7RUFBQSxhQUFBLE1BQUE7RUFBQSxZQUFBLE1BQUE7RUFBQSxVQUFBLE1BQUE7RUFBQSxlQUFBLE1BQUE7RUFBQSxnQkFBQSxNQUFBO0VBQUEsZ0JBQUEsTUFBQTtFQUFBLHNCQUFBLE1BQUE7RUFBQSxPQUFBLE1BQUE7RUFBQSxhQUFBLE1BQUE7RUFBQSxnQkFBQSxNQUFBO0VBQUEsaUJBQUEsTUFBQTtFQUFBLG1CQUFBLE1BQUE7RUFBQSxrQkFBQSxNQUFBO0VBQUEsY0FBQSxNQUFBO0VBQUEsbUJBQUEsTUFBQTtFQUFBLDJCQUFBLE1BQUE7RUFBQSxZQUFBLE1BQUE7RUFBQSxPQUFBLE1BQUE7RUFBQSxjQUFBLE1BQUE7RUFBQSx3QkFBQSxNQUFBO0VBQUEsb0JBQUEsTUFBQTtFQUFBLFdBQUEsTUFBQTtFQUFBLGdCQUFBLE1BQUE7RUFBQSxNQUFBLE1BQUE7RUFBQSxnQkFBQSxNQUFBO0VBQUEsUUFBQSxNQUFBO0VBQUEscUJBQUEsTUFBQTtFQUFBLE1BQUEsTUFBQTtFQUFBLGVBQUEsTUFBQTtFQUFBLFFBQUEsTUFBQTtFQUFBLFNBQUEsTUFBQTtFQUFBLG9CQUFBLE1BQUE7RUFBQSwwQkFBQSxNQUFBO0VBQUEseUJBQUEsTUFBQTtBQUFBLENBQUE7QUFBQSxJQUFBLGFBQUEsTUFBQTtFQUFBLDJCQUFBO0FBQUE7QUFBQSwwQkFBQTtBQUNBLG9CQUFBO0FBQ0EsNEJBQUE7QUFDQSxxQkFBQTtBQUNBLDRCQUFBO0FBQ0Esc0JBQUE7QUFDQSxxQkFBQTtBQUNBLGNBQUE7RUFBQTtBQUFBLENBQUE7QUNQQSxJQUFBLHdCQUFBLENBQUE7QUFBQUEsVUFBQSx1QkFBQTtFQUFBLGtCQUFBLE1BQUE7RUFBQSxxQkFBQSxNQUFBO0VBQUEscUJBQUEsTUFBQTtFQUFBLGlCQUFBLE1BQUE7QUFBQSxDQUFBO0FBcUJPLFNBQVMsZ0JBQWdCLFFBQXNEO0FBQ25GLFVBQVEsUUFBQTtJQUFBLEtBQ0E7QUFDRixhQUFPLG9CQUFvQjtJQUFBLEtBQ3pCO0FBQ0YsYUFBTyxvQkFBb0I7RUFBQTtBQUdqQyxRQUFNLFdBQVcsQ0FBQyxhQUFhLHVCQUF1QjtBQUV0RCxTQUFPO0lBQ0o7SUFDQSxRQUFRO0lBQ1I7SUFDQTtFQUNIO0FBQ0g7QUFFTyxTQUFTLHNCQUEyQztBQUN4RCxRQUFNLFdBQVcsQ0FBQyxhQUFhLFdBQVc7QUFFMUMsU0FBTztJQUNKO0lBQ0EsUUFBUTtJQUNSO0lBQ0EsT0FBTyxNQUFNO0FBQ1YsYUFBTyxhQUFhLEtBQUssS0FBSyxLQUFLLENBQUM7SUFDdkM7RUFDSDtBQUNIO0FBRU8sU0FBUyxzQkFBMkM7QUFDeEQsUUFBTSxXQUFXLENBQUMsYUFBYSxzQkFBc0I7QUFFckQsU0FBTztJQUNKO0lBQ0EsUUFBUTtJQUNSO0lBQ0E7RUFDSDtBQUNIO0FBRUEsU0FBUyxpQkFBaUIsT0FBdUI7QUFDOUMsU0FBTyw4Q0FBOEMsS0FBSyxPQUFPLEtBQUssQ0FBQztBQUMxRTtBQWpFQSxJQUdZO0FBSFosSUFTTTtBQVROLElBaUJNO0FBakJOLElBQUEscUJBQUEsTUFBQTtFQUFBLG1DQUFBO0FBQUE7QUFBQSxlQUFBO0FBR1ksdUJBQUwsa0JBQUtDLHNCQUFMO0FBQ0pBLHdCQUFBLE1BQUEsSUFBTztBQUNQQSx3QkFBQSxTQUFBLElBQVU7QUFDVkEsd0JBQUEsY0FBQSxJQUFlO0FBSE4sYUFBQUE7SUFBQSxHQUFBLG9CQUFBLENBQUEsQ0FBQTtBQU1OLGNBQTBDLENBQUMsRUFBRSxTQUFTLEdBQUcsT0FBTyxNQUFNLFNBQVM7QUFDbEYsVUFBSSxhQUFBLE9BQWtDLGlCQUFpQixLQUFLLEdBQUc7QUFDNUQsZUFBTyxLQUFLLE9BQU8sS0FBSyxPQUFPLENBQUM7TUFDbkM7QUFFQSxXQUFLLEtBQUs7SUFDYjtBQUVNLGFBQXdDLENBQUMsU0FBUztBQUNyRCxhQUFPLEtBQUssS0FBSyxNQUFNO0lBQzFCO0VBQUE7QUFBQSxDQUFBO0FDSk8sU0FBUyxtQkFBbUIsUUFBaUIsTUFBNEI7QUFDN0UsUUFBTSxVQUFVLElBQUksY0FBYyxNQUFNO0FBQ3hDLFFBQU0sU0FBUyxTQUFTLHNCQUFzQjtBQUU5QyxxQkFBbUIsSUFBSSxFQUFFLFFBQVEsQ0FBQyxTQUFTO0FBQ3hDLFVBQU0sVUFBVSxLQUFLLFFBQVEsUUFBUSxFQUFFO0FBRXZDLFlBQVEsTUFBTSxLQUFLLE9BQU87QUFDMUIsS0FBQyxlQUFlLEtBQUssT0FBTyxJQUFJLFFBQVEsVUFBVSxRQUFRLE9BQU8sS0FBSyxPQUFPO0VBQ2hGLENBQUM7QUFFRCxTQUFPO0FBQ1Y7QUEzQkEsSUFHYTtBQUhiLElBV007QUFYTixJQVlNO0FBWk4sSUFhTTtBQWJOLElBQUEsb0JBQUEsTUFBQTtFQUFBLHNDQUFBO0FBQUE7QUFDQSxlQUFBO0FBRWEsb0JBQU4sTUFBNEM7TUFLaEQsWUFBNEIsUUFBaUI7QUFBakIsYUFBQSxTQUFBO0FBSjVCLGFBQU8sUUFBa0IsQ0FBQztBQUMxQixhQUFPLFFBQWtCLENBQUM7QUFDMUIsYUFBTyxVQUFvQixDQUFDO01BRWtCO0lBQ2pEO0FBRU0sb0JBQWdCO0FBQ2hCLDBCQUFzQjtBQUN0QixxQkFBaUI7RUFBQTtBQUFBLENBQUE7QUNidkIsSUFBQSxlQUFBLENBQUE7QUFBQUQsVUFBQSxjQUFBO0VBQUEsZ0JBQUEsTUFBQTtFQUFBLGVBQUEsTUFBQTtFQUFBLHdCQUFBLE1BQUE7RUFBQSxjQUFBLE1BQUE7RUFBQSxhQUFBLE1BQUE7RUFBQSwyQkFBQSxNQUFBO0VBQUEsMkJBQUEsTUFBQTtBQUFBLENBQUE7QUFZTyxTQUFTLGNBQWNGLFNBQW9DO0FBQy9ELFNBQU87SUFDSixVQUFVO0lBQ1YsUUFBUTtJQUNSLFFBQUFBO0VBQ0g7QUFDSDtBQUVPLFNBQVMsdUJBQXVCLE9BQWtDO0FBQ3RFLFNBQU87SUFDSixVQUFVO0lBQ1YsUUFBUTtJQUNSLFNBQVM7QUFDTixZQUFNLE9BQU8sVUFBVSxXQUFXLElBQUksdUJBQXVCLEtBQUssSUFBSTtJQUN6RTtFQUNIO0FBQ0g7QUFFTyxTQUFTLDBCQUEwQixVQUFvQkgsV0FBVSxPQUEyQjtBQUNoRyxTQUFPO0lBQ0o7SUFDQSxRQUFRO0lBQ1IsT0FBTyxNQUFNO0FBQ1YsYUFBT0EsV0FBVSxPQUFPLElBQUksRUFBRSxLQUFLLElBQUk7SUFDMUM7RUFDSDtBQUNIO0FBRU8sU0FBUywwQkFBMEIsVUFBcUM7QUFDNUUsU0FBTztJQUNKO0lBQ0EsUUFBUTtJQUNSLE9BQU8sUUFBUTtBQUNaLGFBQU87SUFDVjtFQUNIO0FBQ0g7QUFFTyxTQUFTLGFBQWdCLE1BQStDO0FBQzVFLFNBQU8sS0FBSyxXQUFXO0FBQzFCO0FBRU8sU0FBUyxZQUFlLE1BQTJDO0FBQ3ZFLFNBQU8sS0FBSyxXQUFXLFdBQVcsQ0FBQyxLQUFLLFNBQVM7QUFDcEQ7QUF4REEsSUFHYTtBQUhiLElBQUEsWUFBQSxNQUFBO0VBQUEsMEJBQUE7QUFBQTtBQUFBLGtDQUFBO0FBR2EscUJBQXFCLENBQUM7RUFBQTtBQUFBLENBQUE7QUNIbkMsSUFBQSxnQkFBQSxDQUFBO0FBQUFLLFVBQUEsZUFBQTtFQUFBLCtCQUFBLE1BQUE7RUFBQSw0QkFBQSxNQUFBO0VBQUEsNkJBQUEsTUFBQTtFQUFBLGNBQUEsTUFBQTtFQUFBLFdBQUEsTUFBQTtFQUFBLHNCQUFBLE1BQUE7RUFBQSxxQkFBQSxNQUFBO0FBQUEsQ0FBQTtBQWtDTyxTQUFTLHFCQUFxQixNQUEwQixZQUFzQjtBQUNsRixRQUFNLEVBQUUsV0FBVyxTQUFTLE1BQU0sSUFBSSxnQkFBZ0IsSUFBSTtBQUUxRCxNQUFJLENBQUMsV0FBVztBQUNiLFdBQU8sdUJBQXVCLDBCQUEwQjtFQUMzRDtBQUVBLE1BQUksQ0FBQyxNQUFNLFNBQVM7QUFDakIsV0FBTyx1QkFBdUIsOEJBQThCLEtBQUssVUFBVSxJQUFJLENBQUM7RUFDbkY7QUFFQSxVQUFRLEtBQUssR0FBRyxVQUFVO0FBRTFCLE1BQUksUUFBUSxLQUFLLGlCQUFpQixHQUFHO0FBQ2xDLFdBQU8sdUJBQXVCLDZCQUE2QjtFQUM5RDtBQUVBLFNBQU8sVUFBVSxXQUFXLE9BQU87QUFDdEM7QUFFTyxTQUFTLFVBQVUsTUFBaUIsWUFBZ0Q7QUFDeEYsUUFBTSxXQUFxQixDQUFDLFNBQVMsSUFBSSxRQUFRLEdBQUcsVUFBVTtBQUU5RCxTQUFPO0lBQ0o7SUFDQSxRQUFRO0lBQ1IsT0FBTyxNQUE0QjtBQUNoQyxhQUFPLG1CQUFtQixTQUFTLEtBQXNCLElBQUk7SUFDaEU7RUFDSDtBQUNIO0FBRU8sU0FBUyxvQkFBb0IsT0FBMEM7QUFDM0UsU0FBTyxNQUFNLFFBQVEsS0FBSyxLQUFLLE1BQU0sTUFBTSxDQUFDLFNBQVMsa0JBQWtCLElBQUksSUFBSSxDQUFDO0FBQ25GO0FBRUEsU0FBUyxnQkFBZ0IsT0FBZTtBQUNyQyxNQUFJO0FBQ0osTUFBSSxVQUFvQixDQUFDO0FBQ3pCLE1BQUksUUFBUSxFQUFFLFdBQVcsT0FBTyxTQUFTLEtBQUs7QUFFOUMsUUFDSSxRQUFRLFlBQVksRUFBRSxFQUN0QixNQUFNLEVBQUUsRUFDUixRQUFRLENBQUMsU0FBUztBQUNoQixRQUFJLFlBQVksSUFBSSxHQUFHO0FBQ3BCLGtCQUFZO0FBQ1osWUFBTSxZQUFZO0lBQ3JCLE9BQU87QUFDSixZQUFNLFVBQVUsTUFBTSxXQUFXLGNBQWUsUUFBUSxRQUFRLE1BQUEsSUFBVSxJQUFJLE1BQU87SUFDeEY7RUFDSCxDQUFDO0FBRUosU0FBTztJQUNKO0lBQ0E7SUFDQTtFQUNIO0FBQ0g7QUFFQSxTQUFTLFlBQVksV0FBNEM7QUFDOUQsU0FBTyxjQUFjLE9BQXNCLGNBQWM7QUFDNUQ7QUFFQSxTQUFTLGNBQWMsUUFBeUI7QUFDN0MsU0FBTyxZQUFZLEtBQUssTUFBTSxLQUFLLGtCQUFrQixJQUFJLE9BQU8sT0FBTyxDQUFDLENBQUM7QUFDNUU7QUFFQSxTQUFTLGtCQUFrQixRQUF5QjtBQUNqRCxNQUFJLFVBQVUsS0FBSyxNQUFNLEdBQUc7QUFDekIsV0FBTyxPQUFPLFFBQVEsR0FBRyxJQUFJO0VBQ2hDO0FBRUEsU0FBTyxXQUFXO0FBQ3JCO0FBNUdBLElBTWE7QUFOYixJQU9hO0FBUGIsSUFRYTtBQVJiLElBYVk7QUFiWixJQTZCTTtBQTdCTixJQUFBLGFBQUEsTUFBQTtFQUFBLDJCQUFBO0FBQUE7QUFDQSxzQkFBQTtBQUVBLGVBQUE7QUFDQSxjQUFBO0FBRWEsb0NBQWdDO0FBQ2hDLGlDQUE2QjtBQUM3QixrQ0FBOEI7QUFLL0IsbUJBQUwsa0JBQUtFLGtCQUFMO0FBQ0pBLG9CQUFBLFNBQUEsSUFBVTtBQUNWQSxvQkFBQSxPQUFBLElBQVE7QUFDUkEsb0JBQUEsa0JBQUEsSUFBbUI7QUFDbkJBLG9CQUFBLGNBQUEsSUFBZTtBQUNmQSxvQkFBQSxXQUFBLElBQVk7QUFDWkEsb0JBQUEsT0FBQSxJQUFRO0FBQ1JBLG9CQUFBLFdBQUEsSUFBWTtBQVBILGFBQUFBO0lBQUEsR0FBQSxnQkFBQSxDQUFBLENBQUE7QUFnQk4sd0JBQWlDLG9CQUFJLElBQUk7TUFDNUM7TUFDQSxHQUFHLGNBQWMsT0FBTyxPQUFPLFlBQW1CLENBQUM7SUFDdEQsQ0FBQztFQUFBO0FBQUEsQ0FBQTtBQ2FNLFNBQVMsaUJBQWlCLE1BQTBCO0FBQ3hELFFBQU0sU0FBUyxJQUFJLFdBQVc7QUFFOUIsYUFBVyxRQUFRLGFBQWEsSUFBSSxHQUFHO0FBQ3BDLFdBQU8sU0FBUyxLQUFLLE1BQU0sT0FBTyxLQUFLLEdBQUcsR0FBRyxLQUFLLEtBQUs7RUFDMUQ7QUFFQSxTQUFPO0FBQ1Y7QUFFTyxTQUFTLGdCQUFnQixNQUFjLEtBQThCO0FBQ3pFLE1BQUksUUFBdUI7QUFDM0IsUUFBTSxTQUFtQixDQUFDO0FBQzFCLFFBQU0sU0FBZ0Msb0JBQUksSUFBSTtBQUU5QyxhQUFXLFFBQVEsYUFBYSxNQUFNLEdBQUcsR0FBRztBQUN6QyxRQUFJLEtBQUssUUFBUSxLQUFLO0FBQ25CO0lBQ0g7QUFFQSxXQUFPLEtBQU0sUUFBUSxLQUFLLEtBQU07QUFFaEMsUUFBSSxDQUFDLE9BQU8sSUFBSSxLQUFLLElBQUksR0FBRztBQUN6QixhQUFPLElBQUksS0FBSyxNQUFNLENBQUMsQ0FBQztJQUMzQjtBQUVBLFdBQU8sSUFBSSxLQUFLLElBQUksRUFBRyxLQUFLLEtBQUs7RUFDcEM7QUFFQSxTQUFPO0lBQ0o7SUFDQSxPQUFPLE1BQU0sS0FBSyxPQUFPLEtBQUssQ0FBQztJQUMvQjtJQUNBO0lBQ0E7RUFDSDtBQUNIO0FBRUEsU0FBUyxlQUFlLFVBQTBCO0FBQy9DLFNBQU8sU0FBUyxRQUFRLFlBQVksRUFBRTtBQUN6QztBQUVBLFVBQVUsYUFBYSxNQUFjLGVBQThCLE1BQU07QUFDdEUsUUFBTSxRQUFRLEtBQUssTUFBTSxJQUFJO0FBRTdCLFdBQVMsSUFBSSxHQUFHLE1BQU0sTUFBTSxTQUFTLEdBQUcsSUFBSSxPQUFPO0FBQ2hELFVBQU0sT0FBTyxlQUFlLE1BQU0sR0FBQSxDQUFJO0FBRXRDLFFBQUksUUFBUSxNQUFNLEdBQUE7QUFDbEIsUUFBSSxNQUFNO0FBRVYsUUFBSSxNQUFNLFNBQVMsSUFBSSxHQUFHO0FBQ3ZCLFlBQU0sT0FBTyxRQUFRLE9BQU8sSUFBSTtBQUNoQyxZQUFNLEtBQUssQ0FBQTtBQUNYLGNBQVEsS0FBSyxDQUFBO0lBQ2hCO0FBRUEsVUFBTSxFQUFFLE1BQU0sS0FBSyxNQUFNO0VBQzVCO0FBQ0g7QUF4R0EsSUFHYTtBQUhiLElBQUEsa0JBQUEsTUFBQTtFQUFBLG9DQUFBO0FBQUE7QUFDQSxlQUFBO0FBRWEsaUJBQU4sTUFBOEM7TUFBOUMsY0FBQTtBQUNKLGFBQU8sUUFBa0IsQ0FBQztBQUMxQixhQUFPLFNBQStDLHVCQUFPLE9BQU8sSUFBSTtNQUFBO01BSXhFLElBQVcsTUFBb0I7QUFDNUIsWUFBSSxDQUFDLEtBQUssTUFBTTtBQUNiLGVBQUssT0FBTyxLQUFLLE1BQU0sT0FBTyxDQUFDLEtBQW1CLFNBQWlCO0FBQ2hFLG1CQUFPLE9BQU8sT0FBTyxLQUFLLEtBQUssT0FBTyxJQUFBLENBQUs7VUFDOUMsR0FBRyxDQUFDLENBQUM7UUFDUjtBQUVBLGVBQU8sS0FBSztNQUNmO01BRU8sUUFBUSxNQUE0QjtBQUN4QyxZQUFJLEVBQUUsUUFBUSxLQUFLLFNBQVM7QUFDekIsZ0JBQU0sU0FBUyxLQUFLLEtBQUssS0FBSztBQUM5QixlQUFLLE9BQU8sSUFBQSxJQUFRLFNBQVMsT0FBTyxPQUFPLEtBQUssT0FBTyxNQUFBLENBQU8sSUFBSSxDQUFDO0FBRW5FLGVBQUssTUFBTSxLQUFLLElBQUk7UUFDdkI7QUFFQSxlQUFPLEtBQUssT0FBTyxJQUFBO01BQ3RCO01BRU8sU0FBUyxNQUFjLEtBQWEsT0FBZTtBQUN2RCxjQUFNLFNBQVMsS0FBSyxRQUFRLElBQUk7QUFFaEMsWUFBSSxDQUFDLE9BQU8sZUFBZSxHQUFHLEdBQUc7QUFDOUIsaUJBQU8sR0FBQSxJQUFPO1FBQ2pCLFdBQVcsTUFBTSxRQUFRLE9BQU8sR0FBQSxDQUFJLEdBQUc7QUFDbkMsaUJBQU8sR0FBQSxFQUFrQixLQUFLLEtBQUs7UUFDdkMsT0FBTztBQUNKLGlCQUFPLEdBQUEsSUFBTyxDQUFDLE9BQU8sR0FBQSxHQUFnQixLQUFLO1FBQzlDO0FBRUEsYUFBSyxPQUFPO01BQ2Y7SUFDSDtFQUFBO0FBQUEsQ0FBQTtBQzlCQSxTQUFTLGNBQ04sT0FDQSxVQUNtQjtBQUNuQixNQUFJLE9BQU8sVUFBVSxZQUFZLGVBQWUsZUFBZSxLQUFLLEdBQUc7QUFDcEUsV0FBTztFQUNWO0FBQ0EsU0FBTztBQUNWO0FBRUEsU0FBUyxjQUNOLEtBQ0EsT0FDQUMsU0FDQSxPQUNtQjtBQUNuQixRQUFNLFdBQXFCLENBQUMsVUFBVSxLQUFLLE9BQU87QUFFbEQsTUFBSUEsU0FBUTtBQUNULGFBQVMsS0FBSyxPQUFPO0VBQ3hCO0FBRUEsV0FBUyxLQUFLLEtBQUssS0FBSztBQUV4QixTQUFPO0lBQ0o7SUFDQSxRQUFRO0lBQ1IsT0FBTyxNQUFzQjtBQUMxQixhQUFPO0lBQ1Y7RUFDSDtBQUNIO0FBRUEsU0FBUyxjQUFjLEtBQWEsT0FBcUQ7QUFDdEYsUUFBTSxXQUFxQixDQUFDLFVBQVUsVUFBVSxpQkFBaUIsYUFBYSxHQUFHO0FBRWpGLE1BQUksT0FBTztBQUNSLGFBQVMsT0FBTyxHQUFHLEdBQUcsS0FBSyxPQUFPO0VBQ3JDO0FBRUEsU0FBTztJQUNKO0lBQ0EsUUFBUTtJQUNSLE9BQU8sTUFBTTtBQUNWLGFBQU8sZ0JBQWdCLE1BQU0sR0FBRztJQUNuQztFQUNIO0FBQ0g7QUFFQSxTQUFTLGVBQWUsT0FBdUQ7QUFDNUUsUUFBTSxXQUFXLENBQUMsVUFBVSxVQUFVLGlCQUFpQixRQUFRO0FBRS9ELE1BQUksT0FBTztBQUNSLGFBQVMsS0FBSyxLQUFLLE9BQU87RUFDN0I7QUFFQSxTQUFPO0lBQ0o7SUFDQSxRQUFRO0lBQ1IsT0FBTyxNQUFjO0FBQ2xCLGFBQU8saUJBQWlCLElBQUk7SUFDL0I7RUFDSDtBQUNIO0FBRWUsU0FBUixpQkFBK0U7QUFDbkYsU0FBTztJQUNKLFVBQThCLEtBQWEsVUFBa0IsTUFBaUI7QUFDM0UsYUFBTyxLQUFLO1FBQ1Q7VUFDRztVQUNBO1VBQ0EsS0FBSyxDQUFBLE1BQU87VUFDWjtZQUFjLEtBQUssQ0FBQTtZQUFJOztVQUFvQjtRQUM5QztRQUNBLHlCQUF5QixTQUFTO01BQ3JDO0lBQ0g7SUFFQSxVQUE4QixLQUFhLE9BQXdCO0FBQ2hFLGFBQU8sS0FBSztRQUNULGNBQWMsS0FBSyxjQUFjLE9BQU8sTUFBUyxDQUFDO1FBQ2xELHlCQUF5QixTQUFTO01BQ3JDO0lBQ0g7SUFFQSxjQUFrQyxNQUFpQjtBQUNoRCxhQUFPLEtBQUs7UUFDVCxlQUFlLGNBQWMsS0FBSyxDQUFBLEdBQUksTUFBUyxDQUFDO1FBQ2hELHlCQUF5QixTQUFTO01BQ3JDO0lBQ0g7RUFDSDtBQUNIO0FBMUdBLElBTVk7QUFOWixJQUFBLGNBQUEsTUFBQTtFQUFBLDRCQUFBO0FBQUE7QUFDQSxvQkFBQTtBQUdBLGVBQUE7QUFFWSxxQkFBTCxrQkFBS0Msb0JBQUw7QUFDSkEsc0JBQUEsUUFBQSxJQUFTO0FBQ1RBLHNCQUFBLFFBQUEsSUFBUztBQUNUQSxzQkFBQSxPQUFBLElBQVE7QUFDUkEsc0JBQUEsVUFBQSxJQUFXO0FBSkYsYUFBQUE7SUFBQSxHQUFBLGtCQUFBLENBQUEsQ0FBQTtFQUFBO0FBQUEsQ0FBQTtBQ1FMLFNBQVMsaUJBQWlCLE9BQXdDO0FBQ3RFLFNBQU8sZUFBZSxJQUFJLEtBQXVCO0FBQ3BEO0FBaEJBLElBQVk7QUFBWixJQVlNO0FBWk4sSUFBQSx3QkFBQSxNQUFBO0VBQUEsc0NBQUE7QUFBQTtBQUFZLHFCQUFMLGtCQUFLQyxvQkFBTDtBQUNKQSxzQkFBQSxPQUFBLElBQVE7QUFDUkEsc0JBQUEsUUFBQSxJQUFTO0FBQ1RBLHNCQUFBLFNBQUEsSUFBVTtBQUNWQSxzQkFBQSxVQUFBLElBQVc7QUFDWEEsc0JBQUEsU0FBQSxJQUFVO0FBQ1ZBLHNCQUFBLFNBQUEsSUFBVTtBQUNWQSxzQkFBQSxVQUFBLElBQVc7QUFDWEEsc0JBQUEsU0FBQSxJQUFVO0FBQ1ZBLHNCQUFBLFFBQUEsSUFBUztBQVRBLGFBQUFBO0lBQUEsR0FBQSxrQkFBQSxDQUFBLENBQUE7QUFZTixxQkFBaUIsSUFBSSxJQUFJLE9BQU8sT0FBTyxjQUFjLENBQUM7RUFBQTtBQUFBLENBQUE7QUNvQ3JELFNBQVMsb0JBQW9CLFFBQWdDO0FBQ2pFLFNBQU8sSUFBSSxVQUFVLEVBQUUsTUFBTSxHQUFHLE1BQU07QUFDekM7QUFFQSxTQUFTLFVBQVUsTUFBMEI7QUFDMUMsUUFBTSxRQUE2QixvQkFBSSxJQUFZO0FBQ25ELFFBQU0sVUFBaUMsQ0FBQztBQUV4Qyx5QkFBdUIsTUFBTSxDQUFDLFVBQVU7QUFDckMsVUFBTSxDQUFDLE1BQU0sTUFBTSxPQUFPLElBQUksTUFBTSxNQUFNLElBQUk7QUFDOUMsVUFBTSxJQUFJLElBQUk7QUFDZCxLQUFDLFFBQVEsSUFBQSxJQUFRLFFBQVEsSUFBQSxLQUFTLENBQUMsR0FBRyxLQUFLO01BQ3hDLE1BQU0sU0FBUyxJQUFJO01BQ25CO01BQ0E7SUFDSCxDQUFDO0VBQ0osQ0FBQztBQUVELFNBQU87SUFDSjtJQUNBO0VBQ0g7QUFDSDtBQUVlLFNBQVIsZUFBNkM7QUFDakQsU0FBTztJQUNKLEtBQXlCLFlBQW1DO0FBQ3pELFlBQU0sT0FBTyx5QkFBeUIsU0FBUztBQUMvQyxZQUFNLFVBQVUsbUJBQW1CLFNBQVM7QUFFNUMsaUJBQVcsVUFBVSxtQkFBbUI7QUFDckMsWUFBSSxRQUFRLFNBQVMsTUFBTSxHQUFHO0FBQzNCLGlCQUFPLEtBQUs7WUFDVCx1QkFBdUIscUJBQXFCLDJCQUEyQjtZQUN2RTtVQUNIO1FBQ0g7TUFDSDtBQUVBLFVBQUksT0FBTyxlQUFlLFVBQVU7QUFDakMscUJBQWEsaUJBQWlCLEVBQUUsTUFBTSxVQUFVO01BQ25EO0FBRUEsWUFBTSxXQUFXLENBQUMsUUFBUSxVQUFVLE1BQU0sZUFBZSxHQUFHLFNBQVMsR0FBRyxVQUFVO0FBRWxGLGFBQU8sS0FBSztRQUNUO1VBQ0c7VUFDQSxRQUFRO1VBQ1IsT0FBTyxRQUFRO0FBQ1osbUJBQU8sVUFBVSxNQUFNO1VBQzFCO1FBQ0g7UUFDQTtNQUNIO0lBQ0g7RUFDSDtBQUNIO0FBekdBLElBYU07QUFiTixJQWVNO0FBZk4sSUFBQTtBQUFBLElBeUJNO0FBekJOLElBQUEsWUFBQSxNQUFBO0VBQUEsMEJBQUE7QUFBQTtBQUVBLGVBQUE7QUFTQSxjQUFBO0FBRU0sd0JBQW9CLENBQUMsSUFBSTtBQUV6QixZQUFRLE9BQU8sV0FBVztBQVUxQixnQkFBTixNQUF3QztNQUF4QyxjQUFBO0FBQ0csYUFBUyxFQUFBLElBQW1CLENBQUM7TUFBQTtNQUU3QixHQUZTLEtBQUEsT0FFUCxPQUFPLFNBQUEsSUFBWTtBQUNsQixtQkFBVyxTQUFTLEtBQUssS0FBQSxHQUFRO0FBQzlCLGdCQUFNO1FBQ1Q7TUFDSDtNQUVBLE9BQU8sS0FBZTtBQUNuQixZQUFJLFVBQVUsS0FBSyxLQUFBLEVBQU8sS0FBSyxTQUFTLEtBQUssR0FBRyxjQUFjLEtBQUssSUFBSSxHQUFHLEdBQUc7QUFDN0UsZUFBTztNQUNWO01BRUEsU0FBUyxPQUFpQjtBQUN2QixhQUFLLEtBQUEsRUFBTyxLQUFLLEdBQUcsY0FBYyxPQUFPLElBQUksQ0FBQztBQUM5QyxlQUFPO01BQ1Y7SUFDSDtFQUFBO0FBQUEsQ0FBQTtBQzNDQSxJQUFBLGdCQUFBLENBQUE7QUFBQUwsVUFBQSxlQUFBO0VBQUEsV0FBQSxNQUFBO0VBQUEsY0FBQSxNQUFBO0VBQUEsV0FBQSxNQUFBO0FBQUEsQ0FBQTtBQWlCTyxTQUFTLFVBQVUsTUFBd0IsWUFBc0I7QUFDckUsUUFBTSxXQUFxQixDQUFDLE9BQU87QUFDbkMsTUFBSSxpQkFBaUIsSUFBSSxHQUFHO0FBQ3pCLGFBQVMsS0FBSyxLQUFLLE1BQU07RUFDNUI7QUFDQSxXQUFTLEtBQUssR0FBRyxVQUFVO0FBRTNCLFNBQU8sMEJBQTBCLFFBQVE7QUFDNUM7QUFFTyxTQUFTLGFBQWEsTUFBeUM7QUFDbkUsTUFBSSxpQkFBaUIsSUFBSSxHQUFHO0FBQ3pCLFdBQU87RUFDVjtBQUVBLFVBQVEsT0FBTyxNQUFBO0lBQUEsS0FDUDtJQUFBLEtBQ0E7QUFDRixhQUFPO0VBQUE7QUFHYjtBQUNIO0FBRUEsU0FBUyxpQkFBaUIsTUFBMEM7QUFDakUsU0FBTyxXQUFXLFNBQVMsSUFBSTtBQUNsQztBQTNDQSxJQUdZO0FBSFosSUFXTTtBQVhOLElBQUEsYUFBQSxNQUFBO0VBQUEsMkJBQUE7QUFBQTtBQUFBLGNBQUE7QUFHWSxnQkFBTCxrQkFBS00sZUFBTDtBQUNKQSxpQkFBQSxPQUFBLElBQVE7QUFDUkEsaUJBQUEsTUFBQSxJQUFPO0FBQ1BBLGlCQUFBLE1BQUEsSUFBTztBQUNQQSxpQkFBQSxPQUFBLElBQVE7QUFDUkEsaUJBQUEsTUFBQSxJQUFPO0FBTEUsYUFBQUE7SUFBQSxHQUFBLGFBQUEsQ0FBQSxDQUFBO0FBUU4saUJBQWEsTUFBTSxLQUFLLE9BQU8sT0FBTyxTQUFTLENBQUM7RUFBQTtBQUFBLENBQUE7QUNXdEQsU0FBUyxZQUFZO0FBQ2xCLGFBQU8sYUFBQUMsU0FBTSxZQUFZO0FBQzVCO0FBVUEsU0FBUyxlQUNOLElBQ0EsUUFDQSxTQUNxQjtBQUNyQixNQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sTUFBTSxFQUFFLFFBQVEsT0FBTyxFQUFFLEdBQUc7QUFDaEQsV0FBTyxDQUFDLFVBQ0gsS0FDQSxDQUFDLFlBQVksU0FBUztBQUNuQixTQUFHLFNBQVMsR0FBRyxJQUFJO0FBQ25CLGNBQVEsU0FBUyxHQUFHLElBQUk7SUFDM0I7RUFDUjtBQUVBLFNBQU8sQ0FBQyxZQUFZLFNBQVM7QUFDMUIsT0FBRyxNQUFNLFdBQVcsUUFBUSxHQUFHLElBQUk7QUFDbkMsUUFBSSxTQUFTO0FBQ1YsY0FBUSxTQUFTLEdBQUcsSUFBSTtJQUMzQjtFQUNIO0FBQ0g7QUFFQSxTQUFTLGdCQUNOLE1BQ0EsZUFDQSxFQUFFLFdBQVcsZ0JBQWdCLEdBQ3RCO0FBQ1AsTUFBSSxPQUFPLFNBQVMsVUFBVTtBQUMzQixXQUFPO0VBQ1Y7QUFDQSxRQUFNLGlCQUFrQixpQkFBaUIsY0FBYyxhQUFjO0FBRXJFLE1BQUksZUFBZSxXQUFXLGVBQWUsR0FBRztBQUM3QyxXQUFPLGVBQWUsT0FBTyxnQkFBZ0IsU0FBUyxDQUFDO0VBQzFEO0FBRUEsU0FBTyxrQkFBa0I7QUFDNUI7QUFFTyxTQUFTLGFBQ2IsT0FDQSxTQUNBLGFBQ0EsZUFBZSxVQUFVLEdBQ1o7QUFDYixRQUFNLGNBQWUsU0FBUyxJQUFJLFlBQWE7QUFFL0MsUUFBTSxVQUEwQixDQUFDO0FBQ2pDLFFBQU0sZ0JBQ0gsT0FBTyxZQUFZLFdBQVcsYUFBYSxPQUFPLE9BQU8sSUFBSTtBQUNoRSxRQUFNLE1BQU0sZ0JBQWdCLFdBQVcsU0FBUyxZQUFZLEdBQUcsZUFBZSxZQUFZO0FBRTFGLFNBQU8sS0FBSyxXQUFXO0FBRXZCLFdBQVMsUUFBUSxNQUFjLFNBQWtCO0FBQzlDLFdBQU87TUFDSjtNQUNBLGFBQWEsT0FBTyxJQUFJLFFBQVEsVUFBVSxJQUFJLEdBQUcsU0FBUyxZQUFZO0lBQ3pFO0VBQ0g7QUFFQSxXQUFTLEtBQUssT0FBZ0I7QUFDM0IsVUFBTSxhQUFjLFNBQVMsSUFBSSxZQUFhO0FBQzlDLFVBQU1BLFNBQVMsaUJBQWlCLGVBQWUsZUFBZSxVQUFVLEtBQU07QUFDOUUsVUFBTSxPQUFPLGVBQWUsY0FBYyxHQUFHLGVBQWUsY0FBY0EsTUFBSztBQUUvRSxXQUFPLE9BQU8sT0FBTyxnQkFBZ0JBLFNBQVEsTUFBTTtNQUNoRDtNQUNBO01BQ0E7TUFDQTtJQUNILENBQUM7RUFDSjtBQUNIO0FBM0dBLElBQUEsa0JBQUEsTUFBQTtFQUFBLDBCQUFBO0FBQUE7QUFDQSxlQUFBO0FBV0EsaUJBQUFBLFFBQU0sV0FBVyxJQUFJLENBQUMsVUFBZSxPQUFPLGdCQUFnQixLQUFLLElBQUksTUFBTSxTQUFTLEdBQUc7QUFDdkYsaUJBQUFBLFFBQU0sV0FBVyxJQUFJLENBQUMsVUFBa0I7QUFDckMsVUFBSSxPQUFPLFNBQVMsS0FBSyxHQUFHO0FBQ3pCLGVBQU8sTUFBTSxTQUFTLE1BQU07TUFDL0I7QUFDQSxhQUFPLGVBQWUsS0FBSztJQUM5QjtFQUFBO0FBQUEsQ0FBQTtBQ2xCQSxJQVlhO0FBWmIsSUFZYTtBQVpiLElBQUEsMkJBQUEsTUFBQTtFQUFBLDJDQUFBO0FBQUE7QUFDQSxtQkFBQTtBQUNBLG9CQUFBO0FBVWEseUJBQU4sTUFBd0I7TUFHNUIsWUFBb0IsV0FBVyxlQUFlO0FBQTFCLGFBQUEsV0FBQTtBQUZwQixhQUFRLFNBQWdELG9CQUFJLElBQUk7TUFFakI7TUFFdkMsYUFBYSxNQUF3QjtBQUMxQyxlQUFPLEtBQUssT0FBTyxJQUFJLElBQUk7TUFDOUI7TUFFUSxlQUFlLE1BQXdDO0FBQzVELGNBQU0sT0FBTyxtQkFBa0IsUUFBUSxLQUFLLFNBQVMsQ0FBQSxDQUFFO0FBQ3ZELGNBQU0sU0FBUyxhQUFhLEtBQUssVUFBVSxJQUFJO0FBRS9DLGVBQU87VUFDSjtVQUNBO1VBQ0E7UUFDSDtNQUNIO01BRUEsS0FBSyxNQUF3QztBQUMxQyxjQUFNLFdBQVcsS0FBSyxlQUFlLElBQUk7QUFDekMsaUJBQVMsT0FBTywyQ0FBMkMsS0FBSyxRQUFRO0FBRXhFLGFBQUssT0FBTyxJQUFJLE1BQU0sUUFBUTtBQUU5QixlQUFPO01BQ1Y7TUFFQSxNQUFNLEtBQWU7QUFDbEIsbUJBQVcsQ0FBQyxNQUFNLEVBQUUsT0FBTyxDQUFDLEtBQUssTUFBTSxLQUFLLEtBQUssT0FBTyxRQUFRLENBQUMsR0FBRztBQUNqRSxjQUFJLFNBQVMsSUFBSSxNQUFNO0FBQ3BCLG1CQUFPLEtBQUssYUFBYSxHQUFHO0FBQzVCO2NBQ0c7WUFDSDtVQUNILE9BQU87QUFDSixtQkFBTztjQUNKO2NBQ0EsSUFBSTtZQUNQO1VBQ0g7QUFFQSxlQUFLLFNBQVMsSUFBSTtRQUNyQjtBQUVBLFlBQUksS0FBSyxPQUFPLFNBQVMsR0FBRztBQUN6QixnQkFBTSxJQUFJLE1BQU0sMENBQTBDLEtBQUssT0FBTyxNQUFNO1FBQy9FO01BQ0g7TUFFQSxTQUFTLE1BQXdCO0FBQzlCLGNBQU0sV0FBVyxLQUFLLGFBQWEsSUFBSTtBQUN2QyxZQUFJLFVBQVU7QUFDWCxlQUFLLE9BQU8sT0FBTyxJQUFJO1FBQzFCO01BQ0g7TUFFQSxRQUFRLE1BQXdDO0FBQzdDLGNBQU0sV0FBVyxLQUFLLGFBQWEsSUFBSTtBQUN2QyxZQUFJLENBQUMsVUFBVTtBQUNaLGdCQUFNLElBQUksU0FBUyxRQUFXLHVEQUF1RDtRQUN4RjtBQUNBLGlCQUFTLE9BQU8sZUFBZTtBQUUvQixlQUFPO01BQ1Y7TUFFQSxPQUFPLFFBQVEsT0FBTyxTQUFTO0FBQzVCLGVBQU8sUUFBUSxRQUFRLEVBQUUsbUJBQWtCO01BQzlDO0lBR0g7QUF6RWEsd0JBQU47QUFBTSxzQkF3RUssVUFBVTtFQUFBO0FBQUEsQ0FBQTtBQ29MNUIsU0FBUyxjQUFpQixNQUF3QixVQUFvQjtBQUNuRSxTQUFPO0lBQ0osUUFBUSxNQUFNLEtBQUssUUFBUSxLQUFLO0lBQ2hDO0VBQ0g7QUFDSDtBQUVBLFNBQVMsZ0JBQWdCLFFBQWtCLFFBQXNCO0FBQzlELFNBQU8sQ0FBQyxRQUFlO0FBQ3BCLFdBQU8sc0NBQXNDLEdBQUc7QUFDaEQsV0FBTyxLQUFLLE9BQU8sS0FBSyxPQUFPLElBQUksS0FBSyxHQUFHLE9BQU8sQ0FBQztFQUN0RDtBQUNIO0FBRUEsU0FBUyxlQUNOLFFBQ0EsTUFDQSxRQUNBLFFBQ0Q7QUFDQyxTQUFPLENBQUMsV0FBbUI7QUFDeEIsV0FBTyx3QkFBd0IsTUFBTSxNQUFNO0FBQzNDLFdBQU8sTUFBTSxNQUFNO0FBQ25CLFdBQU8sS0FBSyxNQUFNO0VBQ3JCO0FBQ0g7QUFqU0EsSUFpQmE7QUFqQmIsSUFBQSwwQkFBQSxNQUFBO0VBQUEsMENBQUE7QUFBQTtBQUNBLG1CQUFBO0FBR0EsY0FBQTtBQVNBLGVBQUE7QUFFQSw2QkFBQTtBQUVhLHVCQUFOLE1BQW9EO01BcUJ4RCxZQUNXLFdBQ0EsWUFDQSxVQUNUO0FBSFMsYUFBQSxZQUFBO0FBQ0EsYUFBQSxhQUFBO0FBQ0EsYUFBQSxXQUFBO0FBdkJYLGFBQVEsU0FBdUIsUUFBUSxRQUFRO0FBQy9DLGFBQVEsU0FBUyxJQUFJLGtCQUFrQjtNQXVCcEM7TUFwQkgsSUFBVyxNQUFNO0FBQ2QsZUFBTyxLQUFLLFFBQVEsS0FBSyxVQUFVO01BQ3RDO01BRUEsSUFBVyxJQUFJLEtBQWE7QUFDekIsYUFBSyxPQUFPO01BQ2Y7TUFFQSxJQUFXLE1BQU07QUFDZCxlQUFPLEtBQUssVUFBVTtNQUN6QjtNQUVBLElBQVcsZ0JBQWdCO0FBQ3hCLGVBQU8sS0FBSyxVQUFVO01BQ3pCO01BUU8sUUFBUTtBQUNaLGVBQU87TUFDVjtNQUVPLEtBQVEsTUFBb0M7QUFDaEQsYUFBSyxPQUFPLEtBQUssSUFBSTtBQUVyQixlQUFRLEtBQUssU0FBUyxLQUFLLE9BQU8sS0FBSyxNQUFNLEtBQUssWUFBWSxJQUFJLENBQUM7TUFDdEU7TUFFYyxZQUFlLE1BQTJDO0FBQUEsZUFBQSxRQUFBLE1BQUEsTUFBQSxhQUFBO0FBQ3JFLGdCQUFNLHFCQUFxQixNQUFNLEtBQUssV0FBVyxLQUFLO0FBQ3RELGdCQUFNLGtCQUFrQixNQUFNLEtBQUssT0FBTyxTQUFTLElBQUk7QUFFdkQsY0FBSTtBQUNELGtCQUFNLEVBQUUsT0FBTyxJQUFJLEtBQUssT0FBTyxRQUFRLElBQUk7QUFDM0MsbUJBQVEsTUFBTyxZQUFZLElBQUksSUFDMUIsS0FBSyxpQkFBaUIsTUFBTSxNQUFNLElBQ2xDLEtBQUssa0JBQWtCLE1BQU0sTUFBTTtVQUMzQyxTQUFTLEdBQVQ7QUFDRyxrQkFBTSxLQUFLLGlCQUFpQixNQUFNLENBQVU7VUFDL0MsVUFBQTtBQUNHLDRCQUFnQjtBQUNoQiwrQkFBbUI7VUFDdEI7UUFDSCxDQUFBO01BQUE7TUFFUSxpQkFBb0IsTUFBd0IsR0FBVTtBQUMzRCxjQUFNLFdBQ0gsYUFBYSxXQUFXLE9BQU8sT0FBTyxHQUFHLEVBQUUsS0FBSyxDQUFDLElBQUksSUFBSSxTQUFTLE1BQU0sS0FBSyxPQUFPLENBQUMsQ0FBQztBQUV6RixhQUFLLFNBQVMsUUFBUSxRQUFRO0FBQzlCLGFBQUssT0FBTyxNQUFNLFFBQVE7QUFFMUIsZUFBTztNQUNWO01BRWMsa0JBQXFCLE1BQXVCLFFBQXNCO0FBQUEsZUFBQSxRQUFBLE1BQUEsTUFBQSxhQUFBO0FBQzdFLGdCQUFNLFNBQVMsS0FBSyxTQUFTLEtBQUssZ0JBQWdCLElBQUksY0FBYyxNQUFNLEtBQUssUUFBUSxDQUFDO0FBQ3hGLGdCQUFNLE9BQU8sS0FBSyxTQUFTO1lBQ3hCO1lBQ0EsQ0FBQyxHQUFHLEtBQUssUUFBUTtZQUNqQixjQUFjLE1BQU0sS0FBSyxRQUFRO1VBQ3BDO0FBRUEsZ0JBQU0sTUFBTSxNQUFNLEtBQUs7WUFDcEI7WUFDQTtZQUNBO1lBQ0EsS0FBSztZQUNMLE9BQU8sS0FBSyxPQUFPO1VBQ3RCO0FBQ0EsZ0JBQU0sZ0JBQWdCLE1BQU0sS0FBSyxlQUFlLE1BQU0sTUFBTSxLQUFLLE9BQU8sS0FBSyxRQUFRLENBQUM7QUFFdEYsaUJBQU8sNkNBQTZDLEtBQUssTUFBTTtBQUUvRCxjQUFJLGFBQWEsSUFBSSxHQUFHO0FBQ3JCLG1CQUFPLGVBQWUsS0FBSyxRQUFRLGFBQWE7VUFDbkQ7QUFFQSxpQkFBTyxlQUFlLEtBQUssUUFBUSxjQUFjLFVBQVUsQ0FBQztRQUMvRCxDQUFBO01BQUE7TUFFYyxpQkFBaUIsTUFBaUIsUUFBc0I7QUFBQSxlQUFBLFFBQUEsTUFBQSxNQUFBLGFBQUE7QUFDbkUsaUJBQU8sNkRBQTZEO0FBQ3BFLGlCQUFPLEtBQUssT0FBTyxJQUFJO1FBQzFCLENBQUE7TUFBQTtNQUVRLGVBQ0wsTUFDQSxNQUNBLFFBQ0EsUUFDMEI7QUFDMUIsY0FBTSxFQUFFLFVBQVUsV0FBVyxRQUFRLE9BQU8sSUFBSTtBQUVoRCxlQUFPLElBQUksUUFBUSxDQUFDLE1BQU0sU0FBUztBQUNoQyxpQkFBTyw0REFBNEQsUUFBUTtBQUUzRSxnQkFBTSxFQUFFLE1BQU0sSUFBSSxLQUFLLFNBQVM7WUFDN0I7WUFDQSxFQUFFLE9BQU8sVUFBVTtZQUNuQixlQUFBLGVBQUEsQ0FBQSxHQUNNLGNBQWMsTUFBTSxJQUFJLENBQUEsR0FDeEIsTUFBQTtVQUVUO0FBRUEsY0FBSSxTQUFTLEtBQUssU0FBUztBQUN4QixtQkFBTyxLQUFLLGdEQUFnRDtBQUU1RCxtQkFBTyxLQUFLO2NBQ1Q7Y0FDQTtjQUNBLENBQUMsY0FBYztBQUNaLHVCQUFPLEtBQUsseUNBQXlDO0FBQ3JELHVCQUFPLDhCQUE4QixlQUFlLFNBQVMsQ0FBQztBQUU5RDtrQkFDRyxJQUFJO29CQUNELE1BQU0sUUFBUSxTQUFTLElBQUksT0FBTyxPQUFPLFNBQVMsSUFBSTtvQkFDdEQsT0FBTyxPQUFPLE1BQU07a0JBQ3ZCO2dCQUNIO2NBQ0g7Y0FDQTtZQUNIO1VBQ0g7QUFFQSxjQUFJLE9BQU87QUFDUixtQkFBTztjQUNKO2NBQ0E7Y0FDQSxPQUFPO2NBQ1A7WUFDSDtBQUNBLG1CQUFPLEtBQUssS0FBSztVQUNwQjtBQUVBLGlCQUFPLEtBQUssaUNBQWlDO0FBQzdDLGVBQUssSUFBSSxpQkFBaUIsT0FBTyxPQUFPLE1BQU0sR0FBRyxPQUFPLE9BQU8sTUFBTSxDQUFDLENBQUM7UUFDMUUsQ0FBQztNQUNKO01BRWMsWUFDWCxNQUNBLFNBQ0EsTUFDQSxlQUNBLFFBQzJCO0FBQUEsZUFBQSxRQUFBLE1BQUEsTUFBQSxhQUFBO0FBQzNCLGdCQUFNLGVBQWUsT0FBTyxRQUFRLFFBQVE7QUFDNUMsZ0JBQU0sZUFBNkIsS0FBSyxTQUFTO1lBQzlDO1lBQ0E7Y0FDRyxLQUFLLEtBQUs7Y0FDVixLQUFLLEtBQUs7Y0FDVixhQUFhO1lBQ2hCO1lBQ0EsY0FBYyxNQUFNLEtBQUssUUFBUTtVQUNwQztBQUVBLGlCQUFPLElBQUksUUFBUSxDQUFDLFNBQVM7QUFDMUIsa0JBQU0sU0FBbUIsQ0FBQztBQUMxQixrQkFBTSxTQUFtQixDQUFDO0FBRTFCLG1CQUFPLEtBQUssU0FBUyxTQUFTLElBQUk7QUFDbEMsbUJBQU8sTUFBTSxZQUFZO0FBRXpCLGdCQUFJLFlBQVksS0FBSyxhQUFhLE1BQU0sSUFBSTtBQUM1QyxnQkFBSSxXQUFXO0FBQ1oscUJBQU8sS0FBSztnQkFDVDtnQkFDQTtnQkFDQSxVQUFVO2dCQUNWO2NBQ0gsQ0FBQztZQUNKO0FBRUEsaUJBQUssU0FBUyxLQUFLLGdCQUFnQixRQUFXLGNBQUEsZUFBQSxDQUFBLEdBQ3hDLGNBQWMsTUFBTSxJQUFJLENBQUEsR0FEZ0I7Y0FFM0MsS0FBSyxRQUFRO0FBQ1YsNEJBQVksVUFBVTtjQUN6QjtZQUNILENBQUEsQ0FBQztBQUVELGtCQUFNLGNBQVUsNEJBQU0sU0FBUyxNQUFNLFlBQVk7QUFFakQsb0JBQVEsT0FBUTtjQUNiO2NBQ0EsZUFBZSxRQUFRLFVBQVUsUUFBUSxhQUFhLEtBQUssUUFBUSxDQUFDO1lBQ3ZFO0FBQ0Esb0JBQVEsT0FBUTtjQUNiO2NBQ0EsZUFBZSxRQUFRLFVBQVUsUUFBUSxhQUFhLEtBQUssUUFBUSxDQUFDO1lBQ3ZFO0FBRUEsb0JBQVEsR0FBRyxTQUFTLGdCQUFnQixRQUFRLE1BQU0sQ0FBQztBQUVuRCxnQkFBSSxlQUFlO0FBQ2hCLHFCQUFPLDZEQUE2RDtBQUNwRSw0QkFBYyxTQUFTLFFBQVEsUUFBUyxRQUFRLFFBQVMsQ0FBQyxHQUFHLElBQUksQ0FBQztZQUNyRTtBQUVBLGlCQUFLLFNBQVMsS0FBSyxlQUFlLFFBQVcsY0FBQSxlQUFBLENBQUEsR0FDdkMsY0FBYyxNQUFNLElBQUksQ0FBQSxHQURlO2NBRTFDO2NBQ0EsTUFBTSxVQUFrQixRQUFnQjtBQUNyQyxxQkFBSztrQkFDRjtrQkFDQTtrQkFDQTtrQkFDQSxXQUFXLGFBQWE7Z0JBQzNCLENBQUM7Y0FDSjtjQUNBLEtBQUssUUFBZTtBQUNqQixvQkFBSSxRQUFRLFFBQVE7QUFDakI7Z0JBQ0g7QUFFQSw0QkFBWTtBQUNaLHdCQUFRLEtBQUssUUFBUTtjQUN4QjtZQUNILENBQUEsQ0FBQztVQUNKLENBQUM7UUFDSixDQUFBO01BQUE7TUFFUSxhQUFnQixNQUF3QixNQUFnQjtBQUM3RCxZQUFJO0FBQ0osYUFBSyxTQUFTLEtBQUssZ0JBQWdCLFFBQVcsY0FBQSxlQUFBLENBQUEsR0FDeEMsY0FBYyxNQUFNLElBQUksQ0FBQSxHQURnQjtVQUUzQyxLQUFLLFFBQVE7QUFDVix3QkFBWSxVQUFVO1VBQ3pCO1FBQ0gsQ0FBQSxDQUFDO0FBRUQsZUFBTztNQUNWO0lBQ0g7RUFBQTtBQUFBLENBQUE7QUN0UUEsSUFBQSx1QkFBQSxDQUFBO0FBQUFQLFVBQUEsc0JBQUE7RUFBQSxhQUFBLE1BQUE7QUFBQSxDQUFBO0FBQUEsSUFNYTtBQU5iLElBQUEsb0JBQUEsTUFBQTtFQUFBLG9DQUFBO0FBQUE7QUFHQSw0QkFBQTtBQUdhLGtCQUFOLE1BQStDO01BTW5ELFlBQ1UsS0FDQyxZQUNBLFVBQ1Q7QUFIUSxhQUFBLE1BQUE7QUFDQyxhQUFBLGFBQUE7QUFDQSxhQUFBLFdBQUE7QUFSWCxhQUFRLFNBQVMsSUFBSSxpQkFBaUIsTUFBTSxLQUFLLFlBQVksS0FBSyxRQUFRO01BU3ZFO01BRUgsUUFBMkI7QUFDeEIsZUFBTyxJQUFJLGlCQUFpQixNQUFNLEtBQUssWUFBWSxLQUFLLFFBQVE7TUFDbkU7TUFFQSxLQUFRLE1BQW9DO0FBQ3pDLGVBQU8sS0FBSyxPQUFPLEtBQUssSUFBSTtNQUMvQjtJQUNIO0VBQUE7QUFBQSxDQUFBO0FDcEJPLFNBQVMsYUFDYixNQUNBLFVBQ0EsV0FBcUMsTUFDdEM7QUFDQyxRQUFNLFlBQVksQ0FBQyxTQUFZO0FBQzVCLGFBQVMsTUFBTSxJQUFJO0VBQ3RCO0FBRUEsUUFBTVEsV0FBVSxDQUFDLFFBQXFDO0FBQ25ELFNBQUksT0FBQSxPQUFBLFNBQUEsSUFBSyxVQUFTLE1BQU07QUFDckI7UUFDRyxlQUFlLG1CQUFtQiw0QkFBNEIsR0FBRyxJQUFJO1FBQ3JFO01BQ0g7SUFDSDtFQUNIO0FBRUEsV0FBUyxLQUFLLFdBQVdBLFFBQU87QUFDbkM7QUFFQSxTQUFTLDRCQUE0QixLQUF1QjtBQUN6RCxNQUFJLE1BQU0sQ0FBQyxTQUFpQjtBQUN6QixZQUFRO01BQ0wsNkRBQTZELHVDQUF1QztJQUN2RztBQUNBLFVBQU07RUFDVDtBQUVBLFNBQU8sT0FBTyxPQUFPLEtBQUssT0FBTyxvQkFBb0IsSUFBSSxHQUFHLEVBQUUsT0FBTyxtQkFBbUIsQ0FBQyxDQUFDLENBQUM7QUFFM0YsV0FBUyxrQkFBa0IsS0FBNEIsTUFBMEI7QUFDOUUsUUFBSSxRQUFRLEtBQUs7QUFDZCxhQUFPO0lBQ1Y7QUFFQSxRQUFJLElBQUEsSUFBUTtNQUNULFlBQVk7TUFDWixjQUFjO01BQ2QsTUFBTTtBQUNILFlBQUksSUFBSTtBQUNSLGVBQU8sSUFBSSxJQUFJLElBQUE7TUFDbEI7SUFDSDtBQUVBLFdBQU87RUFDVjtBQUNIO0FBcERBLElBQUEscUJBQUEsTUFBQTtFQUFBLDZCQUFBO0FBQUE7QUFDQSw0QkFBQTtBQUVBLGVBQUE7RUFBQTtBQUFBLENBQUE7QUNDTyxTQUFTLDJCQUEyQixXQUFtQixNQUEwQjtBQUNyRixTQUFPLGNBQWMsQ0FBQyxhQUFnQztBQUNuRCxRQUFJLENBQUMsYUFBYSxTQUFTLEdBQUc7QUFDM0IsWUFBTSxJQUFJLE1BQU0sNENBQTRDLFlBQVk7SUFDM0U7QUFFQSxZQUFTLFFBQVEsVUFBVSxNQUFNO0VBQ3BDLENBQUM7QUFDSjtBQVpBLElBQUEsZ0NBQUEsTUFBQTtFQUFBLDhDQUFBO0FBQUE7QUFBQSxlQUFBO0FBRUEsY0FBQTtFQUFBO0FBQUEsQ0FBQTtBQ0dBLFNBQVMsYUFBYSxNQUFnQjtBQUNuQyxRQUFNLFdBQVcsQ0FBQyxZQUFZLEdBQUcsSUFBSTtBQUNyQyxNQUFJLFNBQVMsQ0FBQSxNQUFPLFFBQVEsU0FBUyxTQUFTLElBQUksR0FBRztBQUNsRCxhQUFTLENBQUEsSUFBSyxPQUFPLFVBQVUsSUFBSTtFQUN0QztBQUVBLFNBQU8sMEJBQTBCLFFBQVE7QUFDNUM7QUFFZSxTQUFSLG1CQUE0RjtBQUNoRyxTQUFPO0lBQ0osV0FBNkI7QUFDMUIsYUFBTyxLQUFLO1FBQ1QsYUFBYSxtQkFBbUIsV0FBVyxDQUFDLENBQUM7UUFDN0MseUJBQXlCLFNBQVM7TUFDckM7SUFDSDtJQUVBLGVBQW1DLFlBQVksWUFBWTtBQUN4RCxhQUFPLEtBQUs7UUFDVCxhQUFhLENBQUMsTUFBTSxZQUFZLFlBQVksR0FBRyxtQkFBbUIsU0FBUyxDQUFDLENBQUM7UUFDN0UseUJBQXlCLFNBQVM7TUFDckM7SUFDSDtJQUVBLG9CQUF3QyxZQUFZO0FBQ2pELGFBQU8sS0FBSztRQUNULGFBQWEsQ0FBQyxNQUFNLFlBQVksR0FBRyxtQkFBbUIsU0FBUyxDQUFDLENBQUM7UUFDakUseUJBQXlCLFNBQVM7TUFDckM7SUFDSDtFQUNIO0FBQ0g7QUFyQ0EsSUFBQSxnQkFBQSxNQUFBO0VBQUEsOEJBQUE7QUFBQTtBQUVBLGVBQUE7QUFDQSxjQUFBO0VBQUE7QUFBQSxDQUFBO0FDWUEsU0FBUyx1QkFBMkM7QUFDakQsU0FBTztJQUNKLE9BQU87SUFDUCxTQUFTO0lBQ1QsUUFBUTtJQUNSLE9BQU87SUFDUCxlQUFlO0lBQ2YsTUFBTTtJQUNOLGFBQWE7SUFDYixVQUFVO0VBQ2I7QUFDSDtBQVllLFNBQVIsd0JBQXFEO0FBQ3pELFNBQU87SUFDSixlQUFpQztBQUM5QixhQUFPLEtBQUssU0FBUztRQUNsQixVQUFVLENBQUMsaUJBQWlCLFdBQVc7UUFDdkMsUUFBUTtRQUNSLE9BQU8sUUFBZ0I7QUFDcEIsaUJBQU8sb0JBQW9CLHFCQUFxQixHQUFHLENBQUNWLE9BQU0sR0FBRyxNQUFNO1FBQ3RFO01BQ0gsQ0FBQztJQUNKO0VBQ0g7QUFDSDtBQWxEQSxJQTRCTUE7QUE1Qk4sSUFBQSxxQkFBQSxNQUFBO0VBQUEsbUNBQUE7QUFBQTtBQUVBLGVBQUE7QUEwQk1BLGNBQXlDLElBQUk7TUFDaEQ7TUFDQSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEtBQUssTUFBTTtBQUN2QixjQUFNLFdBQVcsWUFBWSxHQUFHO0FBQ2hDLFlBQUksT0FBTyxlQUFlLFFBQVEsR0FBRztBQUNsQyxpQkFBTyxRQUFBLElBQW1DLFNBQVMsS0FBSztRQUMzRDtNQUNIO0lBQ0g7RUFBQTtBQUFBLENBQUE7QUNRTyxTQUFTLGtCQUFrQixRQUE4QjtBQUM3RCxRQUFNLFNBQXVCO0lBQzFCLFFBQVE7SUFDUixRQUFRO0lBQ1IsUUFBUTtJQUNSLE1BQU07SUFDTixTQUFTO01BQ04sU0FBUztNQUNULFlBQVk7TUFDWixXQUFXO0lBQ2Q7RUFDSDtBQUNBLFNBQU8sb0JBQW9CLFFBQVEsU0FBUyxNQUFNO0FBQ3JEO0FBekRBLElBR007QUFITixJQUFBLG9CQUFBLE1BQUE7RUFBQSxvQ0FBQTtBQUFBO0FBQ0EsZUFBQTtBQUVNLGNBQXNDO01BQ3pDLElBQUksV0FBVyxxQ0FBcUMsQ0FBQyxRQUFRLENBQUMsUUFBUSxNQUFNLE1BQU0sTUFBTTtBQUNyRixlQUFPLFNBQVM7QUFDaEIsZUFBTyxTQUFTO0FBQ2hCLGVBQU8sT0FBTyxDQUFDLENBQUM7TUFDbkIsQ0FBQztNQUNELElBQUksV0FBVyxxQkFBcUIsQ0FBQyxRQUFRLENBQUMsTUFBTSxNQUFNO0FBQ3ZELGNBQU0sUUFBUSxPQUFPLE1BQU0sR0FBRztBQUM5QixjQUFNLFFBQVEsTUFBTSxJQUFJO0FBRXhCLFlBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxTQUFTLEdBQUcsR0FBRztBQUNqQztRQUNIO0FBRUEsZUFBTyxTQUFTO1VBQ2IsT0FBTyxNQUFNLE9BQU8sR0FBRyxNQUFNLFNBQVMsQ0FBQztVQUN2QyxNQUFNLE1BQU0sS0FBSyxHQUFHLEVBQUUsS0FBSztRQUM5QjtNQUNILENBQUM7TUFDRCxJQUFJO1FBQ0Q7UUFDQSxDQUFDLFFBQVEsQ0FBQyxTQUFTLFlBQVksU0FBUyxNQUFNO0FBQzNDLGlCQUFPLFFBQVEsVUFBVSxTQUFTLFNBQVMsRUFBRSxLQUFLO0FBQ2xELGlCQUFPLFFBQVEsYUFBYSxTQUFTLFlBQVksRUFBRSxLQUFLO0FBQ3hELGlCQUFPLFFBQVEsWUFBWSxTQUFTLFdBQVcsRUFBRSxLQUFLO1FBQ3pEO01BQ0g7TUFDQSxJQUFJO1FBQ0Q7UUFDQSxDQUFDLFFBQVEsQ0FBQyxTQUFTLE9BQU8sU0FBUyxNQUFNO0FBQ3RDLGlCQUFPLFFBQVEsVUFBVSxTQUFTLFNBQVMsRUFBRSxLQUFLO0FBQ2xELGdCQUFNLFFBQVEsU0FBUyxPQUFPLEVBQUUsS0FBSztBQUNyQyxjQUFJLGNBQWMsS0FBSztBQUNwQixtQkFBTyxRQUFRLFlBQVk7VUFDOUIsV0FBVyxjQUFjLEtBQUs7QUFDM0IsbUJBQU8sUUFBUSxhQUFhO1VBQy9CO1FBQ0g7TUFDSDtJQUNIO0VBQUE7QUFBQSxDQUFBO0FDM0JPLFNBQVMsV0FDYixTQUNBLE9BQ0EsWUFDeUI7QUFDekIsUUFBTSxXQUFxQjtJQUN4QjtJQUNBO0lBQ0E7SUFDQSxHQUFHLGNBQWMsU0FBUyxJQUFJO0lBQzlCLEdBQUc7SUFDSCxHQUFHO0VBQ047QUFFQSxTQUFPO0lBQ0o7SUFDQSxRQUFRO0lBQ1IsUUFBUTtFQUNYO0FBQ0g7QUFFZSxTQUFSLGlCQUErQztBQUNuRCxTQUFPO0lBQ0osT0FBMkIsWUFBK0IsTUFBaUI7QUFDeEUsWUFBTSxPQUFPLHlCQUF5QixTQUFTO0FBQy9DLFlBQU0sT0FDSCwyQkFBMkIsT0FBTyxLQUNsQztRQUNHLFFBQVEsT0FBTztRQUNmLFFBQVEsV0FBVyxLQUFLLENBQUEsR0FBSSwyQkFBMkIsQ0FBQyxDQUFDLENBQUM7UUFDMUQsQ0FBQyxHQUFHLFdBQVcsS0FBSyxDQUFBLEdBQUksYUFBYSxDQUFDLENBQUMsR0FBRyxHQUFHLG1CQUFtQixXQUFXLEdBQUcsSUFBSSxDQUFDO01BQ3RGO0FBRUgsYUFBTyxLQUFLLFNBQVMsTUFBTSxJQUFJO0lBQ2xDO0VBQ0g7QUFFQSxXQUFTLDJCQUEyQixTQUFtQjtBQUNwRCxXQUNHLENBQUMsMEJBQTBCLE9BQU8sS0FDbEM7TUFDRztJQUNIO0VBRU47QUFDSDtBQTVEQSxJQUFBLGNBQUEsTUFBQTtFQUFBLDRCQUFBO0FBQUE7QUFHQSxzQkFBQTtBQUNBLGVBQUE7QUFTQSxjQUFBO0VBQUE7QUFBQSxDQUFBO0FDUmUsU0FBUix1QkFBb0Q7QUFDeEQsU0FBTztJQUNKLGNBQWtEO0FBQy9DLGFBQU8sS0FBSztRQUNULDBCQUEwQixDQUFDLFlBQVksbUJBQW1CLE1BQU0sR0FBRyxJQUFJO1FBQ3ZFLHlCQUF5QixTQUFTO01BQ3JDO0lBQ0g7RUFDSDtBQUNIO0FBZEEsSUFBQSxvQkFBQSxNQUFBO0VBQUEsa0NBQUE7QUFBQTtBQUVBLGVBQUE7QUFDQSxjQUFBO0VBQUE7QUFBQSxDQUFBO0FDR08sU0FBUyxlQUFlLFVBQWtCLE9BQW9DO0FBQ2xGLFFBQU0sV0FBVyxDQUFDLGVBQWUsUUFBUTtBQUN6QyxNQUFJLE9BQU87QUFDUixhQUFTLEtBQUssSUFBSTtFQUNyQjtBQUVBLFNBQU8sMEJBQTBCLFVBQVUsSUFBSTtBQUNsRDtBQWJBLElBQUEsbUJBQUEsTUFBQTtFQUFBLGlDQUFBO0FBQUE7QUFBQSxjQUFBO0VBQUE7QUFBQSxDQUFBO0FDY08sU0FBUyxVQUFVLE1BQWUsTUFBYyxNQUFjO0FBQ2xFLFFBQU0sV0FBVyxPQUFPLElBQUksRUFBRSxLQUFLO0FBQ25DLE1BQUk7QUFFSixNQUFLLFNBQVMsa0JBQWtCLEtBQUssUUFBUSxHQUFJO0FBQzlDLFdBQU8sSUFBSSxZQUFZLE1BQU0sTUFBTSxPQUFPLE9BQU8sQ0FBQSxDQUFFO0VBQ3REO0FBRUEsTUFBSyxTQUFTLG9CQUFvQixLQUFLLFFBQVEsR0FBSTtBQUNoRCxXQUFPLElBQUksWUFBWSxNQUFNLE1BQU0sTUFBTSxPQUFPLENBQUEsQ0FBRTtFQUNyRDtBQUVBLE1BQUksU0FBUztBQUNiLFFBQU0sU0FBUyxTQUFTLE1BQU0sR0FBRztBQUNqQyxTQUFPLE9BQU8sUUFBUTtBQUNuQixVQUFNLFFBQVEsT0FBTyxNQUFNO0FBQzNCLFFBQUksVUFBVSxNQUFNO0FBQ2pCLGVBQVMsT0FBTyxLQUFLLEdBQUc7QUFDeEI7SUFDSDtFQUNIO0FBRUEsU0FBTyxJQUFJLFlBQVksTUFBTSxNQUFNLE9BQU8sS0FBSyxRQUFRLEdBQUcsTUFBTTtBQUNuRTtBQXJDQSxJQUVhO0FBRmIsSUFXTTtBQVhOLElBWU07QUFaTixJQUFBLG1CQUFBLE1BQUE7RUFBQSxxQ0FBQTtBQUFBO0FBRWEsa0JBQU4sTUFBd0M7TUFDNUMsWUFDbUIsTUFDQSxNQUNBLFVBQ0EsUUFDakI7QUFKaUIsYUFBQSxPQUFBO0FBQ0EsYUFBQSxPQUFBO0FBQ0EsYUFBQSxXQUFBO0FBQ0EsYUFBQSxTQUFBO01BQ2hCO0lBQ047QUFFTSx3QkFBb0I7QUFDcEIsMEJBQXNCO0VBQUE7QUFBQSxDQUFBO0FDTjVCLFNBQVMsZUFBZSxTQUFtQjtBQUN4QyxTQUFPLFFBQVEsU0FBUyxXQUFXO0FBQ3RDO0FBRU8sU0FBUyxTQUFTLE9BQU8sT0FBTyxNQUFjLFlBQThDO0FBQ2hHLFFBQU0sV0FBVyxDQUFDLFFBQVEsR0FBRyxVQUFVO0FBQ3ZDLE1BQUksUUFBUSxDQUFDLGVBQWUsUUFBUSxHQUFHO0FBQ3BDLGFBQVMsT0FBTyxHQUFHLEdBQUcsV0FBVztFQUNwQztBQUVBLFNBQU87SUFDSjtJQUNBLFFBQVE7SUFDUixPQUFPLE1BQTBCO0FBQzlCLGFBQU8sVUFBVSxTQUFTLFNBQVMsUUFBUSxHQUFHLE1BQU0sSUFBSTtJQUMzRDtFQUNIO0FBQ0g7QUF2QkEsSUFJTTtBQUpOLElBQUEsWUFBQSxNQUFBO0VBQUEsMEJBQUE7QUFBQTtBQUNBLHFCQUFBO0FBR00sa0JBQWM7RUFBQTtBQUFBLENBQUE7QUNNYixTQUFTLHFCQUFxQixZQUFzQjtBQUN4RCxXQUFTLElBQUksR0FBRyxJQUFJLFdBQVcsUUFBUSxLQUFLO0FBQ3pDLFVBQU0sU0FBUyxlQUFlLEtBQUssV0FBVyxDQUFBLENBQUU7QUFDaEQsUUFBSSxRQUFRO0FBQ1QsYUFBTyxLQUFLLE9BQU8sQ0FBQTtJQUN0QjtFQUNIO0FBRUEsU0FBTztBQUNWO0FBRU8sU0FBUyxZQUFZLFdBQTZCO0FBQ3RELFNBQU8sZUFBZSxLQUFLLFNBQW1CO0FBQ2pEO0FBdkJBLElBUU07QUFSTixJQUFBLGtCQUFBLE1BQUE7RUFBQSwrQkFBQTtBQUFBO0FBUU0scUJBQWlCO0VBQUE7QUFBQSxDQUFBO0FDUnZCLElBS2E7QUFMYixJQUFBLG1CQUFBLE1BQUE7RUFBQSxxQ0FBQTtBQUFBO0FBS2Esa0JBQU4sTUFBd0M7TUFBeEMsY0FBQTtBQUNKLGFBQUEsVUFBVTtBQUNWLGFBQUEsWUFBWTtBQUNaLGFBQUEsYUFBYTtBQUViLGFBQUEsUUFBMEQsQ0FBQztNQUFBO0lBQzlEO0VBQUE7QUFBQSxDQUFBO0FDd0dPLFNBQVMsY0FBYyxTQUFBLElBQXlCO0FBQ3BELFFBQU1BLFVBQVMsbUJBQW1CLE1BQUE7QUFFbEMsU0FBTyxDQUFDLFdBQW1CLG9CQUFvQixJQUFJLFlBQVksR0FBR0EsU0FBUSxRQUFRLEtBQUs7QUFDMUY7QUF2SEEsSUFNTTtBQU5OLElBMkNNO0FBM0NOLElBMkVNO0FBM0VOLElBd0ZNO0FBeEZOLElBMkdNO0FBM0dOLElBQUEsMEJBQUEsTUFBQTtFQUFBLDBDQUFBO0FBQUE7QUFDQSxvQkFBQTtBQUNBLHFCQUFBO0FBQ0EsMEJBQUE7QUFDQSxlQUFBO0FBRU0saUJBQWE7TUFDaEIsSUFBSTtRQUNEO1FBQ0EsQ0FBQyxRQUFRLENBQUMsTUFBTSxTQUFTLGNBQWMsRUFBRSxNQUFNO0FBQzVDLGlCQUFPLE1BQU0sS0FBSztZQUNmLE1BQU0sS0FBSyxLQUFLO1lBQ2hCLFNBQVMsU0FBUyxPQUFPO1lBQ3pCLFlBQVksWUFBWSxRQUFRLFNBQVMsRUFBRSxFQUFFO1lBQzdDLFdBQVcsWUFBWSxRQUFRLFNBQVMsRUFBRSxFQUFFO1lBQzVDLFFBQVE7VUFDWCxDQUFDO1FBQ0o7TUFDSDtNQUNBLElBQUk7UUFDRDtRQUNBLENBQUMsUUFBUSxDQUFDLE1BQU0sUUFBUSxLQUFLLE1BQU07QUFDaEMsaUJBQU8sTUFBTSxLQUFLO1lBQ2YsTUFBTSxLQUFLLEtBQUs7WUFDaEIsUUFBUSxTQUFTLE1BQU07WUFDdkIsT0FBTyxTQUFTLEtBQUs7WUFDckIsUUFBUTtVQUNYLENBQUM7UUFDSjtNQUNIO01BQ0EsSUFBSTtRQUNEO1FBQ0EsQ0FBQyxRQUFRLENBQUMsU0FBUyxPQUFPLE1BQU07QUFDN0IsZ0JBQU0sV0FBVyxVQUFVLEtBQUssT0FBTztBQUN2QyxnQkFBTSxVQUFVLFVBQVUsS0FBSyxPQUFPO0FBRXRDLGlCQUFPLFVBQVUsU0FBUyxPQUFPO0FBQ2pDLGlCQUFPLGFBQWEsU0FBUyxZQUFBLE9BQUEsU0FBQSxTQUFXLENBQUEsQ0FBRTtBQUMxQyxpQkFBTyxZQUFZLFNBQVMsV0FBQSxPQUFBLFNBQUEsUUFBVSxDQUFBLENBQUU7UUFDM0M7TUFDSDtJQUNIO0FBRU0sb0JBQWdCO01BQ25CLElBQUk7UUFDRDtRQUNBLENBQUMsUUFBUSxDQUFDLGVBQWUsZUFBZSxJQUFJLE1BQU07QUFDL0MsZ0JBQU0sYUFBYSxTQUFTLGFBQWE7QUFDekMsZ0JBQU0sWUFBWSxTQUFTLGFBQWE7QUFFeEMsaUJBQU87QUFDUCxpQkFBTyxjQUFjO0FBQ3JCLGlCQUFPLGFBQWE7QUFFcEIsaUJBQU8sTUFBTSxLQUFLO1lBQ2Y7WUFDQSxTQUFTLGFBQWE7WUFDdEI7WUFDQTtZQUNBLFFBQVE7VUFDWCxDQUFDO1FBQ0o7TUFDSDtNQUNBLElBQUksV0FBdUIsZUFBZSxDQUFDLFFBQVEsQ0FBQyxJQUFJLE1BQU07QUFDM0QsZUFBTztBQUVQLGVBQU8sTUFBTSxLQUFLO1VBQ2Y7VUFDQSxPQUFPO1VBQ1AsUUFBUTtVQUNSLFFBQVE7UUFDWCxDQUFDO01BQ0osQ0FBQztJQUNKO0FBRU0scUJBQWlCO01BQ3BCLElBQUksV0FBdUIsU0FBUyxDQUFDLFFBQVEsQ0FBQyxJQUFJLE1BQU07QUFDckQsZUFBTztBQUNQLGVBQU8sTUFBTSxLQUFLO1VBQ2Y7VUFDQSxTQUFTO1VBQ1QsWUFBWTtVQUNaLFdBQVc7VUFDWCxRQUFRO1FBQ1gsQ0FBQztNQUNKLENBQUM7SUFDSjtBQUVNLHVCQUFtQjtNQUN0QixJQUFJO1FBQ0Q7UUFDQSxDQUFDLFFBQVEsQ0FBQyxRQUFRLFlBQVksTUFBTSxLQUFLLEVBQUUsTUFBTTtBQUM5QyxpQkFBTztBQUNQLGlCQUFPLE1BQU0sS0FBSztZQUNmLE1BQU0sTUFBQSxPQUFBLEtBQU07WUFDWixTQUFTO1lBQ1QsWUFBWTtZQUNaLFdBQVc7WUFDWCxRQUFRO1lBQ1IsUUFBUSxPQUFPLGlCQUFpQixNQUFNLEtBQUssTUFBTTtZQUNqRCxNQUFNLE9BQU8sQ0FBQyxDQUFDLE1BQU0sU0FBUyxNQUFNLElBQUk7WUFDeEMsWUFBWSxTQUFTLFVBQVU7VUFDbEMsQ0FBQztRQUNKO01BQ0g7SUFDSDtBQUVNLHlCQUFrRTtNQUNyRTtRQUFBOztNQUFBLEdBQWtCO01BQ2xCO1FBQUE7O01BQUEsR0FBa0I7TUFDbEI7UUFBQTs7TUFBQSxHQUFzQjtNQUN0QjtRQUFBOztNQUFBLEdBQXlCO01BQ3pCO1FBQUE7O01BQUEsR0FBdUI7SUFDMUI7RUFBQTtBQUFBLENBQUE7QUNwR0EsU0FBUyxZQUFZLFFBQWtCLFFBQXVCO0FBQzNELFNBQU8sT0FBTztJQUNYLENBQUMsTUFBTSxPQUFPLFVBQVU7QUFDckIsV0FBSyxLQUFBLElBQVMsT0FBTyxLQUFBLEtBQVU7QUFDL0IsYUFBTztJQUNWO0lBQ0EsdUJBQU8sT0FBTyxFQUFFLE1BQU0sS0FBSyxDQUFDO0VBQy9CO0FBQ0g7QUFFTyxTQUFTLDJCQUNiLFdBQVcsVUFDWCxTQUFTLG1CQUNULFlBQUEsSUFDRDtBQUNDLFFBQU0sa0JBQWtCLGNBQWMsU0FBUztBQUUvQyxTQUFPLFNBQVUsUUFBOEI7QUFDNUMsVUFBTSxNQUFzQztNQUN6QyxPQUFPLEtBQUs7TUFDWjtNQUNBO0lBQ0gsRUFBRSxJQUFJLFNBQVUsTUFBTTtBQUNuQixZQUFNLGFBQWEsS0FBSyxNQUFNLGVBQWU7QUFDN0MsWUFBTSxjQUErQixZQUFZLFdBQVcsQ0FBQSxFQUFHLE1BQU0sUUFBUSxHQUFHLE1BQU07QUFFdEYsVUFBSSxXQUFXLFNBQVMsS0FBSyxDQUFDLENBQUMsV0FBVyxDQUFBLEVBQUcsS0FBSyxHQUFHO0FBQ2xELG9CQUFZLE9BQU8sZ0JBQWdCLFdBQVcsQ0FBQSxDQUFFO01BQ25EO0FBRUEsYUFBTztJQUNWLENBQUM7QUFFRCxXQUFPO01BQ0o7TUFDQSxRQUFTLElBQUksVUFBVSxJQUFJLENBQUEsS0FBTztNQUNsQyxPQUFPLElBQUk7SUFDZDtFQUNIO0FBQ0g7QUFwREEsSUFLYTtBQUxiLElBT2E7QUFQYixJQVNhO0FBVGIsSUFXTTtBQVhOLElBQUEsOEJBQUEsTUFBQTtFQUFBLDhDQUFBO0FBQUE7QUFDQSxlQUFBO0FBQ0EsNEJBQUE7QUFDQSxvQkFBQTtBQUVhLHFCQUFpQjtBQUVqQixzQkFBa0I7QUFFbEIsZUFBVztBQUVsQix3QkFBb0IsQ0FBQyxRQUFRLFFBQVEsV0FBVyxRQUFRLGVBQWUsY0FBYztFQUFBO0FBQUEsQ0FBQTtBQ1gzRixJQUFBLGVBQUEsQ0FBQTtBQUFBRSxVQUFBLGNBQUE7RUFBQSxpQkFBQSxNQUFBO0VBQUEseUJBQUEsTUFBQTtBQUFBLENBQUE7QUFNTyxTQUFTLGdCQUFnQixZQUEwRDtBQUN2RixNQUFJLFlBQVkscUJBQXFCLFVBQVU7QUFFL0MsUUFBTSxXQUFXLENBQUMsTUFBTTtBQUV4QixNQUFJLGNBQUEsSUFBOEI7QUFDL0IsZ0JBQUE7QUFDQSxhQUFTLEtBQUssYUFBYTtFQUM5QjtBQUVBLFdBQVMsS0FBSyxHQUFHLFVBQVU7QUFFM0IsU0FDRyx3QkFBd0IsUUFBUSxLQUFLO0lBQ2xDO0lBQ0EsUUFBUTtJQUNSLFFBQVEsY0FBYyxTQUFTO0VBQ2xDO0FBRU47QUFFTyxTQUFTLHdCQUF3QixZQUF5QztBQUM5RSxRQUFNLFFBQVEsV0FBVyxPQUFPLFdBQVc7QUFFM0MsTUFBSSxNQUFNLFNBQVMsR0FBRztBQUNuQixXQUFPO01BQ0osc0RBQXNELE1BQU0sS0FBSyxHQUFHO0lBQ3ZFO0VBQ0g7QUFFQSxNQUFJLE1BQU0sVUFBVSxXQUFXLFNBQVMsSUFBSSxHQUFHO0FBQzVDLFdBQU87TUFDSixnQkFBZ0I7SUFDbkI7RUFDSDtBQUNIO0FBekNBLElBQUEsWUFBQSxNQUFBO0VBQUEsMEJBQUE7QUFBQTtBQUVBLG9CQUFBO0FBQ0EsNEJBQUE7QUFDQSxjQUFBO0VBQUE7QUFBQSxDQUFBO0FDZ0VBLFNBQVMsYUFDTixRQUNBLFVBQ21CO0FBQ25CLFFBQU0sU0FBbUIsQ0FBQztBQUMxQixRQUFNLFlBQXNCLENBQUM7QUFFN0IsU0FBTyxLQUFLLE1BQU0sRUFBRSxRQUFRLENBQUMsVUFBVTtBQUNwQyxXQUFPLEtBQUssS0FBSztBQUNqQixjQUFVLEtBQUssT0FBTyxPQUFPLEtBQUEsQ0FBTSxDQUFDO0VBQ3ZDLENBQUM7QUFFRCxTQUFPLENBQUMsUUFBUSxVQUFVLEtBQUssUUFBUSxDQUFDO0FBQzNDO0FBRUEsU0FBUyxZQUErQixPQUFtQjtBQUN4RCxTQUFPLE9BQU8sS0FBSyxLQUFLLEVBQUUsT0FBTyxDQUFDLEtBQUssUUFBUTtBQUM1QyxRQUFJLEVBQUUsT0FBTyxpQkFBaUI7QUFDM0IsVUFBSSxHQUFBLElBQU8sTUFBTSxHQUFBO0lBQ3BCO0FBQ0EsV0FBTztFQUNWLEdBQUcsQ0FBQyxDQUFZO0FBQ25CO0FBRU8sU0FBUyxnQkFDYixNQUErQixDQUFDLEdBQ2hDLGFBQXVCLENBQUMsR0FDUDtBQUNqQixRQUFNLFdBQVcsV0FBVyxJQUFJLFVBQVUsY0FBYyxRQUFRO0FBQ2hFLFFBQU0sU0FDSCxDQUFDLGlCQUFpQixJQUFJLE1BQU0sS0FBSyxJQUFJLFNBQ2hDLElBQUksU0FDSjtJQUNHLE1BQU07SUFDTixNQUFNLElBQUksZUFBZSxRQUFRLFFBQVE7SUFDekMsU0FBUztJQUNULE1BQU07SUFDTixNQUFNLElBQUksWUFBWSxPQUFPO0lBQzdCLGFBQWEsSUFBSSxZQUFZLFFBQVEsUUFBUTtJQUM3QyxjQUFjLElBQUksWUFBWSxRQUFRLFFBQVE7RUFDakQ7QUFFUixRQUFNLENBQUMsUUFBUSxTQUFTLElBQUksYUFBYSxRQUFRLFFBQVE7QUFFekQsUUFBTSxTQUFtQixDQUFDO0FBQzFCLFFBQU0sVUFBb0I7SUFDdkIsbUJBQW1CLGlCQUFpQixZQUFZO0lBQ2hELEdBQUc7RUFDTjtBQUVBLFFBQU0sV0FBZ0MsSUFBWSxLQUFNLElBQVksV0FBQSxLQUFnQixJQUFJO0FBQ3hGLE1BQUksVUFBVTtBQUNYLFlBQVEsS0FBSyxlQUFlLFVBQVU7RUFDekM7QUFFQSxNQUFJLElBQUksUUFBUSxJQUFJLElBQUk7QUFDckIsVUFBTSxnQkFBZ0IsSUFBSSxjQUFjLFFBQVEsUUFBUTtBQUN4RCxXQUFPLEtBQUssR0FBRyxJQUFJLFFBQVEsS0FBSyxnQkFBZ0IsSUFBSSxNQUFNLElBQUk7RUFDakU7QUFFQSxNQUFJLGFBQWEsSUFBSSxJQUFJLEdBQUc7QUFDekIsWUFBUSxLQUFLLFlBQVksU0FBUyxJQUFJLElBQUksQ0FBQztFQUM5QztBQUVBLG9CQUFrQixZQUFZLEdBQWMsR0FBRyxPQUFPO0FBRXRELFNBQU87SUFDSjtJQUNBO0lBQ0EsVUFBVSxDQUFDLEdBQUcsU0FBUyxHQUFHLE1BQU07RUFDbkM7QUFDSDtBQUVPLFNBQVMsUUFDYixVQUNBLFFBQ0EsWUFDeUI7QUFDekIsUUFBTUYsVUFBUywyQkFBMkIsVUFBVSxRQUFRLHFCQUFxQixVQUFVLENBQUM7QUFFNUYsU0FBTztJQUNKLFVBQVUsQ0FBQyxPQUFPLEdBQUcsVUFBVTtJQUMvQixRQUFRO0lBQ1IsUUFBQUE7RUFDSDtBQUNIO0FBRWUsU0FBUixjQUE0QztBQUNoRCxTQUFPO0lBQ0osT0FBOEMsTUFBaUI7QUFDNUQsWUFBTSxPQUFPLHlCQUF5QixTQUFTO0FBQy9DLFlBQU0sVUFBVTtRQUNiLHdCQUF3QixTQUFTO1FBQ2pDLFdBQVcsVUFBVSxDQUFBLEdBQUksV0FBVztNQUN2QztBQUNBLFlBQU0sT0FDSCwyQkFBMkIsR0FBRyxJQUFJLEtBQ2xDLHdCQUF3QixRQUFRLFFBQVEsS0FDeEMsY0FBYyxPQUFPO0FBRXhCLGFBQU8sS0FBSyxTQUFTLE1BQU0sSUFBSTtJQUNsQztFQUNIO0FBRUEsV0FBUyxjQUFjLFNBQTJCO0FBQy9DLFdBQU8sUUFBUSxRQUFRLFVBQVUsUUFBUSxRQUFRLFFBQVEsUUFBUTtFQUNwRTtBQUVBLFdBQVMsMkJBQTJCLE1BQWdCLElBQWM7QUFDL0QsV0FDRyxhQUFhLElBQUksS0FDakIsYUFBYSxFQUFFLEtBQ2Y7TUFDRztJQUNIO0VBRU47QUFDSDtBQXpMQSxJQXVCSztBQXZCTCxJQUFBLFdBQUEsTUFBQTtFQUFBLHlCQUFBO0FBQUE7QUFFQSxvQkFBQTtBQUNBLGtCQUFBO0FBQ0EsZ0NBQUE7QUFNQSxlQUFBO0FBVUEsY0FBQTtBQUNBLGNBQUE7QUFFSyxxQkFBTCxrQkFBS1csb0JBQUw7QUFDR0Esc0JBQUFBLGdCQUFBLFVBQUEsSUFBQSxDQUFBLElBQUE7QUFDQUEsc0JBQUFBLGdCQUFBLFdBQUEsSUFBQSxDQUFBLElBQUE7QUFDQUEsc0JBQUFBLGdCQUFBLFVBQUEsSUFBQSxDQUFBLElBQUE7QUFDQUEsc0JBQUFBLGdCQUFBLEdBQUEsSUFBQSxDQUFBLElBQUE7QUFDQUEsc0JBQUFBLGdCQUFBLE1BQUEsSUFBQSxDQUFBLElBQUE7QUFDQUEsc0JBQUFBLGdCQUFBLFFBQUEsSUFBQSxDQUFBLElBQUE7QUFDQUEsc0JBQUFBLGdCQUFBLE1BQUEsSUFBQSxDQUFBLElBQUE7QUFDQUEsc0JBQUFBLGdCQUFBLElBQUEsSUFBQSxDQUFBLElBQUE7QUFDQUEsc0JBQUFBLGdCQUFBLFVBQUEsSUFBQSxDQUFBLElBQUE7QUFDQUEsc0JBQUFBLGdCQUFBLFdBQUEsSUFBQSxDQUFBLElBQUE7QUFDQUEsc0JBQUFBLGdCQUFBLFNBQUEsSUFBQSxFQUFBLElBQUE7QUFDQUEsc0JBQUFBLGdCQUFBLFdBQUEsSUFBQSxFQUFBLElBQUE7QUFDQUEsc0JBQUFBLGdCQUFBLFlBQUEsSUFBQSxFQUFBLElBQUE7QUFiRSxhQUFBQTtJQUFBLEdBQUEsa0JBQUEsQ0FBQSxDQUFBO0VBQUE7QUFBQSxDQUFBO0FDdkJMLElBT2E7QUFQYixJQW1CYTtBQW5CYixJQUFBLG9CQUFBLE1BQUE7RUFBQSxzQ0FBQTtBQUFBO0FBT2EsMkJBQU4sTUFBb0Q7TUFDeEQsWUFDbUIsUUFDQSxPQUFzQixNQUN0QixNQUNqQjtBQUhpQixhQUFBLFNBQUE7QUFDQSxhQUFBLE9BQUE7QUFDQSxhQUFBLE9BQUE7TUFDaEI7TUFFSCxXQUFXO0FBQ1IsZUFBTyxHQUFHLEtBQUssUUFBUSxLQUFLO01BQy9CO0lBQ0g7QUFFYSx5QkFBTixNQUFnRDtNQUFoRCxjQUFBO0FBQ0osYUFBTyxZQUE2QixDQUFDO0FBQ3JDLGFBQU8sU0FBbUIsQ0FBQztBQUMzQixhQUFPLFNBQTRCO01BQUE7TUFFbkMsSUFBSSxTQUFTO0FBQ1YsZUFBTyxLQUFLLFVBQVUsU0FBUztNQUNsQztNQUVBLElBQUksU0FBUztBQUNWLGVBQU8sS0FBSztNQUNmO01BRUEsV0FBVztBQUNSLFlBQUksS0FBSyxVQUFVLFFBQVE7QUFDeEIsaUJBQU8sY0FBYyxLQUFLLFVBQVUsS0FBSyxJQUFJO1FBQ2hEO0FBRUEsZUFBTztNQUNWO0lBQ0g7RUFBQTtBQUFBLENBQUE7QUN2Q0EsSUFPYTtBQVBiLElBdUJhO0FBdkJiLElBQUEsbUJBQUEsTUFBQTtFQUFBLHFDQUFBO0FBQUE7QUFPYSxrQkFBTixNQUF3QztNQUF4QyxjQUFBO0FBQ0osYUFBTyxpQkFBaUI7VUFDckIsS0FBSyxDQUFDO1FBQ1Q7QUFDQSxhQUFPLFVBQVUsQ0FBQztBQUNsQixhQUFPLFVBQW9CLENBQUM7QUFDNUIsYUFBTyxRQUFrQixDQUFDO0FBQzFCLGFBQU8sWUFBbUMsQ0FBQztBQUMzQyxhQUFPLGFBQW9DLENBQUM7QUFDNUMsYUFBTyxVQUE2QjtVQUNqQyxTQUFTO1VBQ1QsV0FBVztVQUNYLFlBQVk7UUFDZjtNQUFBO0lBQ0g7QUFFYSx3QkFBTixNQUFvRDtNQUFwRCxjQUFBO0FBQ0osYUFBQSxTQUFTO0FBQ1QsYUFBQSxPQUFPO1VBQ0osT0FBTztVQUNQLFFBQVE7UUFDWDtBQUNBLGFBQUEsU0FBUztVQUNOLE9BQU87VUFDUCxRQUFRO1FBQ1g7QUFDQSxhQUFBLFVBQVU7TUFBQTtNQUVWLFdBQVc7QUFDUixlQUFPLEtBQUs7TUFDZjtJQUNIO0VBQUE7QUFBQSxDQUFBO0FDL0JBLFNBQVMsd0JBQ04sZ0JBQ2dDO0FBQ2hDLFNBQVEsZUFBZSxVQUFVLGVBQWUsV0FBVztJQUN4RCxhQUFhO0lBQ2IsVUFBVTtJQUNWLGFBQWE7SUFDYixZQUFZO0lBQ1osUUFBUSxFQUFFLE9BQU8sR0FBRyxPQUFPLEVBQUU7SUFDN0IsT0FBTyxFQUFFLE9BQU8sR0FBRyxPQUFPLEVBQUU7RUFDL0I7QUFDSDtBQUVBLFNBQVMsY0FBYyxRQUFnQjtBQUNwQyxRQUFNLFFBQVEsWUFBWSxLQUFLLE1BQU07QUFDckMsUUFBTSxRQUFRLGVBQWUsS0FBSyxNQUFNO0FBRXhDLFNBQU87SUFDSixPQUFPLFNBQVUsU0FBUyxNQUFNLENBQUEsS0FBTyxHQUFHO0lBQzFDLE9BQU8sU0FBVSxTQUFTLE1BQU0sQ0FBQSxLQUFPLEdBQUc7RUFDN0M7QUFDSDtBQTVCQSxJQThCYTtBQTlCYixJQUFBLDRCQUFBLE1BQUE7RUFBQSw0Q0FBQTtBQUFBO0FBS0EsZUFBQTtBQXlCYSxrQ0FDVjtNQUNHLElBQUk7UUFDRDtRQUNBLENBQUMsUUFBUSxDQUFDLFFBQVEsS0FBSyxNQUFNO0FBQzFCLGdCQUFNLE1BQU0sT0FBTyxZQUFZO0FBQy9CLGdCQUFNLGNBQWMsd0JBQXdCLE9BQU8sY0FBYztBQUVqRSxpQkFBTyxPQUFPLGFBQWEsRUFBRSxDQUFDLEdBQUEsR0FBTSxTQUFTLEtBQUssRUFBRSxDQUFDO1FBQ3hEO01BQ0g7TUFDQSxJQUFJO1FBQ0Q7UUFDQSxDQUFDLFFBQVEsQ0FBQyxRQUFRLEtBQUssTUFBTTtBQUMxQixnQkFBTSxNQUFNLE9BQU8sWUFBWTtBQUMvQixnQkFBTSxjQUFjLHdCQUF3QixPQUFPLGNBQWM7QUFFakUsaUJBQU8sT0FBTyxhQUFhLEVBQUUsQ0FBQyxHQUFBLEdBQU0sU0FBUyxLQUFLLEVBQUUsQ0FBQztRQUN4RDtNQUNIO01BQ0EsSUFBSTtRQUNEO1FBQ0EsQ0FBQyxRQUFRLENBQUMsT0FBTyxRQUFRLFVBQVUsTUFBTTtBQUN0QyxnQkFBTSxVQUFVLHdCQUF3QixPQUFPLGNBQWM7QUFDN0Qsa0JBQVEsUUFBUSxjQUFjLEtBQUs7QUFDbkMsa0JBQVEsU0FBUyxjQUFjLE1BQU07QUFDckMsa0JBQVEsYUFBYSxTQUFTLFVBQVU7UUFDM0M7TUFDSDtJQUNIO0VBQUE7QUFBQSxDQUFBO0FDOUJJLFNBQVMsb0JBQ2IsU0FDQSxRQUNvQjtBQUNwQixTQUFPLG9CQUFvQixFQUFFLGdCQUFnQixJQUFJLHFCQUFxQixFQUFPLEdBQUdWLFVBQVMsTUFBTTtBQUNsRztBQWxDQSxJQUlNQTtBQUpOLElBb0NhO0FBcENiLElBQUEsNkJBQUEsTUFBQTtFQUFBLDZDQUFBO0FBQUE7QUFDQSxlQUFBO0FBQ0EsOEJBQUE7QUFFTUEsZUFDSDtNQUNHLElBQUksaUJBQWlCLG9CQUFvQixDQUFDLFFBQVEsQ0FBQyxJQUFJLE1BQU07QUFDMUQsZUFBTyxlQUFlLElBQUksS0FBSyxLQUFLLEtBQUssQ0FBQztBQUMxQyxlQUFPO01BQ1YsQ0FBQztNQUNELEdBQUc7TUFDSCxJQUFJO1FBQ0QsQ0FBQyxvQ0FBb0MscUJBQXFCO1FBQzFELENBQUMsUUFBUSxDQUFDLGNBQWMsTUFBTTtBQUMxQixpQkFBTyxlQUE0QyxpQkFBaUI7UUFDeEU7TUFDSDtNQUNBLElBQUk7UUFDRCxDQUFDLDZDQUE2QyxxQkFBcUI7UUFDbkUsQ0FBQyxRQUFRLENBQUMsT0FBTyxTQUFTLEdBQUcsTUFBTTtBQUMvQixpQkFBTyxlQUE0QyxrQkFBa0I7WUFDbkUsT0FBTyxTQUFTLEtBQUs7WUFDckI7WUFDQTtVQUNIO1FBQ0g7TUFDSDtJQUNIO0FBU1UsMkJBQU4sTUFBcUQ7TUFBckQsY0FBQTtBQUNKLGFBQWdCLE1BQWdCLENBQUM7TUFBQTtJQUNwQztFQUFBO0FBQUEsQ0FBQTtBQ3lCTyxTQUFTLHFCQUFxQixRQUFnQixRQUFnQjtBQUNsRSxRQUFNLFlBQVksb0JBQW9CLElBQUksa0JBQWtCLEdBQUcsY0FBYyxDQUFDLFFBQVEsTUFBTSxDQUFDO0FBRTdGLFNBQU8sVUFBVSxXQUFXO0FBQy9CO0FBbkVBLElBTU07QUFOTixJQU9NO0FBUE4sSUFRTTtBQVJOLElBVU1BO0FBVk4sSUFxQ007QUFyQ04sSUFtRGE7QUFuRGIsSUF1RGE7QUF2RGIsSUFBQSxrQkFBQSxNQUFBO0VBQUEsa0NBQUE7QUFBQTtBQUNBLHFCQUFBO0FBRUEsZUFBQTtBQUNBLCtCQUFBO0FBRU0sd0JBQW9CO0FBQ3BCLG9CQUFnQjtBQUNoQixtQkFBZTtBQUVmQSxlQUFvQztNQUN2QyxJQUFJLFdBQVcsbUJBQW1CLENBQUMsUUFBUSxDQUFDLE1BQU0sWUFBWSxTQUFTLE1BQU07QUFDMUUsZUFBTyxNQUFNLEtBQUssSUFBSTtBQUV0QixZQUFJLFlBQVk7QUFDYixpQkFBTyxXQUFXLElBQUEsSUFBUSxXQUFXO1FBQ3hDO0FBRUEsWUFBSSxXQUFXO0FBQ1osaUJBQU8sVUFBVSxJQUFBLElBQVEsVUFBVTtRQUN0QztNQUNILENBQUM7TUFDRCxJQUFJLFdBQVcsZUFBZSxDQUFDLFFBQVEsQ0FBQyxTQUFTLEVBQUUsWUFBWSxFQUFFLFNBQVMsTUFBTTtBQUM3RSxZQUFJLGVBQWUsVUFBYSxjQUFjLFFBQVc7QUFDdEQsaUJBQU8sUUFBUSxVQUFVLENBQUMsV0FBVztBQUNyQyxpQkFBTyxRQUFRLGFBQWEsQ0FBQyxjQUFjO0FBQzNDLGlCQUFPLFFBQVEsWUFBWSxDQUFDLGFBQWE7QUFDekMsaUJBQU87UUFDVjtBQUNBLGVBQU87TUFDVixDQUFDO01BQ0QsSUFBSSxXQUFXLGNBQWMsQ0FBQyxRQUFRLENBQUMsUUFBUSxJQUFJLE1BQU07QUFDdEQsZUFBTyxPQUFPLE9BQU8sSUFBSTtBQUN6QixlQUFPLFdBQVcsV0FBVyxPQUFPLFVBQVUsT0FBTyxTQUFTLElBQUk7TUFDckUsQ0FBQztJQUNKO0FBRU0sbUJBQStDO01BQ2xELElBQUksV0FBVyxpQkFBaUIsQ0FBQyxRQUFRLENBQUMsTUFBTSxNQUFNLE1BQU0sT0FBTyxTQUFTLE9BQU87TUFDbkYsSUFBSSxXQUFXLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxPQUFPLE1BQU0sTUFBTSxPQUFPLFVBQVUsUUFBUTtNQUN2RixJQUFJO1FBQ0Q7UUFDQSxDQUFDLFFBQVEsQ0FBQyxXQUFXLFlBQVksYUFBYSxZQUFZLE1BQU07QUFDN0QsaUJBQU8sT0FBTyxRQUFRO0FBQ3RCLGlCQUFPLEtBQUssUUFBUTtBQUNwQixpQkFBTyxPQUFPLFNBQVM7QUFDdkIsaUJBQU8sS0FBSyxTQUFTO1FBQ3hCO01BQ0g7SUFDSDtBQUVhLHNCQUFrRCxDQUFDLFFBQVEsV0FBVztBQUNoRixhQUFPLG9CQUFvQixJQUFJLFlBQVksR0FBR0EsVUFBUyxDQUFDLFFBQVEsTUFBTSxDQUFDO0lBQzFFO0FBRWEsc0JBQWtELENBQUMsUUFBUSxXQUFXO0FBQ2hGLGFBQU8sT0FBTztRQUNYLElBQUksWUFBWTtRQUNoQixnQkFBZ0IsUUFBUSxNQUFNO1FBQzlCLG9CQUFvQyxRQUFRLE1BQU07TUFDckQ7SUFDSDtFQUFBO0FBQUEsQ0FBQTtBQzdEQSxJQU1NQTtBQU5OLElBOEJhO0FBOUJiLElBc0NhO0FBdENiLElBQUEsbUJBQUEsTUFBQTtFQUFBLG1DQUFBO0FBQUE7QUFDQSxzQkFBQTtBQUVBLGVBQUE7QUFDQSxvQkFBQTtBQUVNQSxlQUFxQztNQUN4QyxJQUFJLFdBQVcseUJBQXlCLENBQUMsU0FBUyxDQUFDLFNBQVMsTUFBTTtBQUMvRCxnQkFBUSxPQUFPLEtBQUssU0FBUztNQUNoQyxDQUFDO01BQ0QsSUFBSSxXQUFXLGlEQUFpRCxDQUFDLFNBQVMsQ0FBQyxRQUFRLElBQUksTUFBTTtBQUMxRixnQkFBUSxVQUFVLEtBQUssSUFBSSxxQkFBcUIsUUFBUSxJQUFJLENBQUM7TUFDaEUsQ0FBQztNQUNELElBQUk7UUFDRDtRQUNBLENBQUMsU0FBUyxDQUFDLFFBQVEsTUFBTSxTQUFTLE1BQU07QUFDckMsa0JBQVEsVUFBVSxLQUFLLElBQUkscUJBQXFCLFFBQVEsTUFBTSxFQUFFLFVBQVUsQ0FBQyxDQUFDO1FBQy9FO01BQ0g7TUFDQSxJQUFJLFdBQVcseUJBQXlCLENBQUMsU0FBUyxDQUFDLE1BQU0sTUFBTTtBQUM1RCxnQkFBUSxVQUFVLEtBQUssSUFBSSxxQkFBcUIsUUFBUSxJQUFJLENBQUM7TUFDaEUsQ0FBQztNQUNELElBQUksV0FBVyxvQ0FBb0MsQ0FBQyxTQUFTLENBQUMsTUFBTSxNQUFNO0FBQ3ZFLGdCQUFRLFNBQVM7TUFDcEIsQ0FBQztJQUNKO0FBS2EsdUJBQW9ELENBQUMsUUFBUSxXQUFXO0FBQ2xGLGFBQU8sT0FBTyxPQUFPLGlCQUFpQixRQUFRLE1BQU0sR0FBRyxnQkFBZ0IsUUFBUSxNQUFNLENBQUM7SUFDekY7QUFNYSx1QkFBb0QsQ0FBQyxXQUFXO0FBQzFFLGFBQU8sb0JBQW9CLElBQUksbUJBQW1CLEdBQUdBLFVBQVMsTUFBTTtJQUN2RTtFQUFBO0FBQUEsQ0FBQTtBQ2xDTyxTQUFTLFVBQVUsWUFBMkQ7QUFDbEYsTUFBSSxDQUFDLFdBQVcsUUFBUTtBQUNyQixXQUFPLHVCQUF1Qix3Q0FBd0M7RUFDekU7QUFFQSxTQUFPO0lBQ0osVUFBVSxDQUFDLFNBQVMsR0FBRyxVQUFVO0lBQ2pDLFFBQVE7SUFDUixPQUFPLFFBQVEsUUFBcUI7QUFDakMsWUFBTSxRQUFRLGlCQUFpQixRQUFRLE1BQU07QUFDN0MsVUFBSSxNQUFNLFFBQVE7QUFDZixjQUFNLElBQUksaUJBQWlCLEtBQUs7TUFDbkM7QUFFQSxhQUFPO0lBQ1Y7RUFDSDtBQUNIO0FBdkJBLElBQUEsYUFBQSxNQUFBO0VBQUEsMkJBQUE7QUFBQTtBQUNBLDRCQUFBO0FBQ0EscUJBQUE7QUFFQSxjQUFBO0VBQUE7QUFBQSxDQUFBO0FDTUEsU0FBUyxxQkFBcUIsT0FBZSxRQUFnQixRQUFzQztBQUNoRyxRQUFNLFVBQVUsT0FBTyxTQUFTLFNBQVM7QUFDekMsUUFBTSxNQUFNLE9BQU8sU0FBUyxLQUFLLEtBQUssY0FBYyxLQUFLLEtBQUs7QUFDOUQsUUFBTSxpQkFBaUIsQ0FBQyxPQUFPLFNBQVMsS0FBSztBQUU3QyxTQUFPO0lBQ0o7SUFDQTtJQUNBLFFBQVEsQ0FBQztJQUNULEtBQUssQ0FBQztJQUNOO0lBQ0E7SUFDQTtFQUNIO0FBQ0g7QUF4QkEsSUEwQk1BO0FBMUJOLElBbUVhO0FBbkViLElBNkVhO0FBN0ViLElBQUEsa0JBQUEsTUFBQTtFQUFBLGtDQUFBO0FBQUE7QUFPQSxlQUFBO0FBQ0EsK0JBQUE7QUFrQk1BLGVBQW9DO01BQ3ZDLElBQUksV0FBVyxxQkFBcUIsQ0FBQyxRQUFRLENBQUMsSUFBSSxNQUFNO0FBQ3JELGVBQU8sT0FBTztNQUNqQixDQUFDO01BQ0QsSUFBSSxXQUFXLHVDQUF1QyxDQUFDLFFBQVEsQ0FBQyxLQUFLLE1BQU07QUFDeEUsZUFBTyxNQUFNLGNBQUEsZUFBQSxDQUFBLEdBQ04sT0FBTyxPQUFPLENBQUMsQ0FBQSxHQURUO1VBRVY7UUFDSCxDQUFBO01BQ0gsQ0FBQztNQUNELElBQUksV0FBVyxxQ0FBcUMsQ0FBQyxRQUFRLENBQUMsT0FBTyxRQUFRLElBQUksTUFBTTtBQUNwRixlQUFPLE9BQU8sS0FBSyxxQkFBcUIsT0FBTyxRQUFRLElBQUksQ0FBQztNQUMvRCxDQUFDO01BQ0QsSUFBSTtRQUNEO1FBQ0EsQ0FBQyxRQUFRLENBQUMsT0FBTyxRQUFRLFVBQVUsTUFBTTtBQUN0QyxpQkFBTyxTQUFTLGNBQUEsZUFBQSxDQUFBLEdBQ1QsT0FBTyxVQUFVLENBQUMsQ0FBQSxHQURUO1lBRWI7WUFDQTtZQUNBO1VBQ0gsQ0FBQTtRQUNIO01BQ0g7TUFDQSxJQUFJO1FBQ0Q7UUFDQSxDQUFDLFFBQVEsQ0FBQyxPQUFPLFFBQVEsTUFBTSxFQUFFLE1BQU07QUFDcEMsaUJBQU8sU0FBUztZQUNiLE1BQU07Y0FDSDtjQUNBO1lBQ0g7WUFDQSxNQUFNO2NBQ0g7Y0FDQTtZQUNIO1VBQ0g7UUFDSDtNQUNIO0lBQ0g7QUFFYSxzQkFBa0QsQ0FBQyxRQUFRLFdBQVc7QUFDaEYsWUFBTSxhQUFhLGdCQUFnQixRQUFRLE1BQU07QUFDakQsWUFBTSxpQkFBaUIsb0JBQThDLFFBQVEsTUFBTTtBQUVuRixhQUFPLGVBQUEsZUFBQSxDQUFBLEdBQ0QsVUFBQSxHQUNBLGNBQUE7SUFFVDtBQUVhLHNCQUFrRCxDQUFDLFFBQVEsV0FBVztBQUNoRixhQUFPLG9CQUFvQixFQUFFLFFBQVEsQ0FBQyxFQUFFLEdBQUdBLFVBQVMsQ0FBQyxRQUFRLE1BQU0sQ0FBQztJQUN2RTtFQUFBO0FBQUEsQ0FBQTtBQy9FQSxJQUFBLGVBQUEsQ0FBQTtBQUFBQyxVQUFBLGNBQUE7RUFBQSxjQUFBLE1BQUE7RUFBQSxVQUFBLE1BQUE7QUFBQSxDQUFBO0FBT08sU0FBUyxhQUFhLE1BQWUsQ0FBQyxHQUFHLFlBQThDO0FBQzNGLFNBQU8sWUFBWSxRQUFRO0FBQzNCLFNBQU8sU0FBUyxLQUFLLFVBQVU7QUFDbEM7QUFFTyxTQUFTLFNBQVMsTUFBZSxDQUFDLEdBQUcsWUFBOEM7QUFDdkYsUUFBTSxXQUFXLENBQUMsUUFBUSxHQUFHLFVBQVU7QUFDdkMsTUFBSSxJQUFJLFFBQVE7QUFDYixhQUFTLE9BQU8sR0FBRyxHQUFHLElBQUksTUFBTTtFQUNuQztBQUNBLE1BQUksSUFBSSxRQUFRO0FBQ2IsYUFBUyxPQUFPLEdBQUcsR0FBRyxJQUFJLE1BQU07RUFDbkM7QUFFQSxTQUFPLFVBQVUsSUFBSTtBQUNyQixTQUFPLFVBQVUsV0FBVztBQUM1QixTQUFPLFVBQVUsYUFBYTtBQUU5QixTQUFPO0lBQ0o7SUFDQSxRQUFRO0lBQ1IsUUFBQTtFQUNIO0FBQ0g7QUE5QkEsSUFBQSxZQUFBLE1BQUE7RUFBQSwwQkFBQTtBQUFBO0FBQ0Esb0JBQUE7QUFFQSxlQUFBO0VBQUE7QUFBQSxDQUFBO0FDRWUsU0FBUixlQUE0RDtBQUNoRSxTQUFPO0lBQ0osYUFBK0I7QUFDNUIsWUFBTSxXQUFXLENBQUMsUUFBUSxHQUFHLG1CQUFtQixXQUFXLENBQUMsQ0FBQztBQUM3RCxVQUFJLENBQUMsU0FBUyxTQUFTLFVBQVUsR0FBRztBQUNqQyxpQkFBUyxPQUFPLEdBQUcsR0FBRyxVQUFVO01BQ25DO0FBRUEsYUFBTyxLQUFLO1FBQ1QsMEJBQTBCLFFBQVE7UUFDbEMseUJBQXlCLFNBQVM7TUFDckM7SUFDSDtJQUVBLE9BQXlCO0FBQ3RCLFlBQU0sV0FBVyxDQUFDLFFBQVEsR0FBRyxtQkFBbUIsV0FBVyxDQUFDLENBQUM7QUFDN0QsYUFBTyxLQUFLO1FBQ1QsMEJBQTBCLFFBQVE7UUFDbEMseUJBQXlCLFNBQVM7TUFDckM7SUFDSDtFQUNIO0FBQ0g7QUEzQkEsSUFBQSxZQUFBLE1BQUE7RUFBQSwwQkFBQTtBQUFBO0FBRUEsZUFBQTtBQUNBLGNBQUE7RUFBQTtBQUFBLENBQUE7QUNIQSxJQUVhO0FBRmIsSUFJYTtBQUpiLElBQUEseUJBQUEsTUFBQTtFQUFBLDJDQUFBO0FBQUE7QUFFYSxvQkFBZ0I7QUFFaEIsd0JBQU4sTUFBb0Q7TUFHeEQsWUFDVSxNQUNBLE9BQ0EsYUFDUjtBQUhRLGFBQUEsT0FBQTtBQUNBLGFBQUEsUUFBQTtBQUNBLGFBQUEsY0FBQTtBQUVQLFlBQUksVUFBVSxPQUFPLGdCQUFnQixLQUFLO0FBQ3ZDLGdCQUFNLFNBQVMsY0FBYyxLQUFLLElBQUksS0FBSyxDQUFDLE1BQU0sTUFBTSxJQUFJO0FBQzVELGVBQUssT0FBTyxPQUFPLENBQUEsS0FBTTtBQUN6QixlQUFLLE9BQU8sT0FBTyxDQUFBLEtBQU07UUFDNUI7TUFDSDtJQUNIO0VBQUE7QUFBQSxDQUFBO0FDcUJBLFNBQVMsWUFBWSxNQUFjO0FBQ2hDLFFBQU0sQ0FBQyxJQUFJLElBQUksSUFBSSxLQUFLLE1BQU0sSUFBSTtBQUVsQyxTQUFPO0lBQ0osTUFBTSxRQUFRO0lBQ2Q7RUFDSDtBQUNIO0FBRUEsU0FBU0YsUUFDTixRQUNBLFFBQ0EsU0FDMkI7QUFDM0IsU0FBTyxDQUFDLEdBQUcsU0FBUyxVQUFVLE9BQU87QUFDeEM7QUFFQSxTQUFTLFVBQVUsV0FBZ0MsUUFBK0I7QUFDL0UsU0FBTyxPQUFPLElBQUksQ0FBQyxNQUFNQSxRQUFPLFFBQVEsR0FBRyxDQUFDLFFBQVEsU0FBUyxPQUFPLE9BQU8sWUFBWSxJQUFJLENBQUMsQ0FBQztBQUNoRztBQTRIQSxTQUFTLFVBQVUsUUFBc0IsU0FBaUI7QUFDdkQsUUFBTUgsV0FBVSxRQUFRLEtBQUs7QUFDN0IsVUFBUSxLQUFBO0lBQUEsS0FDQUEsU0FBUSxPQUFPLENBQUM7QUFDbEIsYUFBTyxLQUFLQSxTQUFRLE9BQU8sQ0FBQyxHQUFHQSxTQUFRLE9BQU8sQ0FBQyxHQUFHQSxTQUFRLE9BQU8sQ0FBQyxDQUFDO0lBQUEsS0FDakVBLFNBQVEsT0FBTyxDQUFDO0FBQ2xCLGFBQU8sS0FBSyxLQUEwQkEsU0FBUSxPQUFPLENBQUMsR0FBR0EsU0FBUSxPQUFPLENBQUMsQ0FBQztJQUFBO0FBRTFFO0VBQUE7QUFHTixXQUFTLEtBQUssT0FBZSxZQUFvQixNQUFjO0FBQzVELFVBQU0sTUFBTSxHQUFHLFFBQVE7QUFDdkIsVUFBTSxVQUFVSSxTQUFRLElBQUksR0FBRztBQUUvQixRQUFJLFNBQVM7QUFDVixjQUFRLFFBQVEsSUFBSTtJQUN2QjtBQUVBLFFBQUksUUFBUSxRQUFRLFFBQVEsTUFBTTtBQUMvQixhQUFPLE1BQU0sS0FBSyxJQUFJLGtCQUFrQixNQUFNLE9BQU8sVUFBVSxDQUFDO0lBQ25FO0VBQ0g7QUFDSDtBQTdNQSxJQU1hO0FBTmIsSUE0RE1BO0FBNUROLElBaUthO0FBaktiLElBQUEscUJBQUEsTUFBQTtFQUFBLHVDQUFBO0FBQUE7QUFDQSxlQUFBO0FBQ0EsMkJBQUE7QUFJYSxvQkFBTixNQUE0QztNQUE1QyxjQUFBO0FBQ0osYUFBTyxZQUFZLENBQUM7QUFDcEIsYUFBTyxhQUFhLENBQUM7QUFDckIsYUFBTyxVQUFVLENBQUM7QUFDbEIsYUFBTyxVQUFVLENBQUM7QUFDbEIsYUFBTyxVQUFVO0FBQ2pCLGFBQU8sV0FBVyxDQUFDO0FBQ25CLGFBQU8sVUFBVSxDQUFDO0FBQ2xCLGFBQU8sUUFBUSxDQUFDO0FBQ2hCLGFBQU8sU0FBUyxDQUFDO0FBQ2pCLGFBQU8sUUFBUTtBQUNmLGFBQU8sU0FBUztBQUNoQixhQUFPLFVBQVU7QUFDakIsYUFBTyxXQUFXO0FBQ2xCLGFBQU8sV0FBVztBQUVsQixhQUFPLFVBQVUsTUFBTTtBQUNwQixpQkFBTyxDQUFDLEtBQUssTUFBTTtRQUN0QjtNQUFBO0lBQ0g7QUFtQ01BLGVBQXlDLElBQUksSUFBSTtNQUNwREQ7UUFBTztRQUEwQjtRQUEyQixDQUFDLFFBQVEsU0FDbEUsT0FBTyxPQUFPLFNBQVMsSUFBSTtNQUM5QjtNQUNBQTtRQUFPO1FBQTBCO1FBQTZCLENBQUMsUUFBUSxTQUNwRSxPQUFPLE9BQU8sU0FBUyxJQUFJO01BQzlCO01BQ0FBO1FBQU87UUFBMEI7UUFBOEIsQ0FBQyxRQUFRLFNBQ3JFLE9BQU8sT0FBTyxVQUFVLElBQUk7TUFDL0I7TUFFQUE7UUFDRztRQUNBO1FBQ0EsQ0FBQyxRQUFRLFNBQVMsT0FBTyxPQUFPLFNBQVMsSUFBSSxLQUFLLE9BQU8sT0FBTyxRQUFRLElBQUk7TUFDL0U7TUFDQUE7UUFDRztRQUNBO1FBQ0EsQ0FBQyxRQUFRLFNBQ04sT0FBTyxPQUFPLFNBQVMsSUFBSSxLQUMzQixPQUFPLE9BQU8sUUFBUSxJQUFJLEtBQzFCLE9BQU8sT0FBTyxVQUFVLElBQUk7TUFDbEM7TUFFQUE7UUFDRztRQUNBO1FBQ0EsQ0FBQyxRQUFRLFNBQVMsT0FBTyxPQUFPLFNBQVMsSUFBSSxLQUFLLE9BQU8sT0FBTyxRQUFRLElBQUk7TUFDL0U7TUFFQUE7UUFDRztRQUNBO1FBQ0EsQ0FBQyxRQUFRLFNBQVMsT0FBTyxPQUFPLFVBQVUsSUFBSSxLQUFLLE9BQU8sT0FBTyxRQUFRLElBQUk7TUFDaEY7TUFDQUE7UUFDRztRQUNBO1FBQ0EsQ0FBQyxRQUFRLFNBQVMsT0FBTyxPQUFPLFVBQVUsSUFBSSxLQUFLLE9BQU8sT0FBTyxRQUFRLElBQUk7TUFDaEY7TUFFQUEsUUFBTyxLQUE2QixLQUEwQixDQUFDLFFBQVEsU0FBUztBQUM3RSxlQUFPLE9BQU8sU0FBUyxZQUFZLElBQUksQ0FBQztNQUMzQyxDQUFDO01BQ0RBLFFBQU8sS0FBNkIsS0FBOEIsQ0FBQyxRQUFRLFNBQVM7QUFDakYsY0FBTSxVQUFVLFlBQVksSUFBSTtBQUNoQyxlQUFPLE9BQU8sU0FBUyxPQUFPO0FBQzlCLGVBQU8sT0FBTyxVQUFVLFFBQVEsRUFBRTtNQUNyQyxDQUFDO01BQ0RBLFFBQU8sS0FBNkIsS0FBNkIsQ0FBQyxTQUFTLFVBQVU7QUFDbEYsZUFBUSxRQUFRLFVBQVUsUUFBUSxXQUFXLENBQUMsR0FBSSxLQUFLO01BQzFELENBQUM7TUFFREE7UUFBTztRQUErQjtRQUErQixDQUFDLFFBQVEsU0FDM0UsT0FBTyxPQUFPLFdBQVcsSUFBSTtNQUNoQztNQUVBLEdBQUc7UUFBVTtRQUEyQjtRQUEyQjs7TUFBNEI7TUFDL0YsR0FBRztRQUNBO1FBQ0E7UUFDQTs7TUFDSDtNQUNBLEdBQUc7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7TUFDSDtNQUVBO1FBQ0c7UUFDQSxDQUFDLFFBQVEsU0FBUztBQUNmLGdCQUFNLFdBQVc7QUFDakIsZ0JBQU0sWUFBWTtBQUNsQixnQkFBTSxhQUFhO0FBQ25CLGdCQUFNLGNBQWM7QUFDcEIsZ0JBQU0sbUJBQW1CO0FBQ3pCLGNBQUk7QUFFSix3QkFBYyxTQUFTLEtBQUssSUFBSTtBQUNoQyxpQkFBTyxRQUFTLGVBQWUsQ0FBQyxZQUFZLENBQUEsS0FBTztBQUVuRCx3QkFBYyxVQUFVLEtBQUssSUFBSTtBQUNqQyxpQkFBTyxTQUFVLGVBQWUsQ0FBQyxZQUFZLENBQUEsS0FBTztBQUVwRCx3QkFBYyxXQUFXLEtBQUssSUFBSTtBQUNsQyxpQkFBTyxVQUFVLGVBQWUsWUFBWSxDQUFBO0FBRTVDLHdCQUFjLFlBQVksS0FBSyxJQUFJO0FBQ25DLGlCQUFPLFdBQVcsZUFBZSxZQUFZLENBQUE7QUFFN0Msd0JBQWMsaUJBQWlCLEtBQUssSUFBSTtBQUN4QyxpQkFBTyxVQUFXLGVBQWUsWUFBWSxDQUFBLEtBQU8sT0FBTztBQUUzRCxpQkFBTyxXQUFXLGdCQUFnQixLQUFLLElBQUk7UUFDOUM7TUFDSDtJQUNILENBQUM7QUFFWSx5QkFBcUIsU0FBVSxNQUE0QjtBQUNyRSxZQUFNLFFBQVEsS0FBSyxNQUFNLElBQUk7QUFDN0IsWUFBTSxTQUFTLElBQUksY0FBYztBQUVqQyxlQUFTLElBQUksR0FBRyxJQUFJLE1BQU0sUUFBUSxJQUFJLEtBQUs7QUFDeEMsWUFBSSxPQUFPLE1BQU0sR0FBQSxFQUFLLEtBQUs7QUFFM0IsWUFBSSxDQUFDLE1BQU07QUFDUjtRQUNIO0FBRUEsWUFBSSxLQUFLLE9BQU8sQ0FBQyxNQUFNLEtBQTZCO0FBQ2pELGtCQUFRLFFBQVEsTUFBTSxHQUFBLEtBQVE7UUFDakM7QUFFQSxrQkFBVSxRQUFRLElBQUk7TUFDekI7QUFFQSxhQUFPO0lBQ1Y7RUFBQTtBQUFBLENBQUE7QUM5S08sU0FBUyxXQUFXLFlBQWdEO0FBQ3hFLFFBQU0sV0FBVztJQUNkO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxHQUFHLFdBQVcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxlQUFlLFNBQVMsR0FBRyxDQUFDO0VBQzlEO0FBRUEsU0FBTztJQUNKLFFBQVE7SUFDUjtJQUNBLE9BQU8sTUFBYztBQUNsQixhQUFPLG1CQUFtQixJQUFJO0lBQ2pDO0VBQ0g7QUFDSDtBQXZCQSxJQUlNO0FBSk4sSUFBQSxjQUFBLE1BQUE7RUFBQSw0QkFBQTtBQUFBO0FBQ0EsdUJBQUE7QUFHTSxxQkFBaUIsQ0FBQyxVQUFVLElBQUk7RUFBQTtBQUFBLENBQUE7QUNVdEMsU0FBUyxnQkFDTixRQUFRLEdBQ1IsUUFBUSxHQUNSLFFBQXlCLEdBQ3pCLFFBQVEsSUFDUixZQUFZLE1BQ0U7QUFDZCxTQUFPLE9BQU87SUFDWDtNQUNHO01BQ0E7TUFDQTtNQUNBO01BQ0E7SUFDSDtJQUNBO0lBQ0E7TUFDRyxRQUFRO0FBQ0wsZUFBTyxHQUFHLEtBQUssU0FBUyxLQUFLLFNBQVMsS0FBSztNQUM5QztNQUNBLGNBQWM7TUFDZCxZQUFZO0lBQ2Y7RUFDSDtBQUNIO0FBRUEsU0FBUyx1QkFBdUI7QUFDN0IsU0FBTyxnQkFBZ0IsR0FBRyxHQUFHLEdBQUcsSUFBSSxLQUFLO0FBQzVDO0FBRWUsU0FBUixrQkFBZ0Q7QUFDcEQsU0FBTztJQUNKLFVBQTRCO0FBQ3pCLGFBQU8sS0FBSyxTQUFTO1FBQ2xCLFVBQVUsQ0FBQyxXQUFXO1FBQ3RCLFFBQVE7UUFDUixRQUFRO1FBQ1IsUUFBUSxRQUFRLE9BQU8sTUFBTSxNQUFNO0FBQ2hDLGNBQUksT0FBTyxhQUFBLElBQWtDO0FBQzFDLG1CQUFPLEtBQUssT0FBTyxLQUFLLGFBQWEsQ0FBQztVQUN6QztBQUVBLGVBQUssS0FBSztRQUNiO01BQ0gsQ0FBQztJQUNKO0VBQ0g7QUFDSDtBQW9CQSxTQUFTLGNBQWMsUUFBZ0I7QUFDcEMsTUFBSSxXQUFXLGVBQWU7QUFDM0IsV0FBTyxxQkFBcUI7RUFDL0I7QUFFQSxTQUFPLG9CQUFvQixnQkFBZ0IsR0FBRyxHQUFHLEdBQUcsTUFBTSxHQUFHQyxVQUFTLE1BQU07QUFDL0U7QUF2RkEsSUFZTTtBQVpOLElBK0RNQTtBQS9ETixJQUFBLGVBQUEsTUFBQTtFQUFBLDZCQUFBO0FBQUE7QUFFQSxlQUFBO0FBVU0sb0JBQWdCO0FBbURoQkEsZUFBdUM7TUFDMUMsSUFBSTtRQUNEO1FBQ0EsQ0FBQyxRQUFRLENBQUMsT0FBTyxPQUFPLE9BQU8sUUFBUSxFQUFFLE1BQU07QUFDNUMsaUJBQU87WUFDSjtZQUNBLGdCQUFnQixTQUFTLEtBQUssR0FBRyxTQUFTLEtBQUssR0FBRyxTQUFTLEtBQUssR0FBRyxLQUFLO1VBQzNFO1FBQ0g7TUFDSDtNQUNBLElBQUk7UUFDRDtRQUNBLENBQUMsUUFBUSxDQUFDLE9BQU8sT0FBTyxPQUFPLFFBQVEsRUFBRSxNQUFNO0FBQzVDLGlCQUFPLE9BQU8sUUFBUSxnQkFBZ0IsU0FBUyxLQUFLLEdBQUcsU0FBUyxLQUFLLEdBQUcsT0FBTyxLQUFLLENBQUM7UUFDeEY7TUFDSDtJQUNIO0VBQUE7QUFBQSxDQUFBO0FDL0VBLElBQUEseUJBQUEsQ0FBQTtBQUFBQyxVQUFBLHdCQUFBO0VBQUEsY0FBQSxNQUFBO0FBQUEsQ0FBQTtBQUFBLElBMkJhO0FBM0JiLElBQUEsc0JBQUEsTUFBQTtFQUFBLDhCQUFBO0FBQUE7QUFDQSx1QkFBQTtBQUNBLGtDQUFBO0FBQ0Esa0JBQUE7QUFDQSx1QkFBQTtBQUNBLGdCQUFBO0FBQ0EsZ0JBQUE7QUFDQSxzQkFBQTtBQUNBLGNBQUE7QUFDQSxxQkFBQTtBQUNBLGNBQUE7QUFDQSxhQUFBO0FBQ0EsZUFBQTtBQUNBLGNBQUE7QUFDQSxjQUFBO0FBQ0EsZ0JBQUE7QUFDQSxjQUFBO0FBQ0EsaUJBQUE7QUFFQSxlQUFBO0FBUWEsbUJBQU4sTUFBNEM7TUFDaEQsWUFBb0IsV0FBOEI7QUFBOUIsYUFBQSxZQUFBO01BQStCO01BRXpDLFNBQVksTUFBd0IsTUFBaUM7QUFDNUUsY0FBTSxRQUFRLEtBQUssVUFBVSxNQUFNO0FBQ25DLGNBQU0sVUFBVSxNQUFNLEtBQUssSUFBSTtBQUUvQixZQUFJLE1BQU07QUFDUCx1QkFBYSxNQUFNLFNBQVMsSUFBSTtRQUNuQztBQUVBLGVBQU8sT0FBTyxPQUFPLE1BQU07VUFDeEIsTUFBTSxFQUFFLE9BQU8sUUFBUSxLQUFLLEtBQUssT0FBTyxFQUFFO1VBQzFDLE9BQU8sRUFBRSxPQUFPLFFBQVEsTUFBTSxLQUFLLE9BQU8sRUFBRTtVQUM1QyxXQUFXLEVBQUUsT0FBTyxNQUFNO1FBQzdCLENBQUM7TUFDSjtNQUVBLElBQUksT0FBMEI7QUFDM0IsZUFBTyxLQUFLO1VBQ1QsMEJBQTBCLENBQUMsT0FBTyxHQUFHLFFBQVEsS0FBSyxDQUFDLENBQUM7VUFDcEQseUJBQXlCLFNBQVM7UUFDckM7TUFDSDtNQUVBLElBQUksV0FBc0Q7QUFDdkQsY0FBTSxPQUFPLHlCQUF5QixTQUFTO0FBRS9DLFlBQUksT0FBTyxjQUFjLFVBQVU7QUFDaEMsaUJBQU8sS0FBSyxTQUFTLDJCQUEyQixXQUFXLEtBQUssU0FBUyxHQUFHLElBQUk7UUFDbkY7QUFFQSxZQUFJLFFBQU8sYUFBQSxPQUFBLFNBQUEsVUFBVyxVQUFTLFVBQVU7QUFDdEMsaUJBQU8sS0FBSztZQUNUO2NBQ0csVUFBVTtjQUNULFVBQVUsUUFBUSxLQUFLLGFBQWM7WUFDekM7WUFDQTtVQUNIO1FBQ0g7QUFFQSxlQUFPLEtBQUs7VUFDVCx1QkFBdUIsd0RBQXdEO1VBQy9FO1FBQ0g7TUFDSDtNQUVBLFdBQVcsTUFBYyxPQUEwQjtBQUNoRCxlQUFPLEtBQUs7VUFDVCxlQUFlLE1BQU0sVUFBVSxJQUFJO1VBQ25DLHlCQUF5QixTQUFTO1FBQ3JDO01BQ0g7TUFFQSxLQUFLLE1BQTBCO0FBQzVCLGVBQU8sS0FBSztVQUNULFNBQVMsU0FBUyxNQUFNLEtBQUssVUFBVSxLQUFLLG1CQUFtQixTQUFTLENBQUM7VUFDekUseUJBQXlCLFNBQVM7UUFDckM7TUFDSDtNQUVBLFFBQVE7QUFDTCxlQUFPLEtBQUs7VUFDVCxVQUFVLG1CQUFtQixTQUFTLENBQUM7VUFDdkMseUJBQXlCLFNBQVM7UUFDckM7TUFDSDtNQUVBLFlBQVksUUFBZ0IsUUFBZ0I7QUFDekMsWUFBSSxFQUFFLGFBQWEsTUFBTSxLQUFLLGFBQWEsTUFBTSxJQUFJO0FBQ2xELGlCQUFPLEtBQUs7WUFDVDtjQUNHO1lBQ0g7VUFDSDtRQUNIO0FBRUEsZUFBTyxLQUFLO1VBQ1QsVUFBVSxDQUFDLFFBQVEsUUFBUSxHQUFHLG1CQUFtQixTQUFTLENBQUMsQ0FBQztVQUM1RCx5QkFBeUIsV0FBVyxLQUFLO1FBQzVDO01BQ0g7TUFFQSxjQUFjLFNBQXdCO0FBQ25DLGFBQUssVUFBVSxnQkFBZ0I7QUFDL0IsZUFBTztNQUNWO01BRUEsT0FBTztBQUNKLGNBQU0sT0FBTztVQUNWO1lBQ0csUUFBUSxXQUFXLFVBQVUsQ0FBQSxHQUFJLFlBQVk7WUFDN0MsUUFBUSxXQUFXLFVBQVUsQ0FBQSxHQUFJLFlBQVk7VUFDaEQ7VUFDQSxtQkFBbUIsU0FBUztRQUMvQjtBQUVBLGVBQU8sS0FBSyxTQUFTLE1BQU0seUJBQXlCLFNBQVMsQ0FBQztNQUNqRTtNQUVBLFFBQVE7QUFDTCxlQUFPLEtBQUs7VUFDVCwwQkFBMEIsQ0FBQyxTQUFTLEdBQUcsbUJBQW1CLFNBQVMsQ0FBQyxDQUFDO1VBQ3JFLHlCQUF5QixTQUFTO1FBQ3JDO01BQ0g7TUFFQSxTQUFTO0FBQ04sZUFBTyxLQUFLO1VBQ1QsV0FBVyxtQkFBbUIsU0FBUyxDQUFDO1VBQ3hDLHlCQUF5QixTQUFTO1FBQ3JDO01BQ0g7SUFDSDtBQUVBLFdBQU87TUFDSixhQUFhO01BQ2IsaUJBQVM7TUFDVCxlQUFPO01BQ1AsZUFBTztNQUNQLHNCQUFhO01BQ2IscUJBQVk7TUFDWixhQUFLO01BQ0wsWUFBSTtNQUNKLGFBQUs7TUFDTCxnQkFBUTtJQUNYO0VBQUE7QUFBQSxDQUFBO0FDMUpBLElBQUEsb0JBQUEsQ0FBQTtBQUFBQSxVQUFBLG1CQUFBO0VBQUEsV0FBQSxNQUFBO0FBQUEsQ0FBQTtBQUFBLElBU007QUFUTixJQXVCYTtBQXZCYixJQUFBLGlCQUFBLE1BQUE7RUFBQSxpQ0FBQTtBQUFBO0FBQUEsZUFBQTtBQUVBLG9CQUFBO0FBT00sMkJBQTRDLE1BQU07QUFDckQsVUFBSSxLQUFLO0FBQ1QsYUFBTyxNQUFNO0FBQ1Y7QUFDQSxjQUFNLEVBQUUsU0FBUyxLQUFLLFFBQUksd0NBQXlDO0FBRW5FLGVBQU87VUFDSjtVQUNBO1VBQ0E7UUFDSDtNQUNIO0lBQ0gsR0FBRztBQUVVLGdCQUFOLE1BQWdCO01BS3BCLFlBQW9CLGNBQWMsR0FBRztBQUFqQixhQUFBLGNBQUE7QUFKcEIsYUFBUSxTQUFTLGFBQWEsSUFBSSxXQUFXO0FBQzdDLGFBQVEsVUFBMkIsQ0FBQztBQUNwQyxhQUFRLFVBQTJCLENBQUM7QUFHakMsYUFBSyxPQUFPLCtCQUErQixXQUFXO01BQ3pEO01BRVEsV0FBVztBQUNoQixZQUFJLENBQUMsS0FBSyxRQUFRLFVBQVUsS0FBSyxRQUFRLFVBQVUsS0FBSyxhQUFhO0FBQ2xFLGVBQUs7WUFDRjtZQUNBLEtBQUssUUFBUTtZQUNiLEtBQUssUUFBUTtZQUNiLEtBQUs7VUFDUjtBQUNBO1FBQ0g7QUFFQSxjQUFNLE9BQU8sT0FBTyxLQUFLLFNBQVMsS0FBSyxRQUFRLE1BQU0sQ0FBRTtBQUN2RCxhQUFLLE9BQU8sb0JBQW9CLEtBQUssRUFBRTtBQUN2QyxhQUFLLEtBQUssTUFBTTtBQUNiLGVBQUssT0FBTyxrQkFBa0IsS0FBSyxFQUFFO0FBQ3JDLGlCQUFPLEtBQUssU0FBUyxJQUFJO0FBQ3pCLGVBQUssU0FBUztRQUNqQixDQUFDO01BQ0o7TUFFQSxPQUEwQztBQUN2QyxjQUFNLEVBQUUsU0FBUyxHQUFHLElBQUksT0FBTyxLQUFLLFNBQVMsb0JBQW9CLENBQUM7QUFDbEUsYUFBSyxPQUFPLG9CQUFvQixFQUFFO0FBRWxDLGFBQUssU0FBUztBQUVkLGVBQU87TUFDVjtJQUNIO0VBQUE7QUFBQSxDQUFBO0FDNURBLElBQUEsc0JBQUEsQ0FBQTtBQUFBQSxVQUFBLHFCQUFBO0VBQUEsZ0JBQUEsTUFBQTtBQUFBLENBQUE7QUFnQ08sU0FBUyxlQUFlLFNBQW1CLFlBQTBDO0FBQ3pGLFNBQU8sMEJBQTBCLENBQUMsU0FBUyxHQUFHLFlBQVksR0FBRyxPQUFPLENBQUM7QUFDeEU7QUFsQ0EsSUFBQSxtQkFBQSxNQUFBO0VBQUEsaUNBQUE7QUFBQTtBQUFBLGNBQUE7RUFBQTtBQUFBLENBQUE7QUNpQk8sU0FBUyxzQkFBc0IsUUFBZ0IsTUFBeUM7QUFDNUYsU0FBTztJQUNKO0lBQ0E7SUFDQSxTQUFTO0VBQ1o7QUFDSDtBQUVPLFNBQVMsc0JBQXNCLFFBQTJDO0FBQzlFLFNBQU87SUFDSjtJQUNBLE1BQU07SUFDTixTQUFTO0VBQ1o7QUFDSDtBQS9CQSxJQU9hO0FBUGIsSUFBQSwyQkFBQSxNQUFBO0VBQUEsNkNBQUE7QUFBQTtBQU9hLDBCQUFOLE1BQTZEO01BQTdELGNBQUE7QUFDSixhQUFBLE1BQWtDLENBQUM7QUFDbkMsYUFBQSxXQUErRCxDQUFDO0FBQ2hFLGFBQUEsU0FBcUMsQ0FBQztNQUFBO01BRXRDLElBQUksVUFBbUI7QUFDcEIsZUFBTyxDQUFDLEtBQUssT0FBTztNQUN2QjtJQUNIO0VBQUE7QUFBQSxDQUFBO0FDb0JPLFNBQVMsdUJBQXVCLE1BQWMsaUJBQXFDO0FBQ3ZGLFNBQU8sb0JBQUEsS0FBdUMsaUJBQWlCLEtBQUssSUFBSTtBQUMzRTtBQXJDQSxJQVNNO0FBVE4sSUFVTTtBQVZOLElBWU1EO0FBWk4sSUE0QmE7QUE1QmIsSUFBQSwyQkFBQSxNQUFBO0VBQUEsMkNBQUE7QUFBQTtBQUNBLDZCQUFBO0FBTUEsZUFBQTtBQUVNLHlCQUFxQjtBQUNyQix1QkFBbUI7QUFFbkJBLGVBQWlEO01BQ3BELElBQUksV0FBVyxvQkFBb0IsQ0FBQyxRQUFRLENBQUMsUUFBUSxJQUFJLE1BQU07QUFDNUQsY0FBTSxXQUFXLHNCQUFzQixRQUFRLElBQUk7QUFFbkQsZUFBTyxJQUFJLEtBQUssUUFBUTtBQUN4QixlQUFPLFNBQVMsTUFBQSxJQUFVO01BQzdCLENBQUM7TUFDRCxJQUFJLFdBQVcsa0JBQWtCLENBQUMsUUFBUSxDQUFDLE1BQU0sTUFBTTtBQUNwRCxjQUFNLFdBQVcsc0JBQXNCLE1BQU07QUFFN0MsZUFBTyxPQUFPLEtBQUssUUFBUTtBQUMzQixlQUFPLElBQUksS0FBSyxRQUFRO0FBQ3hCLGVBQU8sU0FBUyxNQUFBLElBQVU7TUFDN0IsQ0FBQztJQUNKO0FBRWEsMkJBQW9FLENBQzlFLFFBQ0EsV0FDRTtBQUNGLGFBQU8sb0JBQW9CLElBQUksb0JBQW9CLEdBQUdBLFVBQVMsQ0FBQyxRQUFRLE1BQU0sQ0FBQztJQUNsRjtFQUFBO0FBQUEsQ0FBQTtBQ2pDQSxJQU9hO0FBUGIsSUFBQSxxQkFBQSxNQUFBO0VBQUEsdUNBQUE7QUFBQTtBQU9hLDBCQUFOLE1BQW1EO01BQW5ELGNBQUE7QUFDSixhQUFPLE1BQWdCLENBQUM7QUFDeEIsYUFBTyxXQUFpRCxDQUFDO0FBQ3pELGFBQU8sVUFBa0I7QUFDekIsYUFBTyxXQUFvQjtNQUFBO01BRTNCLEtBQ0csUUFDQSxVQUNBLE1BQ0EsUUFDQSxPQUNEO0FBQ0MsWUFBSSxXQUFXLEtBQWdDO0FBQzVDLGVBQUssV0FBVztBQUNoQixlQUFLLFVBQVU7UUFDbEI7QUFFQSxhQUFLLElBQUksS0FBSyxJQUFJO0FBQ2xCLGFBQUssU0FBUyxJQUFBLElBQVE7VUFDbkIsU0FBUyxXQUFXO1VBQ3BCLGdCQUFnQixXQUFXO1VBQzNCO1VBQ0E7VUFDQTtRQUNIO01BQ0g7SUFDSDtFQUFBO0FBQUEsQ0FBQTtBQ2ZBLFNBQVMsYUFBYSxPQUFnQjtBQUNuQyxTQUFPLFFBQVEsTUFBTSxPQUFPLENBQUMsSUFBSTtBQUNwQztBQUVPLFNBQVMsbUJBQW1CLFFBQStCO0FBQy9ELFNBQU8sb0JBQW9CLElBQUksb0JBQW9CLEdBQUdBLFVBQVMsTUFBTTtBQUN4RTtBQXpCQSxJQUlNQTtBQUpOLElBQUEsb0JBQUEsTUFBQTtFQUFBLG9DQUFBO0FBQUE7QUFDQSx1QkFBQTtBQUNBLGVBQUE7QUFFTUEsZUFBNkM7TUFDaEQsSUFBSTtRQUNEO1FBQ0EsQ0FBQyxRQUFRLENBQUMsU0FBUyxNQUFNLFFBQVEsS0FBSyxNQUFNO0FBQ3pDLGlCQUFPLEtBQUssYUFBYSxPQUFPLEdBQUcsTUFBTSxNQUFNLFFBQVEsS0FBSztRQUMvRDtNQUNIO01BQ0EsSUFBSTtRQUNELElBQUEsT0FBQyw2Q0FBc0MsR0FBQztRQUN4QyxDQUFDLFFBQVEsQ0FBQyxTQUFTLE1BQU0sUUFBUSxLQUFLLE1BQU07QUFDekMsaUJBQU8sS0FBSyxhQUFhLE9BQU8sR0FBRyxPQUFPLE1BQU0sUUFBUSxLQUFLO1FBQ2hFO01BQ0g7SUFDSDtFQUFBO0FBQUEsQ0FBQTtBQ2pCQSxJQUFBLGlCQUFBLENBQUE7QUFBQUMsVUFBQSxnQkFBQTtFQUFBLGlCQUFBLE1BQUE7RUFBQSxZQUFBLE1BQUE7RUFBQSw2QkFBQSxNQUFBO0VBQUEsa0JBQUEsTUFBQTtFQUFBLG9CQUFBLE1BQUE7QUFBQSxDQUFBO0FBT08sU0FBUyw0QkFBNEIsVUFBb0I7QUFDN0QsUUFBTSxpQkFBaUIsQ0FBQyxNQUFNLE1BQU0sVUFBVTtBQUM5QyxTQUFPLFNBQVMsS0FBSyxDQUFDLFlBQVksZUFBZSxTQUFTLE9BQU8sQ0FBQztBQUNyRTtBQUVPLFNBQVMsV0FDYixZQUNxRDtBQUNyRCxRQUFNLFdBQVcsNEJBQTRCLFVBQVU7QUFDdkQsUUFBTSxXQUFXLENBQUMsVUFBVSxHQUFHLFVBQVU7QUFFekMsTUFBSSxTQUFTLFdBQVcsR0FBRztBQUN4QixhQUFTLEtBQUssSUFBSTtFQUNyQjtBQUVBLE1BQUksQ0FBQyxTQUFTLFNBQVMsSUFBSSxHQUFHO0FBQzNCLGFBQVMsT0FBTyxHQUFHLEdBQUcsSUFBSTtFQUM3QjtBQUVBLFNBQU87SUFDSixRQUFRO0lBQ1I7SUFDQSxPQUFPLFFBQVEsUUFBUTtBQUNwQixVQUFJLFVBQVU7QUFDWCxlQUFPLHFCQUFxQixRQUFRLE1BQU0sRUFBRSxJQUFJLENBQUE7TUFDbkQ7QUFFQSxhQUFPLG1CQUFtQixNQUFNO0lBQ25DO0VBQ0g7QUFDSDtBQUVPLFNBQVMsa0JBQTZDO0FBQzFELFFBQU1GLFVBQVM7QUFFZixTQUFPO0lBQ0osUUFBUTtJQUNSLFVBQVUsQ0FBQyxVQUFVLElBQUk7SUFDekIsUUFBQUE7RUFDSDtBQUNIO0FBRU8sU0FBUyxtQkFDYixVQUNBLGNBQWMsT0FDc0I7QUFDcEMsU0FBTztJQUNKLFFBQVE7SUFDUixVQUFVLENBQUMsVUFBVSxNQUFNLGNBQWMsT0FBTyxNQUFNLEdBQUcsUUFBUTtJQUNqRSxPQUFPLFFBQVEsUUFBUTtBQUNwQixhQUFPLHFCQUFxQixRQUFRLE1BQU07SUFDN0M7SUFDQSxRQUFRLEVBQUUsVUFBVSxPQUFPLEdBQUcsT0FBTyxNQUFNLE1BQU07QUFDOUMsVUFBSSxDQUFDLHVCQUF1QixPQUFPLEtBQUssR0FBRyxRQUFRLEdBQUc7QUFDbkQsZUFBTyxLQUFLLEtBQUs7TUFDcEI7QUFFQSxXQUFLLE1BQU07SUFDZDtFQUNIO0FBQ0g7QUFFTyxTQUFTLGlCQUNiLFFBQ0EsY0FBYyxPQUN1QjtBQUNyQyxRQUFNLE9BQTZDO0lBQ2hELFFBQVE7SUFDUixVQUFVLENBQUMsVUFBVSxNQUFNLGNBQWMsT0FBTyxNQUFNLE1BQU07SUFDNUQsT0FBTyxRQUFRLFFBQVE7QUFDcEIsYUFBTyxxQkFBcUIsUUFBUSxNQUFNLEVBQUUsU0FBUyxNQUFBO0lBQ3hEO0lBQ0EsUUFBUSxFQUFFLFVBQVUsUUFBUSxPQUFPLEdBQUcsT0FBTyxHQUFHLE1BQU07QUFDbkQsVUFBSSxDQUFDLHVCQUF1QixPQUFPLEtBQUssR0FBRyxRQUFRLEdBQUc7QUFDbkQsZUFBTyxLQUFLLEtBQUs7TUFDcEI7QUFFQSxZQUFNLElBQUk7UUFDUCxLQUFLLE9BQU8sZUFBZSxNQUFNLEdBQUcsZUFBZSxNQUFNLENBQUM7UUFDMUQsT0FBTyxLQUFLO01BQ2Y7SUFDSDtFQUNIO0FBRUEsU0FBTztBQUNWO0FBNUZBLElBQUEsY0FBQSxNQUFBO0VBQUEsNEJBQUE7QUFBQTtBQUVBLDRCQUFBO0FBQ0EsNkJBQUE7QUFDQSxzQkFBQTtBQUNBLGVBQUE7RUFBQTtBQUFBLENBQUE7QUNMQSxJQUdhO0FBSGIsSUFBQSxtQkFBQSxNQUFBO0VBQUEscUNBQUE7QUFBQTtBQUdhLHVCQUFtQixDQUFDLFNBQTJCO0FBQ3pELGFBQU8sS0FDSCxNQUFNLEtBQUssRUFDWCxJQUFJLENBQUMsU0FBUyxLQUFLLEtBQUssQ0FBQyxFQUN6QixPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsSUFBSTtJQUM5QjtFQUFBO0FBQUEsQ0FBQTtBQ1JBLElBQUEsdUJBQUEsQ0FBQTtBQUFBRSxVQUFBLHNCQUFBO0VBQUEsaUJBQUEsTUFBQTtBQUFBLENBQUE7QUFHTyxTQUFTLGdCQUFnQixPQUF1QztBQUNwRSxTQUFPO0lBQ0osVUFBVSxDQUFDLGdCQUFnQixHQUFHLEtBQUs7SUFDbkMsUUFBUTtJQUNSLFFBQVE7RUFDWDtBQUNIO0FBVEEsSUFBQSxvQkFBQSxNQUFBO0VBQUEsa0NBQUE7QUFBQTtBQUNBLHFCQUFBO0VBQUE7QUFBQSxDQUFBO0FDREEsSUFBQSxnQkFBQSxDQUFBO0FBQUFBLFVBQUEsZUFBQTtFQUFBLGlCQUFBLE1BQUE7RUFBQSxXQUFBLE1BQUE7QUFBQSxDQUFBO0FBK0JBLFNBQVMsa0JBQWtCLFNBQWlCO0FBQ3pDLFNBQU8sc0JBQXNCLEtBQUssT0FBTztBQUM1QztBQUVPLFNBQVMsVUFDYixNQUNBLFdBQ0EsWUFDK0I7QUFDL0IsUUFBTSxXQUFXLENBQUMsU0FBUyxHQUFHLFVBQVU7QUFFeEMsZUFBYSxJQUFJLEtBQUssU0FBUyxLQUFLLElBQUk7QUFDeEMsZUFBYSxTQUFTLEtBQUssU0FBUyxLQUFLLFNBQVM7QUFFbEQsUUFBTSxTQUFTLFNBQVMsS0FBSyxpQkFBaUI7QUFDOUMsTUFBSSxRQUFRO0FBQ1QsV0FBTyx1QkFBdUIsZ0RBQWdEO0VBQ2pGO0FBRUEsU0FBTywwQkFBMEIsUUFBUTtBQUM1QztBQUVPLFNBQVMsZ0JBQ2IsTUFDQSxXQUNBLFlBQ0Q7QUFDQyxTQUFPLFlBQVksVUFBVTtBQUU3QixTQUFPLFVBQVUsTUFBTSxXQUFXLFVBQVU7QUFDL0M7QUE3REEsSUFBQSxhQUFBLE1BQUE7RUFBQSwyQkFBQTtBQUFBO0FBQUEsY0FBQTtBQUVBLGVBQUE7RUFBQTtBQUFBLENBQUE7QUNtQ08sU0FBUyxpQkFBaUIsUUFBZ0IsUUFBNkI7QUFDM0UsUUFBTSxTQUFzQjtJQUN6QixLQUFLO0lBQ0wsUUFBUTtJQUNSLFVBQVUsQ0FBQztJQUNYLE1BQU0sQ0FBQztJQUNQLFNBQVMsQ0FBQztJQUNWLFNBQVMsQ0FBQztFQUNiO0FBQ0EsU0FBTyxvQkFBb0IsUUFBUUQsV0FBUyxDQUFDLFFBQVEsTUFBTSxDQUFDO0FBQy9EO0FBL0NBLElBR01BO0FBSE4sSUFBQSxtQkFBQSxNQUFBO0VBQUEsbUNBQUE7QUFBQTtBQUNBLGVBQUE7QUFFTUEsZ0JBQXFDO01BQ3hDLElBQUksV0FBVyxjQUFjLENBQUMsUUFBUSxDQUFDLE1BQU0sTUFBTTtBQUNoRCxlQUFPLFNBQVM7TUFDbkIsQ0FBQztNQUNELElBQUksV0FBVyx1Q0FBdUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxRQUFRLE1BQU07QUFDakYsZUFBTyxTQUFTLEtBQUs7VUFDbEI7VUFDQTtRQUNILENBQUM7TUFDSixDQUFDO01BQ0QsSUFBSSxXQUFXLG9DQUFvQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLFFBQVEsTUFBTTtBQUM5RSxlQUFPLEtBQUssS0FBSztVQUNkO1VBQ0E7UUFDSCxDQUFDO01BQ0osQ0FBQztNQUNELElBQUksV0FBVyxpQ0FBaUMsQ0FBQyxRQUFRLENBQUMsUUFBUSxNQUFNO0FBQ3JFLGVBQU8sUUFBUSxLQUFLO1VBQ2pCO1FBQ0gsQ0FBQztNQUNKLENBQUM7TUFDRCxJQUFJO1FBQ0Q7UUFDQSxDQUFDLFFBQVEsQ0FBQyxNQUFNLElBQUksTUFBTSxRQUFRLE1BQU07QUFDckMsaUJBQU8sUUFBUSxLQUFLO1lBQ2pCO1lBQ0E7WUFDQTtZQUNBO1VBQ0gsQ0FBQztRQUNKO01BQ0g7SUFDSDtFQUFBO0FBQUEsQ0FBQTtBQ25DQSxJQUFBLGdCQUFBLENBQUE7QUFBQUMsVUFBQSxlQUFBO0VBQUEsV0FBQSxNQUFBO0FBQUEsQ0FBQTtBQU1BLFNBQVNVLG1CQUFrQixTQUFpQjtBQUN6QyxTQUFPLHNCQUFzQixLQUFLLE9BQU87QUFDNUM7QUFFTyxTQUFTLFVBQ2IsUUFDQSxRQUNBLFlBQ29DO0FBQ3BDLFFBQU0sV0FBVyxDQUFDLFNBQVMsR0FBRyxVQUFVO0FBQ3hDLE1BQUksVUFBVSxRQUFRO0FBQ25CLGFBQVMsS0FBSyxRQUFRLE1BQU07RUFDL0I7QUFFQSxRQUFNLFNBQVMsU0FBUyxLQUFLQSxrQkFBaUI7QUFDOUMsTUFBSSxRQUFRO0FBQ1QsV0FBTyx1QkFBdUIsZ0RBQWdEO0VBQ2pGO0FBRUEsU0FBTztJQUNKO0lBQ0EsUUFBUTtJQUNSLFFBQVE7RUFDWDtBQUNIO0FBOUJBLElBQUEsYUFBQSxNQUFBO0VBQUEsMkJBQUE7QUFBQTtBQUNBLHFCQUFBO0FBR0EsY0FBQTtFQUFBO0FBQUEsQ0FBQTtBQ0tPLFNBQVMsZ0JBQWdCLFFBQTRCO0FBQ3pELFNBQU8sb0JBQW9CLEVBQUUsT0FBTyxDQUFDLEVBQUUsR0FBR1gsV0FBUyxNQUFNO0FBQzVEO0FBWEEsSUFHTUE7QUFITixJQUFBLGtCQUFBLE1BQUE7RUFBQSxrQ0FBQTtBQUFBO0FBQ0EsZUFBQTtBQUVNQSxnQkFBb0M7TUFDdkMsSUFBSSxXQUFXLDJCQUEyQixDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsTUFBTTtBQUMvRCxlQUFPLE1BQU0sS0FBSyxFQUFFLE1BQU0sR0FBRyxDQUFDO01BQ2pDLENBQUM7SUFDSjtFQUFBO0FBQUEsQ0FBQTtBQ1BBLElBQUEsZUFBQSxDQUFBO0FBQUFDLFVBQUEsY0FBQTtFQUFBLFVBQUEsTUFBQTtBQUFBLENBQUE7QUFLTyxTQUFTLFNBQVMsTUFBeUIsSUFBb0M7QUFDbkYsU0FBTztJQUNKLFVBQVUsQ0FBQyxNQUFNLE1BQU0sR0FBRyxRQUFRLElBQUksR0FBRyxFQUFFO0lBQzNDLFFBQVE7SUFDUixRQUFRO0VBQ1g7QUFDSDtBQVhBLElBQUEsWUFBQSxNQUFBO0VBQUEsMEJBQUE7QUFBQTtBQUNBLG9CQUFBO0FBRUEsZUFBQTtFQUFBO0FBQUEsQ0FBQTtBQ0hBLElBQUEsZUFBQSxDQUFBO0FBQUFBLFVBQUEsY0FBQTtFQUFBLFVBQUEsTUFBQTtBQUFBLENBQUE7QUFNTyxTQUFTLFNBQ2IsUUFDQSxRQUNBLFlBQ3VCO0FBQ3ZCLFFBQU0sV0FBcUIsQ0FBQyxRQUFRLEdBQUcsVUFBVTtBQUNqRCxNQUFJLFVBQVUsUUFBUTtBQUNuQixhQUFTLE9BQU8sR0FBRyxHQUFHLFFBQVEsTUFBTTtFQUN2QztBQUVBLFNBQU87SUFDSjtJQUNBLFFBQVE7SUFDUixPQUFPLFFBQVEsUUFBb0I7QUFDaEMsYUFBTyxnQkFBZ0IsUUFBUSxNQUFNO0lBQ3hDO0lBQ0EsUUFBUSxRQUFRLFFBQVEsT0FBTyxNQUFNO0FBQ2xDLFlBQU0sWUFBWTtRQUNmLGVBQWUsT0FBTyxNQUFNO1FBQzVCLGVBQWUsT0FBTyxNQUFNO01BQy9CO0FBQ0EsVUFBSSxXQUFXO0FBQ1osZUFBTyxLQUFLLElBQUksaUJBQWlCLFNBQVMsQ0FBQztNQUM5QztBQUVBLFdBQUssTUFBTTtJQUNkO0VBQ0g7QUFDSDtBQWxDQSxJQUFBLFlBQUEsTUFBQTtFQUFBLDBCQUFBO0FBQUE7QUFDQSw0QkFBQTtBQUNBLG9CQUFBO0FBRUEsZUFBQTtFQUFBO0FBQUEsQ0FBQTtBQ1NPLFNBQVMsZ0JBQWdCLE1BQW1DO0FBQ2hFLFFBQU0sVUFBaUQsQ0FBQztBQUV4RCxVQUFRLE1BQU0sQ0FBQyxDQUFDLElBQUksTUFBTyxRQUFRLElBQUEsSUFBUSxFQUFFLEtBQUssQ0FBRTtBQUVwRCxTQUFPLE9BQU8sT0FBTyxPQUFPO0FBQy9CO0FBRU8sU0FBUyx1QkFBdUIsTUFBZ0M7QUFDcEUsUUFBTSxVQUE4QyxDQUFDO0FBRXJELFVBQVEsTUFBTSxDQUFDLENBQUMsTUFBTSxLQUFLLE9BQU8sTUFBTTtBQUNyQyxRQUFJLENBQUMsUUFBUSxlQUFlLElBQUksR0FBRztBQUNoQyxjQUFRLElBQUEsSUFBUTtRQUNiO1FBQ0EsTUFBTSxFQUFFLE9BQU8sSUFBSSxNQUFNLEdBQUc7TUFDL0I7SUFDSDtBQUVBLFFBQUksV0FBVyxLQUFLO0FBQ2pCLGNBQVEsSUFBQSxFQUFNLEtBQUssUUFBUSxRQUFRLFdBQVcsRUFBRSxDQUFBLElBQXFDO0lBQ3hGO0VBQ0gsQ0FBQztBQUVELFNBQU8sT0FBTyxPQUFPLE9BQU87QUFDL0I7QUFFQSxTQUFTLFFBQVEsTUFBYyxTQUFtQztBQUMvRCx5QkFBdUIsTUFBTSxDQUFDLFNBQVMsUUFBUSxLQUFLLE1BQU0sS0FBSyxDQUFDLENBQUM7QUFDcEU7QUExQ0EsSUFBQSx3QkFBQSxNQUFBO0VBQUEsMENBQUE7QUFBQTtBQUFBLGVBQUE7RUFBQTtBQUFBLENBQUE7QUNBQSxJQUFBLGlCQUFBLENBQUE7QUFBQUEsVUFBQSxnQkFBQTtFQUFBLGVBQUEsTUFBQTtFQUFBLGdCQUFBLE1BQUE7RUFBQSxpQkFBQSxNQUFBO0VBQUEsWUFBQSxNQUFBO0VBQUEsa0JBQUEsTUFBQTtBQUFBLENBQUE7QUFJTyxTQUFTLGNBQ2IsWUFDQSxZQUNBLFlBQ21CO0FBQ25CLFNBQU8sMEJBQTBCLENBQUMsVUFBVSxPQUFPLEdBQUcsWUFBWSxZQUFZLFVBQVUsQ0FBQztBQUM1RjtBQUVPLFNBQVMsZUFBZSxTQUFtQztBQUMvRCxRQUFNLFdBQVcsQ0FBQyxRQUFRO0FBQzFCLE1BQUksU0FBUztBQUNWLGFBQVMsS0FBSyxJQUFJO0VBQ3JCO0FBRUEsU0FBTztJQUNKO0lBQ0EsUUFBUTtJQUNSLFFBQVEsVUFBVSx5QkFBeUI7RUFDOUM7QUFDSDtBQUVPLFNBQVMsZ0JBQWdCLFlBQTBDO0FBQ3ZFLFFBQU0sV0FBVyxDQUFDLEdBQUcsVUFBVTtBQUMvQixNQUFJLFNBQVMsQ0FBQSxNQUFPLGFBQWE7QUFDOUIsYUFBUyxRQUFRLFdBQVc7RUFDL0I7QUFFQSxTQUFPLDBCQUEwQixRQUFRO0FBQzVDO0FBRU8sU0FBUyxXQUFXLFlBQTBDO0FBQ2xFLFFBQU0sV0FBVyxDQUFDLEdBQUcsVUFBVTtBQUMvQixNQUFJLFNBQVMsQ0FBQSxNQUFPLFVBQVU7QUFDM0IsYUFBUyxRQUFRLFFBQVE7RUFDNUI7QUFFQSxTQUFPLDBCQUEwQixRQUFRO0FBQzVDO0FBRU8sU0FBUyxpQkFBaUIsWUFBb0I7QUFDbEQsU0FBTywwQkFBMEIsQ0FBQyxVQUFVLFVBQVUsVUFBVSxDQUFDO0FBQ3BFO0FBN0NBLElBQUEsY0FBQSxNQUFBO0VBQUEsNEJBQUE7QUFBQTtBQUFBLDBCQUFBO0FBRUEsY0FBQTtFQUFBO0FBQUEsQ0FBQTtBQ0ZBLElBQUEscUJBQUEsQ0FBQTtBQUFBQSxVQUFBLG9CQUFBO0VBQUEsZUFBQSxNQUFBO0FBQUEsQ0FBQTtBQVFPLFNBQVMsY0FDYixNQUFrQixDQUFDLEdBQ25CLFlBQ2tDO0FBQ2xDLFFBQU0sVUFBVSxnQkFBcUIsR0FBRztBQUN4QyxRQUFNLFdBQVcsQ0FBQyxTQUFTLFFBQVEsR0FBRyxRQUFRLFVBQVUsR0FBRyxVQUFVO0FBQ3JFLFFBQU1GLFVBQVM7SUFDWixRQUFRO0lBQ1IsUUFBUTtJQUNSLHFCQUFxQixRQUFRO0VBQ2hDO0FBRUEsU0FDRyx3QkFBd0IsUUFBUSxLQUFLO0lBQ2xDO0lBQ0EsUUFBUTtJQUNSLFFBQUFBO0VBQ0g7QUFFTjtBQTNCQSxJQUFBLGtCQUFBLE1BQUE7RUFBQSxnQ0FBQTtBQUFBO0FBQ0Esb0JBQUE7QUFDQSxnQ0FBQTtBQUVBLGNBQUE7QUFDQSxhQUFBO0VBQUE7QUFBQSxDQUFBO0FDTEEsSUFBQSxxQkFBQSxDQUFBO0FBQUFFLFVBQUEsb0JBQUE7RUFBQSxrQkFBQSxNQUFBO0VBQUEsbUJBQUEsTUFBQTtFQUFBLGVBQUEsTUFBQTtFQUFBLHFCQUFBLE1BQUE7QUFBQSxDQUFBO0FBR08sU0FBUyxpQkFBaUIsTUFBYyxNQUFrQztBQUM5RSxTQUFPLGNBQWMsQ0FBQyxPQUFPLE1BQU0sSUFBSSxDQUFDO0FBQzNDO0FBRU8sU0FBUyxrQkFBa0IsWUFBMEM7QUFDekUsU0FBTyxjQUFjLENBQUMsUUFBUSxHQUFHLFVBQVUsQ0FBQztBQUMvQztBQUVPLFNBQVMsY0FBYyxZQUEwQztBQUNyRSxRQUFNLFdBQVcsQ0FBQyxHQUFHLFVBQVU7QUFDL0IsTUFBSSxTQUFTLENBQUEsTUFBTyxhQUFhO0FBQzlCLGFBQVMsUUFBUSxXQUFXO0VBQy9CO0FBRUEsU0FBTywwQkFBMEIsUUFBUTtBQUM1QztBQUVPLFNBQVMsb0JBQW9CLFlBQTBDO0FBQzNFLFNBQU8sY0FBYyxDQUFDLFVBQVUsR0FBRyxVQUFVLENBQUM7QUFDakQ7QUF0QkEsSUFBQSxrQkFBQSxNQUFBO0VBQUEsZ0NBQUE7QUFBQTtBQUNBLGNBQUE7RUFBQTtBQUFBLENBQUE7QUNxQ0EsU0FBUyxhQUFhLEdBQVcsR0FBbUI7QUFDakQsUUFBTSxTQUFTLE1BQU0sQ0FBQztBQUN0QixRQUFNLFNBQVMsTUFBTSxDQUFDO0FBRXRCLE1BQUksV0FBVyxRQUFRO0FBQ3BCLFdBQU8sU0FBUyxJQUFJO0VBQ3ZCO0FBRUEsU0FBTyxTQUFTLE9BQU8sR0FBRyxDQUFDLElBQUk7QUFDbEM7QUFFQSxTQUFTLE9BQU8sR0FBVyxHQUFXO0FBQ25DLFNBQU8sTUFBTSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUk7QUFDcEM7QUFFQSxTQUFTLFFBQVEsT0FBZTtBQUM3QixTQUFPLE1BQU0sS0FBSztBQUNyQjtBQUVBLFNBQVMsU0FBUyxPQUEyQjtBQUMxQyxNQUFJLE9BQU8sVUFBVSxVQUFVO0FBQzVCLFdBQU8sU0FBUyxNQUFNLFFBQVEsU0FBUyxFQUFFLEdBQUcsRUFBRSxLQUFLO0VBQ3REO0FBRUEsU0FBTztBQUNWO0FBL0RBLElBRWE7QUFGYixJQVNhO0FBVGIsSUFBQSxlQUFBLE1BQUE7RUFBQSxpQ0FBQTtBQUFBO0FBRWEsY0FBTixNQUFtQztNQUN2QyxZQUNtQixLQUNBLFFBQ2pCO0FBRmlCLGFBQUEsTUFBQTtBQUNBLGFBQUEsU0FBQTtNQUNoQjtJQUNOO0FBRWEsbUJBQWUsU0FBVSxNQUFjLGFBQWEsT0FBTztBQUNyRSxZQUFNLE9BQU8sS0FBSyxNQUFNLElBQUksRUFBRSxJQUFJLE9BQU8sRUFBRSxPQUFPLE9BQU87QUFFekQsVUFBSSxDQUFDLFlBQVk7QUFDZCxhQUFLLEtBQUssU0FBVSxNQUFNLE1BQU07QUFDN0IsZ0JBQU0sU0FBUyxLQUFLLE1BQU0sR0FBRztBQUM3QixnQkFBTSxTQUFTLEtBQUssTUFBTSxHQUFHO0FBRTdCLGNBQUksT0FBTyxXQUFXLEtBQUssT0FBTyxXQUFXLEdBQUc7QUFDN0MsbUJBQU8sYUFBYSxTQUFTLE9BQU8sQ0FBQSxDQUFFLEdBQUcsU0FBUyxPQUFPLENBQUEsQ0FBRSxDQUFDO1VBQy9EO0FBRUEsbUJBQVMsSUFBSSxHQUFHLElBQUksS0FBSyxJQUFJLE9BQU8sUUFBUSxPQUFPLE1BQU0sR0FBRyxJQUFJLEdBQUcsS0FBSztBQUNyRSxrQkFBTSxPQUFPLE9BQU8sU0FBUyxPQUFPLENBQUEsQ0FBRSxHQUFHLFNBQVMsT0FBTyxDQUFBLENBQUUsQ0FBQztBQUU1RCxnQkFBSSxNQUFNO0FBQ1AscUJBQU87WUFDVjtVQUNIO0FBRUEsaUJBQU87UUFDVixDQUFDO01BQ0o7QUFFQSxZQUFNLFNBQVMsYUFBYSxLQUFLLENBQUEsSUFBSyxDQUFDLEdBQUcsSUFBSSxFQUFFLFFBQVEsRUFBRSxLQUFLLENBQUMsUUFBUSxJQUFJLFFBQVEsR0FBRyxLQUFLLENBQUM7QUFFN0YsYUFBTyxJQUFJLFFBQVEsTUFBTSxNQUFNO0lBQ2xDO0VBQUE7QUFBQSxDQUFBO0FDcENBLElBQUEsY0FBQSxDQUFBO0FBQUFBLFVBQUEsYUFBQTtFQUFBLHFCQUFBLE1BQUE7RUFBQSxZQUFBLE1BQUE7RUFBQSxhQUFBLE1BQUE7QUFBQSxDQUFBO0FBT08sU0FBUyxZQUFZLGFBQXVCLENBQUMsR0FBMEI7QUFDM0UsUUFBTSxnQkFBZ0IsV0FBVyxLQUFLLENBQUMsV0FBVyxXQUFXLEtBQUssTUFBTSxDQUFDO0FBRXpFLFNBQU87SUFDSixRQUFRO0lBQ1IsVUFBVSxDQUFDLE9BQU8sTUFBTSxHQUFHLFVBQVU7SUFDckMsT0FBTyxNQUFjO0FBQ2xCLGFBQU8sYUFBYSxNQUFNLGFBQWE7SUFDMUM7RUFDSDtBQUNIO0FBS08sU0FBUyxXQUFXLE1BQTRDO0FBQ3BFLFNBQU87SUFDSixRQUFRO0lBQ1IsVUFBVSxDQUFDLE9BQU8sSUFBSTtJQUN0QixTQUFTO0FBQ04sYUFBTyxFQUFFLEtBQUs7SUFDakI7RUFDSDtBQUNIO0FBS08sU0FBUyxvQkFDYixNQUNBLFlBQzZCO0FBQzdCLFNBQU87SUFDSixRQUFRO0lBQ1IsVUFBVSxDQUFDLE9BQU8sTUFBTSxNQUFNLFlBQVksSUFBSTtJQUM5QyxTQUFTO0FBQ04sYUFBTyxFQUFFLEtBQUs7SUFDakI7RUFDSDtBQUNIO0FBOUNBLElBQUEsV0FBQSxNQUFBO0VBQUEseUJBQUE7QUFBQTtBQUNBLGlCQUFBO0VBQUE7QUFBQSxDQUFBO0FDREEsSUFBQSxjQUFBVyxZQUFBO0VBQUEsYUFBQSxTQUFBQyxTQUFBO0FBQUE7QUFBQSxRQUFNLEVBQUUsYUFBQUMsYUFBWSxLQUFJLGtCQUFBLEdBQUFDLGNBQUEsb0JBQUE7QUFDeEIsUUFBTSxFQUFFLGNBQUFDLGNBQWEsS0FBSSxvQkFBQSxHQUFBRCxjQUFBLHNCQUFBO0FBRXpCLFFBQU0sRUFBRSxXQUFBRSxXQUFVLEtBQUksZUFBQSxHQUFBRixjQUFBLGlCQUFBO0FBQ3RCLFFBQU0sRUFBRSx3QkFBQUcsd0JBQXVCLEtBQUksVUFBQSxHQUFBSCxjQUFBLFlBQUE7QUFDbkMsUUFBTTtNQUNILFNBQUFJO01BQ0EsYUFBQUM7TUFDQSxrQkFBQUM7TUFDQSxjQUFBQztNQUNBLDJCQUFBQztNQUNBLFlBQUFDO01BQ0Esb0JBQUFDO01BQ0EsMEJBQUFDO01BQ0EseUJBQUFDO0lBQ0gsS0FBSSxXQUFBLEdBQUFaLGNBQUEsYUFBQTtBQUNKLFFBQU0sRUFBRSxnQkFBQWEsZ0JBQWUsS0FBSSxpQkFBQSxHQUFBYixjQUFBLG1CQUFBO0FBQzNCLFFBQU07TUFDSCxZQUFBYztNQUNBLGlCQUFBQztNQUNBLG9CQUFBQztNQUNBLGtCQUFBQztJQUNILEtBQUksWUFBQSxHQUFBakIsY0FBQSxjQUFBO0FBQ0osUUFBTSxFQUFFLGlCQUFBa0IsaUJBQWdCLEtBQUksa0JBQUEsR0FBQWxCLGNBQUEsb0JBQUE7QUFDNUIsUUFBTSxFQUFFLGlCQUFBbUIsaUJBQWdCLEtBQUksbUJBQUEsR0FBQW5CLGNBQUEscUJBQUE7QUFDNUIsUUFBTSxFQUFFLFdBQUFvQixZQUFXLGlCQUFBQyxpQkFBZ0IsS0FBSSxXQUFBLEdBQUFyQixjQUFBLGFBQUE7QUFDdkMsUUFBTSxFQUFFLHNCQUFBc0IsdUJBQXNCLHFCQUFBQyxxQkFBb0IsS0FBSSxXQUFBLEdBQUF2QixjQUFBLGFBQUE7QUFDdEQsUUFBTSxFQUFFLGlCQUFBd0IsaUJBQWdCLEtBQUksVUFBQSxHQUFBeEIsY0FBQSxZQUFBO0FBQzVCLFFBQU0sRUFBRSxXQUFBeUIsV0FBVSxLQUFJLFdBQUEsR0FBQXpCLGNBQUEsYUFBQTtBQUN0QixRQUFNLEVBQUUsVUFBQTBCLFVBQVMsS0FBSSxVQUFBLEdBQUExQixjQUFBLFlBQUE7QUFDckIsUUFBTSxFQUFFLFVBQUEyQixVQUFTLEtBQUksVUFBQSxHQUFBM0IsY0FBQSxZQUFBO0FBQ3JCLFFBQU0sRUFBRSxjQUFBNEIsY0FBYSxLQUFJLFVBQUEsR0FBQTVCLGNBQUEsWUFBQTtBQUN6QixRQUFNO01BQ0gsZUFBQTZCO01BQ0EsZ0JBQUFDO01BQ0EsaUJBQUFDO01BQ0EsWUFBQUM7TUFDQSxrQkFBQUM7SUFDSCxLQUFJLFlBQUEsR0FBQWpDLGNBQUEsY0FBQTtBQUNKLFFBQU0sRUFBRSxjQUFBa0MsZUFBYyxXQUFBQyxXQUFVLEtBQUksV0FBQSxHQUFBbkMsY0FBQSxhQUFBO0FBQ3BDLFFBQU0sRUFBRSxlQUFBb0MsZUFBYyxLQUFJLGdCQUFBLEdBQUFwQyxjQUFBLGtCQUFBO0FBQzFCLFFBQU07TUFDSCxrQkFBQXFDO01BQ0EsbUJBQUFDO01BQ0EsZUFBQUM7TUFDQSxxQkFBQUM7SUFDSCxLQUFJLGdCQUFBLEdBQUF4QyxjQUFBLGtCQUFBO0FBQ0osUUFBTSxFQUFFLHFCQUFBeUMsc0JBQXFCLFlBQUFDLGFBQVksYUFBQUMsYUFBWSxLQUFJLFNBQUEsR0FBQTNDLGNBQUEsV0FBQTtBQUN6RCxRQUFNLEVBQUUsMkJBQUE0Qyw0QkFBMkIsMkJBQUFDLDJCQUEwQixLQUFJLFVBQUEsR0FBQTdDLGNBQUEsWUFBQTtBQUVqRSxhQUFTOEMsS0FBSSxTQUFTLFNBQVM7QUFDNUIsV0FBSyxXQUFXO0FBQ2hCLFdBQUssWUFBWSxJQUFJL0M7UUFDbEIsUUFBUTtRQUNSLElBQUlHLFdBQVUsUUFBUSxzQkFBc0I7UUFDNUM7TUFDSDtBQUVBLFdBQUssV0FBVyxRQUFRO0lBQzNCO0FBRUEsS0FBQzRDLEtBQUksWUFBWSxPQUFPLE9BQU83QyxjQUFhLFNBQVMsR0FBRyxjQUFjNkM7QUFNdEVBLFNBQUksVUFBVSxlQUFlLFNBQVUsU0FBUztBQUM3QyxXQUFLLFNBQVMsWUFBWSxVQUFVLE9BQU87QUFDM0MsYUFBTztJQUNWO0FBVUFBLFNBQUksVUFBVSxNQUFNLFNBQVUsTUFBTSxPQUFPO0FBQ3hDLFVBQUksVUFBVSxXQUFXLEtBQUssT0FBTyxTQUFTLFVBQVU7QUFDckQsYUFBSyxVQUFVLE1BQU07TUFDeEIsT0FBTztBQUNKLFNBQUMsS0FBSyxVQUFVLE1BQU0sS0FBSyxVQUFVLE9BQU8sQ0FBQyxHQUFHLElBQUEsSUFBUTtNQUMzRDtBQUVBLGFBQU87SUFDVjtBQUtBQSxTQUFJLFVBQVUsWUFBWSxTQUFVLFNBQVM7QUFDMUMsYUFBTyxLQUFLO1FBQ1RWO1VBQ0d4Qix5QkFBd0IsU0FBUyxLQUFLLENBQUM7VUFDdENQLGFBQVksT0FBTyxLQUFLLFdBQVksQ0FBQztRQUN6QztRQUNBTSwwQkFBeUIsU0FBUztNQUNyQztJQUNIO0FBRUEsYUFBUyxnQkFBZ0IsS0FBSyxNQUFNLFVBQVUsV0FBVztBQUN0RCxVQUFJLE9BQU8sYUFBYSxVQUFVO0FBQy9CLGVBQU9SLHdCQUF1QixPQUFPLG9DQUFvQztNQUM1RTtBQUVBLGFBQU8sS0FBSyxVQUFVTSxZQUFXLFdBQVdGLGFBQVksR0FBR0csb0JBQW1CLFNBQVMsQ0FBQztJQUMzRjtBQUtBb0MsU0FBSSxVQUFVLFFBQVEsV0FBWTtBQUMvQixhQUFPLEtBQUs7UUFDVCxnQkFBZ0IsU0FBUzFCLFlBQVcsR0FBRyxTQUFTO1FBQ2hEVCwwQkFBeUIsU0FBUztNQUNyQztJQUNIO0FBS0FtQyxTQUFJLFVBQVUsU0FBUyxXQUFZO0FBQ2hDLGFBQU8sS0FBSztRQUNULGdCQUFnQixVQUFVekIsa0JBQWlCLEdBQUcsU0FBUztRQUN2RFYsMEJBQXlCLFNBQVM7TUFDckM7SUFDSDtBQVVBbUMsU0FBSSxVQUFVLEtBQUssU0FBVSxNQUFNLElBQUk7QUFDcEMsYUFBTyxLQUFLLFNBQVNwQixVQUFTLE1BQU0sRUFBRSxHQUFHZiwwQkFBeUIsU0FBUyxDQUFDO0lBQy9FO0FBT0FtQyxTQUFJLFVBQVUsb0JBQW9CLFNBQVUsTUFBTTtBQUMvQyxVQUFJLE1BQU07QUFDVixhQUFPLEtBQUssS0FBSyxXQUFZO0FBQzFCLFlBQUksS0FBSyxTQUFVLEtBQUssTUFBTTtBQUMzQixjQUFJLFNBQVMsS0FBSyxRQUFRLElBQUk7UUFDakMsQ0FBQztNQUNKLENBQUM7SUFDSjtBQUtBQSxTQUFJLFVBQVUsT0FBTyxTQUFVLFFBQVEsUUFBUSxTQUFTLE1BQU07QUFDM0QsYUFBTyxLQUFLO1FBQ1RuQjtVQUNHbEIsWUFBVyxRQUFRRixhQUFZO1VBQy9CRSxZQUFXLFFBQVFGLGFBQVk7VUFDL0JHLG9CQUFtQixTQUFTO1FBQy9CO1FBQ0FDLDBCQUF5QixTQUFTO01BQ3JDO0lBQ0g7QUFZQW1DLFNBQUksVUFBVSxRQUFRLFNBQVUsUUFBUSxRQUFRO0FBQzdDLGFBQU8sS0FBSztRQUNUckI7VUFDR2hCLFlBQVcsUUFBUUYsYUFBWTtVQUMvQkUsWUFBVyxRQUFRRixhQUFZO1VBQy9CRyxvQkFBbUIsU0FBUztRQUMvQjtRQUNBQywwQkFBeUIsU0FBUztNQUNyQztJQUNIO0FBU0FtQyxTQUFJLFVBQVUsU0FBUyxTQUFVLFNBQVM7QUFDdkMsY0FBUTtRQUNMO01BQ0g7QUFDQSxhQUFPO0lBQ1Y7QUFXQUEsU0FBSSxVQUFVLE9BQU8sU0FBVSxTQUFTLE1BQU07QUFDM0MsYUFBTyxLQUFLO1FBQ1RILGFBQVlqQyxvQkFBbUIsU0FBUyxDQUFDO1FBQ3pDQywwQkFBeUIsU0FBUztNQUNyQztJQUNIO0FBTUFtQyxTQUFJLFVBQVUsU0FBUyxXQUFZO0FBQ2hDLGFBQU8sS0FBSztRQUNURCwyQkFBMEIsQ0FBQyxVQUFVLEdBQUduQyxvQkFBbUIsU0FBUyxDQUFDLENBQUM7UUFDdEVDLDBCQUF5QixTQUFTO01BQ3JDO0lBQ0g7QUFLQW1DLFNBQUksVUFBVSxRQUFRLFNBQVUsTUFBTTtBQUNuQyxhQUFPLEtBQUs7UUFDVFgsV0FBVUQsY0FBYSxJQUFJLEdBQUd4QixvQkFBbUIsU0FBUyxDQUFDO1FBQzNEQywwQkFBeUIsU0FBUztNQUNyQztJQUNIO0FBS0FtQyxTQUFJLFVBQVUsU0FBUyxTQUFVLFFBQVE7QUFDdEMsWUFBTSxPQUFPbkMsMEJBQXlCLFNBQVM7QUFFL0MsVUFBSSxPQUFPLFdBQVcsVUFBVTtBQUM3QixlQUFPLEtBQUssU0FBU1Isd0JBQXVCLHlCQUF5QixHQUFHLElBQUk7TUFDL0U7QUFFQSxhQUFPLEtBQUs7UUFDVDBDLDJCQUEwQixDQUFDLFVBQVUsR0FBR25DLG9CQUFtQixXQUFXLEdBQUcsSUFBSSxHQUFHLE1BQU0sQ0FBQztRQUN2RjtNQUNIO0lBQ0g7QUFLQW9DLFNBQUksVUFBVSxTQUFTLFNBQVUsTUFBTTtBQUNwQyxZQUFNLE9BQ0gsT0FBTyxTQUFTLFdBQ1hKLFlBQVcsSUFBSSxJQUNmdkMsd0JBQXVCLGdDQUFnQztBQUUvRCxhQUFPLEtBQUssU0FBUyxNQUFNUSwwQkFBeUIsU0FBUyxDQUFDO0lBQ2pFO0FBS0FtQyxTQUFJLFVBQVUsa0JBQWtCLFNBQVUsU0FBUyxZQUFZO0FBQzVELGFBQU8sS0FBSztRQUNUTCxxQkFBb0IsU0FBUyxVQUFVO1FBQ3ZDOUIsMEJBQXlCLFNBQVM7TUFDckM7SUFDSDtBQUtBbUMsU0FBSSxVQUFVLG9CQUFvQixTQUFVLFlBQVksYUFBYSxNQUFNO0FBQ3hFLGFBQU8sS0FBSztRQUNUN0Isa0JBQWlCLFlBQVksT0FBTyxnQkFBZ0IsWUFBWSxjQUFjLEtBQUs7UUFDbkZOLDBCQUF5QixTQUFTO01BQ3JDO0lBQ0g7QUFLQW1DLFNBQUksVUFBVSxzQkFBc0IsU0FBVSxhQUFhLGFBQWEsTUFBTTtBQUMzRSxhQUFPLEtBQUs7UUFDVDlCLG9CQUFtQixhQUFhLE9BQU8sZ0JBQWdCLFlBQVksY0FBYyxLQUFLO1FBQ3RGTCwwQkFBeUIsU0FBUztNQUNyQztJQUNIO0FBUUFtQyxTQUFJLFVBQVUsU0FBUyxTQUFVLFNBQVMsTUFBTTtBQUM3QyxhQUFPLEtBQUs7UUFDVGhDLFlBQVdKLG9CQUFtQixTQUFTLENBQUM7UUFDeENDLDBCQUF5QixTQUFTO01BQ3JDO0lBQ0g7QUFPQW1DLFNBQUksVUFBVSxjQUFjLFNBQVUsTUFBTTtBQUN6QyxhQUFPLEtBQUssU0FBUy9CLGlCQUFnQixHQUFHSiwwQkFBeUIsU0FBUyxDQUFDO0lBQzlFO0FBS0FtQyxTQUFJLFVBQVUsTUFBTSxTQUFVLFVBQVU7QUFDckMsWUFBTSxxQkFBcUIsQ0FBQyxNQUFNLFFBQVEsUUFBUTtBQUNsRCxZQUFNLFVBQVUsQ0FBQyxFQUFFLE1BQU0sS0FBSyxxQkFBcUIsWUFBWSxVQUFVLENBQUM7QUFFMUUsZUFBUyxJQUFJLEdBQUcsSUFBSSxRQUFRLFVBQVUsb0JBQW9CLEtBQUs7QUFDNUQsWUFBSSxDQUFDeEMsa0JBQWlCLFFBQVEsQ0FBQSxDQUFFLEdBQUc7QUFDaEMsa0JBQVEsT0FBTyxHQUFHLFFBQVEsU0FBUyxDQUFDO0FBQ3BDO1FBQ0g7TUFDSDtBQUVBLGNBQVEsS0FBSyxHQUFHSSxvQkFBbUIsV0FBVyxHQUFHLElBQUksQ0FBQztBQUV0RCxVQUFJLE9BQU9DLDBCQUF5QixTQUFTO0FBRTdDLFVBQUksQ0FBQyxRQUFRLFFBQVE7QUFDbEIsZUFBTyxLQUFLO1VBQ1RSLHdCQUF1QixpREFBaUQ7VUFDeEU7UUFDSDtNQUNIO0FBRUEsYUFBTyxLQUFLLFNBQVMwQywyQkFBMEIsU0FBUyxLQUFLLFFBQVEsR0FBRyxJQUFJO0lBQy9FO0FBRUFDLFNBQUksVUFBVSxlQUFlLFNBQVUsTUFBTSxNQUFNLE1BQU07QUFDdEQsYUFBTyxLQUFLLFNBQVNULGtCQUFpQixNQUFNLElBQUksR0FBRzFCLDBCQUF5QixTQUFTLENBQUM7SUFDekY7QUFFQW1DLFNBQUksVUFBVSxrQkFBa0IsU0FBVSxNQUFNLE1BQU07QUFDbkQsYUFBTyxLQUFLO1FBQ1ROLHFCQUFvQjlCLG9CQUFtQixXQUFXLElBQUksQ0FBQztRQUN2REMsMEJBQXlCLFNBQVM7TUFDckM7SUFDSDtBQUVBbUMsU0FBSSxVQUFVLGdCQUFnQixTQUFVLE1BQU0sTUFBTTtBQUNqRCxhQUFPLEtBQUs7UUFDVFIsbUJBQWtCNUIsb0JBQW1CLFdBQVcsSUFBSSxDQUFDO1FBQ3JEQywwQkFBeUIsU0FBUztNQUNyQztJQUNIO0FBRUFtQyxTQUFJLFVBQVUsWUFBWSxTQUFVLFNBQVMsTUFBTTtBQUNoRCxhQUFPLEtBQUs7UUFDVFAsZUFBYzdCLG9CQUFtQixTQUFTLENBQUM7UUFDM0NDLDBCQUF5QixTQUFTO01BQ3JDO0lBQ0g7QUFFQW1DLFNBQUksVUFBVSxhQUFhLFdBQVk7QUFDcEMsYUFBTyxLQUFLO1FBQ1RmLGlCQUFnQnJCLG9CQUFtQixTQUFTLENBQUM7UUFDN0NDLDBCQUF5QixTQUFTO01BQ3JDO0lBQ0g7QUFLQW1DLFNBQUksVUFBVSxZQUFZLFNBQVUsWUFBWSxZQUFZLE1BQU07QUFDL0QsYUFBTyxLQUFLO1FBQ1RqQixlQUFjLFlBQVksWUFBWW5CLG9CQUFtQixTQUFTLENBQUM7UUFDbkVDLDBCQUF5QixTQUFTO01BQ3JDO0lBQ0g7QUFLQW1DLFNBQUksVUFBVSxlQUFlLFNBQVUsWUFBWSxNQUFNO0FBQ3RELGFBQU8sS0FBSyxTQUFTYixrQkFBaUIsVUFBVSxHQUFHdEIsMEJBQXlCLFNBQVMsQ0FBQztJQUN6RjtBQU1BbUMsU0FBSSxVQUFVLGFBQWEsU0FBVSxTQUFTLE1BQU07QUFDakQsYUFBTyxLQUFLLFNBQVNoQixnQkFBZSxZQUFZLElBQUksR0FBR25CLDBCQUF5QixTQUFTLENBQUM7SUFDN0Y7QUFRQW1DLFNBQUksVUFBVSxTQUFTLFNBQVUsU0FBUyxNQUFNO0FBQzdDLGFBQU8sS0FBSztRQUNUZCxZQUFXdEIsb0JBQW1CLFNBQVMsQ0FBQztRQUN4Q0MsMEJBQXlCLFNBQVM7TUFDckM7SUFDSDtBQVFBbUMsU0FBSSxVQUFVLE1BQU0sU0FBVSxTQUFTLE1BQU07QUFDMUMsWUFBTSxVQUFVcEMsb0JBQW1CLFNBQVM7QUFFNUMsVUFBSSxRQUFRLENBQUEsTUFBTyxPQUFPO0FBQ3ZCLGdCQUFRLFFBQVEsS0FBSztNQUN4QjtBQUVBLGFBQU8sS0FBSyxTQUFTbUMsMkJBQTBCLE9BQU8sR0FBR2xDLDBCQUF5QixTQUFTLENBQUM7SUFDL0Y7QUFPQW1DLFNBQUksVUFBVSxtQkFBbUIsU0FBVSxNQUFNO0FBQzlDLGFBQU8sS0FBSztRQUNURCwyQkFBMEIsQ0FBQyxvQkFBb0IsQ0FBQztRQUNoRGxDLDBCQUF5QixTQUFTO01BQ3JDO0lBQ0g7QUFTQW1DLFNBQUksVUFBVSxXQUFXLFNBQVUsUUFBUSxNQUFNO0FBQzlDLFlBQU0sT0FBT2xCO1FBQ1YsRUFBRSxRQUFRbkIsWUFBVyxRQUFRRixhQUFZLEVBQUU7UUFDM0NHLG9CQUFtQixTQUFTO01BQy9CO0FBRUEsYUFBTyxLQUFLLFNBQVMsTUFBTUMsMEJBQXlCLFNBQVMsQ0FBQztJQUNqRTtBQUtBbUMsU0FBSSxVQUFVLEtBQUssU0FBVSxPQUFPO0FBQ2pDLGFBQU8sS0FBSztRQUNURCwyQkFBMEIsQ0FBQyxNQUFNLE1BQU0sR0FBR3pDLFNBQVEsS0FBSyxDQUFDLENBQUM7UUFDekRPLDBCQUF5QixTQUFTO01BQ3JDO0lBQ0g7QUFRQW1DLFNBQUksVUFBVSxjQUFjLFNBQVUsT0FBTztBQUMxQyxhQUFPLEtBQUs7UUFDVEQsMkJBQTBCLENBQUMsTUFBTSxZQUFZLEdBQUd6QyxTQUFRLEtBQUssQ0FBQyxDQUFDO1FBQy9ETywwQkFBeUIsU0FBUztNQUNyQztJQUNIO0FBV0FtQyxTQUFJLFVBQVUsVUFBVSxTQUFVLFNBQVMsTUFBTTtBQUM5QyxhQUFPLEtBQUssU0FBUyxTQUFTLFNBQVM7SUFDMUM7QUFFQUEsU0FBSSxVQUFVLGdCQUFnQixXQUFZO0FBQ3ZDLGFBQU8sS0FBSyxTQUFTLFVBQVUsU0FBUztJQUMzQztBQUVBQSxTQUFJLFVBQVUsV0FBVyxTQUFVLFFBQVEsTUFBTTtBQUM5QyxVQUFJLFVBQVVuQywwQkFBeUIsSUFBSTtBQUMzQyxVQUFJLFVBQVUsQ0FBQyxVQUFVO0FBQ3pCLFVBQUksVUFBVSxLQUFLLENBQUE7QUFFbkIsVUFBSSxPQUFPLFlBQVksVUFBVTtBQUM5QixlQUFPLEtBQUs7VUFDVFIsd0JBQXVCLDhEQUE4RDtVQUNyRjtRQUNIO01BQ0g7QUFFQSxVQUFJLE1BQU0sUUFBUSxPQUFPLEdBQUc7QUFDekIsZ0JBQVEsS0FBSyxNQUFNLFNBQVMsT0FBTztNQUN0QztBQUVBLFlBQU0sT0FDSCxXQUFXLFdBQVd5QywyQkFBMEIsT0FBTyxJQUFJQywyQkFBMEIsT0FBTztBQUUvRixhQUFPLEtBQUssU0FBUyxNQUFNLE9BQU87SUFDckM7QUFFQUMsU0FBSSxVQUFVLE9BQU8sU0FBVSxTQUFTLE1BQU07QUFDM0MsWUFBTSxPQUFPdkMsY0FBYSxPQUFPLElBQzVCSjtRQUNHO01BQ0gsSUFDQTBDLDJCQUEwQixDQUFDLFFBQVEsR0FBR25DLG9CQUFtQixTQUFTLENBQUMsQ0FBQztBQUV6RSxhQUFPLEtBQUssU0FBUyxNQUFNQywwQkFBeUIsU0FBUyxDQUFDO0lBQ2pFO0FBRUFtQyxTQUFJLFVBQVUsY0FBYyxXQUFZO0FBQ3JDLGFBQU8sS0FBSztRQUNUdEIsaUJBQWdCZCxvQkFBbUIsV0FBVyxDQUFDLENBQUM7UUFDaERDLDBCQUF5QixTQUFTO01BQ3JDO0lBQ0g7QUFFQW1DLFNBQUksVUFBVSxhQUFhLFNBQVUsU0FBUztBQUMzQyxZQUFNLE9BQU8sQ0FBQ3RDLDJCQUEwQixPQUFPLElBQzFDTDtRQUNHO01BQ0gsSUFDQVUsZ0JBQWVULFNBQVEsT0FBTyxHQUFHTSxvQkFBbUIsQ0FBQyxFQUFFLE1BQU0sS0FBSyxXQUFXLENBQUMsQ0FBQyxDQUFDO0FBRXJGLGFBQU8sS0FBSyxTQUFTLE1BQU1DLDBCQUF5QixTQUFTLENBQUM7SUFDakU7QUFFQW1DLFNBQUksVUFBVSxXQUFXLFdBQVk7QUFDbEMsWUFBTSxXQUFXLENBQUMsYUFBYSxHQUFHcEMsb0JBQW1CLFdBQVcsSUFBSSxDQUFDO0FBQ3JFLGFBQU8sS0FBSztRQUNUbUMsMkJBQTBCLFVBQVUsSUFBSTtRQUN4Q2xDLDBCQUF5QixTQUFTO01BQ3JDO0lBQ0g7QUFJQW1DLFNBQUksVUFBVSxRQUFRLFNBQVUsTUFBTSxTQUFTLE1BQU07QUFDbEQsWUFBTSx5QkFBeUJ2QixxQkFBb0IsSUFBSTtBQUN2RCxZQUFNLFlBQ0YsMEJBQTBCLEtBQUssS0FBSyxFQUFFLEtBQU1kLFlBQVcsTUFBTUYsYUFBWSxLQUFLO0FBQ2xGLFlBQU0sYUFBYUcsb0JBQW1CLENBQUMsRUFBRSxNQUFNLEtBQUssV0FBVyx5QkFBeUIsSUFBSSxDQUFDLENBQUM7QUFFOUYsYUFBTyxLQUFLO1FBQ1RZLHNCQUFxQixXQUFXLFVBQVU7UUFDMUNYLDBCQUF5QixTQUFTO01BQ3JDO0lBQ0g7QUFFQW1DLFNBQUksVUFBVSxPQUFPLFNBQVUsTUFBTTtBQUNsQyxZQUFNLE9BQU87UUFDVixVQUFVLENBQUM7UUFDWCxRQUFRO1FBQ1IsU0FBUztBQUNOLGNBQUksT0FBTyxTQUFTLFlBQVk7QUFDN0IsaUJBQUs7VUFDUjtRQUNIO01BQ0g7QUFFQSxhQUFPLEtBQUssU0FBUyxJQUFJO0lBQzVCO0FBT0FBLFNBQUksVUFBVSxhQUFhLFdBQVk7QUFHcEMsYUFBTztJQUNWO0FBUUFBLFNBQUksVUFBVSxjQUFjLFNBQVUsV0FBVyxNQUFNO0FBQ3BELGFBQU8sS0FBSztRQUNUNUIsaUJBQWdCZCxTQUFRSyxZQUFXLFdBQVdELDRCQUEyQixDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzdFRywwQkFBeUIsU0FBUztNQUNyQztJQUNIO0FBRUFtQyxTQUFJLFVBQVUsY0FBYyxTQUFVLFdBQVcsTUFBTTtBQUNwRCxhQUFPLEtBQUs7UUFDVDNCLGlCQUFnQlYsWUFBVyxXQUFXRixhQUFZLENBQUM7UUFDbkRJLDBCQUF5QixTQUFTO01BQ3JDO0lBQ0g7QUFFQSxJQUFBYixRQUFPLFVBQVVnRDtFQUFBO0FBQUEsQ0FBQTtBQzdtQmpCLGNBQUE7QUNBQSxlQUFBO0FBWU8sSUFBTSxvQkFBTixjQUFnQyxTQUFTO0VBQzdDLFlBQ21CLFFBQ2hCLFNBQ0Q7QUFDQyxVQUFNLFFBQVcsT0FBTztBQUhSLFNBQUEsU0FBQTtFQUluQjtBQUNIO0FEakJBLGVBQUE7QUVEQSxlQUFBO0FBRU8sSUFBTSxpQkFBTixjQUE2QixTQUFTO0VBQzFDLFlBQ1UsTUFDUyxRQUNoQixTQUNEO0FBQ0MsVUFBTSxNQUFNLE9BQU87QUFKWixTQUFBLE9BQUE7QUFDUyxTQUFBLFNBQUE7QUFJaEIsV0FBTyxlQUFlLE1BQU0sV0FBVyxTQUFTO0VBQ25EO0FBQ0g7QUZSQSx3QkFBQTtBQUNBLDhCQUFBO0FBQ0EsbUJBQUE7QUFDQSxXQUFBO0FBQ0EsWUFBQTtBQUNBLHNCQUFBO0FBQ0EsVUFBQTtBQUNBLFdBQUE7QUdQTyxTQUFTLFlBQVksUUFBbUM7QUFDNUQsTUFBSSxDQUFDLFFBQVE7QUFDVjtFQUNIO0FBRUEsUUFBTSxlQUErQztJQUNsRCxNQUFNO0lBQ04sT0FBTyxPQUFPLFNBQVM7QUFDcEIsZUFBUyxPQUFPO0FBQ2IsZ0JBQVEsS0FBSyxJQUFJLGVBQWUsUUFBVyxTQUFTLHVCQUF1QixDQUFDO01BQy9FO0FBRUEsYUFBTyxpQkFBaUIsU0FBUyxJQUFJO0FBRXJDLGNBQVEsUUFBUSxHQUFHLFNBQVMsTUFBTSxPQUFPLG9CQUFvQixTQUFTLElBQUksQ0FBQztJQUM5RTtFQUNIO0FBRUEsUUFBTSxnQkFBaUQ7SUFDcEQsTUFBTTtJQUNOLE9BQU8sT0FBTyxTQUFTO0FBQ3BCLFVBQUksT0FBTyxTQUFTO0FBQ2pCLGdCQUFRLEtBQUssSUFBSSxlQUFlLFFBQVcsU0FBUyx3QkFBd0IsQ0FBQztNQUNoRjtJQUNIO0VBQ0g7QUFFQSxTQUFPLENBQUMsZUFBZSxZQUFZO0FBQ3RDO0FDM0JBLFNBQVMsZUFBZSxLQUF1QjtBQUM1QyxTQUFPLE9BQU8sUUFBUSxZQUFZLElBQUksS0FBSyxFQUFFLFlBQVksTUFBTTtBQUNsRTtBQUVBLFNBQVMsd0JBQXdCLEtBQWEsTUFBYztBQUN6RCxNQUFJLENBQUMsZUFBZSxHQUFHLEdBQUc7QUFDdkI7RUFDSDtBQUVBLE1BQUksQ0FBQywrQkFBK0IsS0FBSyxJQUFJLEdBQUc7QUFDN0M7RUFDSDtBQUVBLFFBQU0sSUFBSTtJQUNQO0lBQ0E7SUFDQTtFQUNIO0FBQ0g7QUFFQSxTQUFTLGtCQUFrQixLQUFhLFFBQWdCO0FBQ3JELE1BQUksOEJBQThCLEtBQUssR0FBRyxHQUFHO0FBQzFDLFVBQU0sSUFBSTtNQUNQO01BQ0E7TUFDQTtJQUNIO0VBQ0g7QUFFQSxNQUFJLFdBQVcsV0FBVyxXQUFXLEtBQUssR0FBRyxHQUFHO0FBQzdDLFVBQU0sSUFBSTtNQUNQO01BQ0E7TUFDQTtJQUNIO0VBQ0g7QUFFQSxNQUFJLFdBQVcsVUFBVSxlQUFlLEtBQUssR0FBRyxHQUFHO0FBQ2hELFVBQU0sSUFBSTtNQUNQO01BQ0E7TUFDQTtJQUNIO0VBQ0g7QUFDSDtBQUVPLFNBQVMsNEJBQTRCO0VBQ3pDLDhCQUE4QjtFQUM5QixrQkFBa0I7QUFDckIsSUFBcUMsQ0FBQyxHQUFrQztBQUNyRSxTQUFPO0lBQ0osTUFBTTtJQUNOLE9BQU8sTUFBTSxTQUFTO0FBQ25CLFdBQUssUUFBUSxDQUFDLFNBQVMsVUFBVTtBQUM5QixjQUFNLE9BQU8sUUFBUSxLQUFLLFNBQVMsS0FBSyxRQUFRLENBQUEsSUFBSztBQUVyRCx1Q0FBK0Isd0JBQXdCLFNBQVMsSUFBSTtBQUNwRSwyQkFBbUIsa0JBQWtCLFNBQVMsUUFBUSxNQUFNO01BQy9ELENBQUM7QUFFRCxhQUFPO0lBQ1Y7RUFDSDtBQUNIO0FDcEVBLFdBQUE7QUFHTyxTQUFTLDZCQUNiLGVBQzhCO0FBQzlCLFFBQU0sU0FBUyxjQUFjLGVBQWUsSUFBSTtBQUVoRCxTQUFPO0lBQ0osTUFBTTtJQUNOLE9BQU8sTUFBTTtBQUNWLGFBQU8sQ0FBQyxHQUFHLFFBQVEsR0FBRyxJQUFJO0lBQzdCO0VBQ0g7QUFDSDtBQ1pBLFdBQUE7QUFHQSxJQUFNLFlBQVEsbUNBQVMsRUFBRTtBQUVsQixTQUFTLDBCQUEwQjtFQUN2QyxVQUFVO0VBQ1YsU0FBUztBQUNaLElBQXlDLENBQUMsR0FBbUM7QUFDMUUsV0FBUyxlQUFlO0FBQ3JCLFFBQUksV0FBVztBQUNmLFVBQU0sU0FBUztNQUNaLFdBQU8sbUNBQVM7TUFDaEIsa0JBQWMsbUNBQVM7TUFDdkIsVUFBTSxtQ0FBUztNQUNmLGlCQUFhLG1DQUFTO0lBQ3pCO0FBRUEsVUFBTSxTQUFTLFFBQVEsS0FBSztNQUN6QixZQUFZLFFBQVEsUUFBUSxPQUFPLGFBQWE7TUFDaEQsV0FBVyxRQUFRLFFBQVEsT0FBTyxZQUFZO0lBQ2pELENBQUM7QUFFRCxxQkFBaUIsU0FBUyxPQUFPLE9BQU8sT0FBTyxZQUFZO0FBQzNELHFCQUFpQixRQUFRLE9BQU8sTUFBTSxPQUFPLFdBQVc7QUFFeEQsV0FBTztNQUNKLE1BQU0sTUFBYztBQUNqQixtQkFBVztBQUNYLGVBQU8sTUFBTSxLQUFLO01BQ3JCO01BQ0EsS0FBSyxNQUFjO0FBQ2hCLG1CQUFXO0FBQ1gsZUFBTyxLQUFLLEtBQUs7TUFDcEI7TUFDQSxJQUFJLFdBQVc7QUFDWixlQUFPO01BQ1Y7TUFDQTtJQUNIO0VBQ0g7QUFFQSxXQUFTLGlCQUNOLE1BQ0EsT0FDQSxTQUNEO0FBQ0MsUUFBSSxTQUFTLE9BQU87QUFDakI7SUFDSDtBQUVBLEtBQUMsU0FBUyxPQUFPLE1BQU0sVUFBVSxNQUFNLFFBQVEsS0FBSyxNQUFNLE1BQU0sSUFBSSxDQUFDLEdBQUcsS0FBSyxRQUFRLElBQUk7RUFDNUY7QUFFQSxTQUFPO0lBQ0osTUFBTTtJQUNBLE9BQU8sSUFBTyxJQUFvQjtBQUFBLGFBQUEsUUFBQSxNQUFBLFdBQUEsV0FBM0IsT0FBTyxFQUFFLFNBQVMsTUFBTSxHQUFHO0FBMUQ5QyxZQUFBQyxLQUFBO0FBMkRTLGNBQU0sU0FBUyxhQUFhO0FBRTVCLFlBQUksYUFBYTtBQUNqQixZQUFJLGFBQWEsTUFBTSxNQUFNLGFBQWE7QUFFMUMsU0FBQUEsTUFBQSxRQUFRLFdBQVIsT0FBQSxTQUFBQSxJQUFnQixHQUFHLFFBQVEsVUFBQTtBQUMzQixTQUFBLEtBQUEsUUFBUSxXQUFSLE9BQUEsU0FBQSxHQUFnQixHQUFHLFFBQVEsVUFBQTtBQUMzQixnQkFBUSxHQUFHLFNBQVMsVUFBVTtBQUU5QixnQkFBUSxHQUFHLFNBQVMsQ0FBQyxTQUFpQixPQUFPLE1BQU0sSUFBSSxDQUFDO0FBQ3hELGdCQUFRLEdBQUcsUUFBUSxDQUFDLFNBQWlCLE9BQU8sS0FBSyxJQUFJLENBQUM7QUFFdEQsWUFBSTtBQUNELGdCQUFNLE9BQU87QUFDYixjQUFJLFlBQVk7QUFDYixrQkFBTSxNQUFNLEVBQUU7VUFDakI7QUFDQSxnQkFBTSxPQUFPLFFBQVE7UUFDeEIsU0FBUyxLQUFUO0FBQ0csZ0JBQU0sT0FBTyxVQUFVLEdBQVk7UUFDdEM7TUFDSCxDQUFBO0lBQUE7RUFDSDtBQUNIO0FDL0VBLFdBQUE7QUFHQSxJQUFNLG1CQUFtQjtBQUN6QixJQUFNLGtCQUFrQjtBQUV4QixTQUFTLGNBQWMsS0FBYTtBQUNqQyxTQUFPLENBQUMsT0FBTyxDQUFDLGdDQUFnQyxLQUFLLEdBQUc7QUFDM0Q7QUFFQSxTQUFTLGVBQ04sT0FDQSxhQUNvQztBQUNwQyxNQUFJLE1BQU0sU0FBUyxLQUFLLE1BQU0sU0FBUyxHQUFHO0FBQ3ZDLFVBQU0sSUFBSSxlQUFlLFFBQVcsVUFBVSxnQkFBZ0I7RUFDakU7QUFFQSxRQUFNLFFBQVEsTUFBTSxLQUFLLGFBQWE7QUFDdEMsTUFBSSxPQUFPO0FBQ1IsUUFBSSxhQUFhO0FBQ2QsY0FBUSxLQUFLLGVBQWU7SUFDL0IsT0FBTztBQUNKLFlBQU0sSUFBSSxlQUFlLFFBQVcsVUFBVSxlQUFlO0lBQ2hFO0VBQ0g7QUFFQSxRQUFNLENBQUMsUUFBUSxNQUFNLElBQUk7QUFDekIsU0FBTztJQUNKO0lBQ0E7RUFDSDtBQUNIO0FBRU8sU0FBUyxtQkFDYixTQUNBLFFBQW9DLENBQUMsS0FBSyxHQUMxQyxjQUFjLE9BQ2Y7QUFDQyxNQUFJLFNBQVMsZUFBZSxRQUFRLEtBQUssR0FBRyxXQUFXO0FBRXZELFVBQVEsR0FBRyxVQUFVLENBQUNDLFdBQVU7QUFDN0IsYUFBUyxlQUFlLFFBQVFBLE1BQUssR0FBRyxXQUFXO0VBQ3RELENBQUM7QUFFRCxVQUFRLE9BQU8sZ0JBQWdCLE1BQU07QUFDbEMsV0FBTyxPQUFPO0VBQ2pCLENBQUM7QUFFRCxVQUFRLE9BQU8sY0FBYyxDQUFDLFNBQVM7QUFDcEMsV0FBTyxPQUFPLFNBQVMsQ0FBQyxPQUFPLFFBQVEsR0FBRyxJQUFJLElBQUk7RUFDckQsQ0FBQztBQUNKO0FDdkRBLGVBQUE7QUFNQSxTQUFTLFlBQVksUUFBb0I7QUFDdEMsU0FBTyxDQUFDLEVBQUUsT0FBTyxZQUFZLE9BQU8sT0FBTztBQUM5QztBQUVBLFNBQVMsZ0JBQWdCLFFBQW9CO0FBQzFDLFNBQU8sT0FBTyxPQUFPLENBQUMsR0FBRyxPQUFPLFFBQVEsR0FBRyxPQUFPLE1BQU0sQ0FBQztBQUM1RDtBQUVPLFNBQVMsc0JBQ2IsWUFBWSxPQUNaLFVBQVUsYUFDVixlQUF1RCxpQkFDeEQ7QUFDQyxTQUFPLENBQUMsT0FBbUMsV0FBdUI7QUFDL0QsUUFBSyxDQUFDLGFBQWEsU0FBVSxDQUFDLFFBQVEsTUFBTSxHQUFHO0FBQzVDLGFBQU87SUFDVjtBQUVBLFdBQU8sYUFBYSxNQUFNO0VBQzdCO0FBQ0g7QUFFTyxTQUFTLHFCQUNiLFFBQzhCO0FBQzlCLFNBQU87SUFDSixNQUFNO0lBQ04sT0FBTyxNQUFNLFNBQVM7QUFDbkIsWUFBTSxRQUFRLE9BQU8sS0FBSyxPQUFPO1FBQzlCLFFBQVEsUUFBUTtRQUNoQixRQUFRLFFBQVE7UUFDaEIsVUFBVSxRQUFRO01BQ3JCLENBQUM7QUFFRCxVQUFJLE9BQU8sU0FBUyxLQUFLLEdBQUc7QUFDekIsZUFBTyxFQUFFLE9BQU8sSUFBSSxTQUFTLFFBQVcsTUFBTSxTQUFTLE9BQU8sQ0FBQyxFQUFFO01BQ3BFO0FBRUEsYUFBTztRQUNKO01BQ0g7SUFDSDtFQUNIO0FBQ0g7QUMxQ0EsV0FBQTtBQUdPLElBQU0sY0FBTixNQUFrQjtFQUFsQixjQUFBO0FBQ0osU0FBUSxVQUFxRCxvQkFBSSxJQUFJO0FBQ3JFLFNBQVEsU0FBUyxJQUFJLGdDQUFhO0VBQUE7RUFFbEMsR0FDRyxNQUNBLFVBQ0Q7QUFDQyxTQUFLLE9BQU8sR0FBRyxNQUFNLFFBQVE7RUFDaEM7RUFFQSxZQUFtRCxNQUFTLE1BQWdDO0FBQ3pGLFNBQUssT0FBTyxLQUFLLE1BQU0sSUFBSTtFQUM5QjtFQUVPLE9BQXNDLE1BQVMsUUFBc0M7QUFDekYsVUFBTSxTQUFTLE9BQU8sS0FBSyxTQUFTLEVBQUUsTUFBTSxPQUFPLENBQUM7QUFFcEQsV0FBTyxNQUFNLEtBQUssUUFBUSxPQUFPLE1BQU07RUFDMUM7RUFFTyxJQUNKLFFBQ0Q7QUFDQyxVQUFNLFVBQWdDLENBQUM7QUFFdkMsWUFBUSxNQUFNLEVBQUUsUUFBUSxDQUFDQyxZQUFXQSxXQUFVLEtBQUssUUFBUSxJQUFJLE9BQU8sU0FBU0EsT0FBTSxDQUFDLENBQUM7QUFFdkYsV0FBTyxNQUFNO0FBQ1YsY0FBUSxRQUFRLENBQUNBLFlBQVcsS0FBSyxRQUFRLE9BQU9BLE9BQU0sQ0FBQztJQUMxRDtFQUNIO0VBRU8sS0FDSixNQUNBLE1BQ0EsU0FDWTtBQUNaLFFBQUksU0FBUztBQUNiLFVBQU0sYUFBYSxPQUFPLE9BQU8sT0FBTyxPQUFPLE9BQU8sQ0FBQztBQUV2RCxlQUFXLFVBQVUsS0FBSyxTQUFTO0FBQ2hDLFVBQUksT0FBTyxTQUFTLE1BQU07QUFDdkIsaUJBQVMsT0FBTyxPQUFPLFFBQVEsVUFBVTtNQUM1QztJQUNIO0FBRUEsV0FBTztFQUNWO0FBQ0g7QUMxREEsV0FBQTtBQUlPLFNBQVMsc0JBQXNCLFVBQXVEO0FBQzFGLFFBQU0sa0JBQWtCO0FBQ3hCLFFBQU0sa0JBQWtCLENBQUMsWUFBWSxTQUFTLFNBQVMsUUFBUSxNQUFNO0FBRXJFLFFBQU0sYUFBNkM7SUFDaEQsTUFBTTtJQUNOLE9BQU8sT0FBTyxTQUFTO0FBWDdCLFVBQUFGO0FBWVMsVUFBSSxDQUFDLFFBQVEsU0FBUyxTQUFTLGVBQWUsR0FBRztBQUM5QztNQUNIO0FBRUEsT0FBQUEsTUFBQSxRQUFRLFFBQVEsV0FBaEIsT0FBQSxTQUFBQSxJQUF3QixHQUFHLFFBQVEsQ0FBQyxVQUFrQjtBQUNuRCxjQUFNLFVBQVUseUNBQXlDLEtBQUssTUFBTSxTQUFTLE1BQU0sQ0FBQztBQUNwRixZQUFJLENBQUMsU0FBUztBQUNYO1FBQ0g7QUFFQSxpQkFBUztVQUNOLFFBQVEsUUFBUTtVQUNoQixPQUFPLG1CQUFtQixRQUFRLENBQUEsQ0FBRTtVQUNwQyxVQUFVLFNBQVMsUUFBUSxDQUFBLENBQUU7VUFDN0IsV0FBVyxTQUFTLFFBQVEsQ0FBQSxDQUFFO1VBQzlCLE9BQU8sU0FBUyxRQUFRLENBQUEsQ0FBRTtRQUM3QixDQUFDO01BQ0osQ0FBQTtJQUNIO0VBQ0g7QUFFQSxRQUFNLFNBQXdDO0lBQzNDLE1BQU07SUFDTixPQUFPLE1BQU0sU0FBUztBQUNuQixVQUFJLENBQUMsZ0JBQWdCLFNBQVMsUUFBUSxNQUFNLEdBQUc7QUFDNUMsZUFBTztNQUNWO0FBRUEsYUFBTyxVQUFVLE1BQU0sZUFBZTtJQUN6QztFQUNIO0FBRUEsU0FBTyxDQUFDLFFBQVEsVUFBVTtBQUM3QjtBQUVBLFNBQVMsbUJBQW1CLE9BQWU7QUFDeEMsU0FBTyxPQUFPLE1BQU0sWUFBWSxFQUFFLE1BQU0sS0FBSyxDQUFDLENBQUMsS0FBSztBQUN2RDtBQ2hEQSxXQUFBO0FBR08sU0FBUyxtQkFDYixjQUNpQztBQUNqQyxRQUFNLFVBQVUsS0FBSyxjQUFjLENBQUMsT0FBTyxLQUFLLENBQUM7QUFFakQsU0FBTztJQUNKLE1BQU07SUFDTixPQUFPLE1BQU07QUFDVixhQUFPLGVBQUEsZUFBQSxDQUFBLEdBQUssT0FBQSxHQUFZLElBQUE7SUFDM0I7RUFDSDtBQUNIO0FDVk8sU0FBUyxjQUFjO0VBQzNCO0VBQ0EsU0FBUztFQUNULFNBQVM7QUFDWixHQUEyRjtBQUN4RixNQUFJLFFBQVEsR0FBRztBQUNaLFdBQU87TUFDSixNQUFNO01BQ04sT0FBTyxPQUFPLFNBQVM7QUFiaEMsWUFBQUEsS0FBQTtBQWNZLFlBQUk7QUFFSixpQkFBUyxPQUFPO0FBQ2IscUJBQVcsYUFBYSxPQUFPO0FBQy9CLG9CQUFVLFdBQVcsTUFBTSxLQUFLO1FBQ25DO0FBRUEsaUJBQVMsT0FBTztBQXJCNUIsY0FBQUEsS0FBQUc7QUFzQmUsV0FBQUgsTUFBQSxRQUFRLFFBQVEsV0FBaEIsT0FBQSxTQUFBQSxJQUF3QixJQUFJLFFBQVEsSUFBQTtBQUNwQyxXQUFBRyxNQUFBLFFBQVEsUUFBUSxXQUFoQixPQUFBLFNBQUFBLElBQXdCLElBQUksUUFBUSxJQUFBO0FBQ3BDLGtCQUFRLFFBQVEsSUFBSSxRQUFRLElBQUk7QUFDaEMsa0JBQVEsUUFBUSxJQUFJLFNBQVMsSUFBSTtBQUNqQyxxQkFBVyxhQUFhLE9BQU87UUFDbEM7QUFFQSxpQkFBUyxPQUFPO0FBQ2IsZUFBSztBQUNMLGtCQUFRLEtBQUssSUFBSSxlQUFlLFFBQVcsV0FBVyx1QkFBdUIsQ0FBQztRQUNqRjtBQUVBLG9CQUFVSCxNQUFBLFFBQVEsUUFBUSxXQUFoQixPQUFBLFNBQUFBLElBQXdCLEdBQUcsUUFBUSxJQUFBO0FBQzdDLG9CQUFVLEtBQUEsUUFBUSxRQUFRLFdBQWhCLE9BQUEsU0FBQSxHQUF3QixHQUFHLFFBQVEsSUFBQTtBQUM3QyxnQkFBUSxRQUFRLEdBQUcsUUFBUSxJQUFJO0FBQy9CLGdCQUFRLFFBQVEsR0FBRyxTQUFTLElBQUk7QUFFaEMsYUFBSztNQUNSO0lBQ0g7RUFDSDtBQUNIO0FDMUNBLGNBQUE7QUFFTyxTQUFTLG9CQUFtRDtBQUNoRSxTQUFPO0lBQ0osTUFBTTtJQUNOLE9BQU8sTUFBTTtBQUNWLFlBQU0sU0FBbUIsQ0FBQztBQUMxQixVQUFJO0FBQ0osZUFBUzFELFFBQU8sTUFBZ0I7QUFDN0IsU0FBQyxTQUFTLFVBQVUsQ0FBQyxHQUFHLEtBQUssR0FBRyxJQUFJO01BQ3ZDO0FBRUEsZUFBUyxJQUFJLEdBQUcsSUFBSSxLQUFLLFFBQVEsS0FBSztBQUNuQyxjQUFNLFFBQVEsS0FBSyxDQUFBO0FBRW5CLFlBQUksV0FBVyxLQUFLLEdBQUc7QUFDcEJBLGtCQUFPLFFBQVEsS0FBSyxDQUFDO0FBQ3JCO1FBQ0g7QUFFQSxZQUFJLFVBQVUsTUFBTTtBQUNqQkE7WUFDRyxLQUFLLE1BQU0sSUFBSSxDQUFDLEVBQUUsUUFBUSxDQUFDLFNBQVUsV0FBVyxJQUFJLEtBQUssUUFBUSxJQUFJLEtBQU0sSUFBSTtVQUNsRjtBQUNBO1FBQ0g7QUFFQSxlQUFPLEtBQUssS0FBSztNQUNwQjtBQUVBLGFBQU8sQ0FBQyxTQUFTLFNBQVMsQ0FBQyxHQUFHLFFBQVEsTUFBTSxHQUFHLE9BQU8sSUFBSSxNQUFNLENBQUM7SUFDcEU7RUFDSDtBQUNIO0FDakJBLFdBQUE7QUFHQSxJQUFNLE1BQU0sWUFBQTtBQW1CTCxTQUFTLG1CQUNiLFNBQ0EsU0FDRDtBQTFDRixNQUFBMEQ7QUEyQ0csUUFBTSxVQUFVLElBQUksWUFBWTtBQUNoQyxRQUFNLFNBQVM7SUFDWCxZQUFZLE9BQU8sWUFBWSxXQUFXLEVBQUUsUUFBUSxJQUFJLFlBQWEsQ0FBQztJQUN2RTtFQUNIO0FBRUEsTUFBSSxDQUFDLGFBQWEsT0FBTyxPQUFPLEdBQUc7QUFDaEMsVUFBTSxJQUFRO01BQ1g7TUFDQTtJQUNIO0VBQ0g7QUFFQSxNQUFJLE1BQU0sUUFBUSxPQUFPLE1BQU0sR0FBRztBQUMvQixZQUFRLElBQUksNkJBQTZCLE9BQU8sTUFBTSxDQUFDO0VBQzFEO0FBRUEsVUFBUSxJQUFJLDRCQUE0QixPQUFPLE1BQU0sQ0FBQztBQUN0RCxVQUFRLElBQUksa0JBQWtCLENBQUM7QUFDL0IsVUFBUSxJQUFJLDBCQUEwQixPQUFPLFVBQVUsQ0FBQztBQUN4RCxTQUFPLFNBQVMsUUFBUSxJQUFJLFlBQVksT0FBTyxLQUFLLENBQUM7QUFDckQsU0FBTyxZQUFZLFFBQVEsSUFBSSxzQkFBc0IsT0FBTyxRQUFRLENBQUM7QUFDckUsU0FBTyxXQUFXLFFBQVEsSUFBSSxjQUFjLE9BQU8sT0FBTyxDQUFDO0FBQzNELFNBQU8sZ0JBQWdCLFFBQVEsSUFBSSxtQkFBbUIsT0FBTyxZQUFZLENBQUM7QUFFMUUsVUFBUSxJQUFJLHFCQUFxQixzQkFBc0IsSUFBSSxDQUFDLENBQUM7QUFDN0QsU0FBTyxVQUFVLFFBQVEsSUFBSSxxQkFBcUIsT0FBTyxNQUFNLENBQUM7QUFFaEUscUJBQW1CLFNBQVMsT0FBTyxTQUFRQSxNQUFBLE9BQU8sV0FBUCxPQUFBLFNBQUFBLElBQWUsdUJBQXVCO0FBRWpGLFNBQU8sSUFBSSxJQUFJLFFBQVEsT0FBTztBQUNqQztBQ3hFQSx3QkFBQTtBQ0tBLElBQU8sY0FBUTs7O0FoR2lCZixJQUFNLG1CQUFvQztBQUFBLEVBQ3hDLGdCQUFnQjtBQUFBO0FBQUEsRUFDaEIsU0FBUztBQUFBLEVBQ1QsWUFBWTtBQUFBLEVBQ1osVUFBVTtBQUFBLEVBQ1YsVUFBVTtBQUFBLEVBQ1YsZUFBZTtBQUFBO0FBQ2pCO0FBR0EsSUFBcUIsZ0JBQXJCLGNBQTJDLHVCQUFPO0FBQUEsRUFBbEQ7QUFBQTtBQUVFLGVBQXdCO0FBR3hCO0FBQUEscUJBQXFCO0FBbU5yQjtBQUFBLDhCQUFxQixDQUFDLFNBQXdCO0FBSTVDLFVBQUksQ0FBQyxLQUFLLFdBQVc7QUFFbkIsYUFBSyxnQkFBZ0Isa0JBQWtCO0FBQUEsTUFDekM7QUFDQSxjQUFRO0FBQUEsUUFDTixzQ0FBc0MsS0FBSyxTQUFTLGdCQUFnQix3QkFBUSxTQUFTO0FBQUEsTUFDdkY7QUFBQSxJQUdGO0FBQUE7QUFBQTtBQUFBLEVBOU5BLE1BQU0sU0FBUztBQUNiLFlBQVEsSUFBSSx5QkFBeUI7QUFDckMsVUFBTSxLQUFLLGFBQWE7QUFFeEIsU0FBSyxrQkFBa0IsS0FBSyxpQkFBaUI7QUFDN0MsU0FBSyxnQkFBZ0IsTUFBTTtBQUUzQixTQUFLLGNBQWMsSUFBSSxrQkFBa0IsS0FBSyxLQUFLLElBQUksQ0FBQztBQUd4RCxTQUFLLGNBQWM7QUFFbkIsUUFBSSxLQUFLLFNBQVMsWUFBWSxLQUFLLEtBQUs7QUFDdEMsV0FBSyxjQUFjO0FBQUEsSUFDckI7QUFFQSxTQUFLLFdBQVc7QUFBQSxNQUNkLElBQUk7QUFBQSxNQUNKLE1BQU07QUFBQSxNQUNOLFVBQVUsTUFBTTtBQUNkLFlBQUksS0FBSyxLQUFLO0FBQ1osZUFBSyxVQUFVO0FBQUEsUUFDakIsT0FBTztBQUNMLGNBQUk7QUFBQSxZQUNGO0FBQUEsVUFDRjtBQUNBLGVBQUssZ0JBQWdCLHFCQUFxQjtBQUFBLFFBQzVDO0FBQUEsTUFDRjtBQUFBLElBQ0YsQ0FBQztBQUdELFNBQUssY0FBYyxLQUFLLElBQUksTUFBTSxHQUFHLFVBQVUsS0FBSyxrQkFBa0IsQ0FBQztBQUN2RSxTQUFLLGNBQWMsS0FBSyxJQUFJLE1BQU0sR0FBRyxVQUFVLEtBQUssa0JBQWtCLENBQUM7QUFDdkUsU0FBSyxjQUFjLEtBQUssSUFBSSxNQUFNLEdBQUcsVUFBVSxLQUFLLGtCQUFrQixDQUFDO0FBR3ZFLFFBQUksS0FBSyxTQUFTLFlBQVksS0FBSyxTQUFTLFNBQVM7QUFDbkQsY0FBUSxJQUFJLDRDQUE0QztBQUN4RCxXQUFLLFVBQVUsRUFBRSxNQUFNLENBQUMsVUFBVTtBQUNoQyxnQkFBUSxNQUFNLGlDQUFpQyxLQUFLO0FBQ3BELFlBQUksdUJBQU8sMkRBQTJEO0FBQ3RFLGFBQUssZ0JBQWdCLHFCQUFxQjtBQUFBLE1BQzVDLENBQUM7QUFBQSxJQUNIO0FBQUEsRUFDRjtBQUFBLEVBRUEsV0FBVztBQUNULFlBQVEsSUFBSSwyQkFBMkI7QUFDdkMsU0FBSyxhQUFhO0FBQUEsRUFDcEI7QUFBQSxFQUVBLGdCQUFnQjtBQUNkLFVBQU0sVUFBVSxLQUFLLElBQUksTUFBTTtBQUMvQixRQUFJLG1CQUFtQixtQ0FBbUI7QUFDeEMsWUFBTSxXQUFXLFFBQVEsWUFBWTtBQUNyQyxjQUFRLElBQUksaUNBQWlDLFVBQVU7QUFDdkQsV0FBSyxNQUFNLFlBQVU7QUFBQSxRQUNuQixTQUFTO0FBQUEsUUFDVCxRQUFRO0FBQUE7QUFBQSxRQUNSLHdCQUF3QjtBQUFBLE1BQzFCLENBQUM7QUFFRCxXQUFLLElBQ0YsUUFBUSxFQUNSO0FBQUEsUUFBSyxDQUFDLE1BQ0wsUUFBUTtBQUFBLFVBQ04seUJBQXlCLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRTtBQUFBLFFBQ25EO0FBQUEsTUFDRixFQUNDLE1BQU0sQ0FBQyxRQUFRO0FBQ2QsZ0JBQVE7QUFBQSxVQUNOO0FBQUEsVUFDQTtBQUFBLFFBQ0Y7QUFDQSxZQUFJO0FBQUEsVUFDRjtBQUFBLFFBQ0Y7QUFDQSxhQUFLLE1BQU07QUFDWCxhQUFLLGdCQUFnQix3QkFBd0I7QUFBQSxNQUMvQyxDQUFDO0FBQUEsSUFDTCxPQUFPO0FBQ0wsY0FBUTtBQUFBLFFBQ047QUFBQSxNQUNGO0FBQ0EsVUFBSTtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQ0EsV0FBSyxnQkFBZ0Isd0JBQXdCO0FBQzdDLFdBQUssTUFBTTtBQUFBLElBQ2I7QUFBQSxFQUNGO0FBQUEsRUFFQSxNQUFNLGVBQWU7QUFDbkIsU0FBSyxXQUFXLE9BQU8sT0FBTyxDQUFDLEdBQUcsa0JBQWtCLE1BQU0sS0FBSyxTQUFTLENBQUM7QUFBQSxFQUMzRTtBQUFBLEVBRUEsTUFBTSxlQUFlO0FBQ25CLFVBQU0sS0FBSyxTQUFTLEtBQUssUUFBUTtBQUFBLEVBQ25DO0FBQUE7QUFBQSxFQUdBLE1BQU0sWUFBWTtBQUNoQixRQUFJLEtBQUssV0FBVztBQUNsQixVQUFJLHVCQUFPLHFDQUFxQztBQUNoRCxjQUFRLElBQUksK0NBQStDO0FBQzNEO0FBQUEsSUFDRjtBQUNBLFFBQUksQ0FBQyxLQUFLLEtBQUs7QUFDYixVQUFJO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFDQSxXQUFLLGdCQUFnQixzQkFBc0I7QUFDM0MsV0FBSyxjQUFjO0FBQ25CLFVBQUksQ0FBQyxLQUFLO0FBQUs7QUFBQSxJQUNqQjtBQUNBLFFBQUksQ0FBQyxLQUFLLFNBQVMsU0FBUztBQUMxQixXQUFLLGdCQUFnQix5QkFBeUI7QUFDOUMsVUFBSSx1QkFBTyx5REFBeUQ7QUFDcEU7QUFBQSxJQUNGO0FBRUEsU0FBSyxZQUFZO0FBQ2pCLFNBQUssZ0JBQWdCLFlBQVk7QUFDakMsWUFBUSxJQUFJLDJDQUEyQztBQUV2RCxRQUFJO0FBS0YsY0FBUSxJQUFJLGtDQUFrQztBQUM5QyxZQUFNLEtBQUssSUFDUixLQUFLLEVBQUUsWUFBWSxRQUFRLGVBQWUsT0FBTyxDQUFDLEVBQ2xELE1BQU0sT0FBTyxjQUFjO0FBL0twQyxZQUFBSTtBQWlMVSxZQUFJLFVBQVUsUUFBUSxTQUFTLFVBQVUsR0FBRztBQUMxQyxrQkFBUTtBQUFBLFlBQ047QUFBQSxVQUNGO0FBQ0EsY0FBSTtBQUFBLFlBQ0Y7QUFBQSxVQUNGO0FBRUEsY0FBSTtBQUNGLG9CQUFNQSxNQUFBLEtBQUssUUFBTCxnQkFBQUEsSUFBVSxPQUFPLEVBQUUsV0FBVyxLQUFLO0FBQ3pDLGdCQUFJO0FBQUEsY0FDRjtBQUFBLFlBQ0Y7QUFBQSxVQUNGLFNBQVMsWUFBUDtBQUNBLG9CQUFRLE1BQU0scUNBQXFDLFVBQVU7QUFDN0QsZ0JBQUk7QUFBQSxjQUNGO0FBQUEsWUFDRjtBQUFBLFVBQ0Y7QUFDQSxnQkFBTSxJQUFJLE1BQU0sNkNBQTZDO0FBQUEsUUFDL0Q7QUFFQSxjQUFNO0FBQUEsTUFDUixDQUFDO0FBQ0gsY0FBUSxJQUFJLDRCQUE0QjtBQUd4QyxjQUFRLElBQUksc0NBQXNDO0FBQ2xELFlBQU0sS0FBSyxJQUFJLElBQUksS0FBSztBQUd4QixZQUFNLFNBQXVCLE1BQU0sS0FBSyxJQUFJLE9BQU87QUFDbkQsWUFBTSxnQkFBZ0IsT0FBTyxNQUFNO0FBQUEsUUFDakMsQ0FBQyxTQUFTLEtBQUssZ0JBQWdCLE9BQU8sS0FBSyxnQkFBZ0I7QUFBQSxNQUM3RDtBQUVBLFVBQUksY0FBYyxTQUFTLEdBQUc7QUFDNUIsZ0JBQVEsSUFBSSx3QkFBd0IsY0FBYyxpQkFBaUI7QUFDbkUsY0FBTSxnQkFBZ0IsS0FBSyxTQUFTLGNBQWM7QUFBQSxVQUNoRDtBQUFBLGNBQ0Esd0JBQU8sRUFBRSxPQUFPLHFCQUFxQjtBQUFBLFFBQ3ZDO0FBQ0EsY0FBTSxLQUFLLElBQUksT0FBTyxhQUFhO0FBQ25DLGdCQUFRLElBQUksOEJBQThCO0FBRzFDLGdCQUFRLElBQUksZ0NBQWdDO0FBQzVDLGNBQU0sS0FBSyxJQUFJLEtBQUs7QUFDcEIsZ0JBQVEsSUFBSSw0QkFBNEI7QUFFeEMsYUFBSyxTQUFTLGVBQVcsd0JBQU8sRUFBRSxPQUFPLHFCQUFxQjtBQUM5RCxjQUFNLEtBQUssYUFBYTtBQUN4QixhQUFLLGdCQUFnQixRQUFRO0FBQzdCLFlBQUksdUJBQU8sa0RBQWtEO0FBQUEsTUFDL0QsT0FBTztBQUNMLGFBQUssU0FBUyxlQUFXLHdCQUFPLEVBQUUsT0FBTyxxQkFBcUI7QUFDOUQsY0FBTSxLQUFLLGFBQWE7QUFDeEIsYUFBSyxnQkFBZ0Isa0JBQWtCO0FBQ3ZDLGdCQUFRLElBQUksdUNBQXVDO0FBQ25ELFlBQUk7QUFBQSxVQUNGO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFBQSxJQUNGLFNBQVMsT0FBUDtBQUNBLGNBQVEsTUFBTSxtQ0FBbUMsS0FBSztBQUN0RCxXQUFLLGdCQUFnQixLQUFLO0FBQUEsSUFDNUIsVUFBRTtBQUNBLFdBQUssWUFBWTtBQUNqQixjQUFRLElBQUksNkNBQTZDO0FBQUEsSUFDM0Q7QUFBQSxFQUNGO0FBQUEsRUFrQkEsZ0JBQWdCLE9BQVk7QUFDMUIsUUFBSSxlQUFlO0FBQ25CLFFBQUksTUFBTSxTQUFTO0FBQ2pCLFVBQ0UsTUFBTSxRQUFRLFNBQVMsVUFBVSxLQUNoQyxNQUFNLE9BQ0wsTUFBTSxJQUFJLFVBQ1YsTUFBTSxJQUFJLFFBQVEsU0FBUyxVQUFVLEdBQ3ZDO0FBQ0EsdUJBQ0U7QUFDRixhQUFLLGdCQUFnQixXQUFXO0FBQUEsTUFDbEMsV0FDRSxNQUFNLFFBQVEsU0FBUyw4QkFBOEIsS0FDckQsTUFBTSxRQUFRLFNBQVMsbUJBQW1CLEdBQzFDO0FBQ0EsdUJBQ0U7QUFDRixhQUFLLGdCQUFnQixZQUFZO0FBQUEsTUFDbkMsV0FBVyxNQUFNLFFBQVEsU0FBUyxzQkFBc0IsR0FBRztBQUN6RCx1QkFDRTtBQUNGLGFBQUssZ0JBQWdCLFlBQVk7QUFBQSxNQUNuQyxXQUNFLE1BQU0sUUFBUSxTQUFTLHVDQUF1QyxHQUM5RDtBQUNBLHVCQUNFO0FBQ0YsYUFBSyxnQkFBZ0IsY0FBYztBQUFBLE1BQ3JDLE9BQU87QUFDTCx1QkFBZSxxQkFBcUIsTUFBTSxRQUFRLFVBQVUsR0FBRyxHQUFHO0FBQ2xFLGFBQUssZ0JBQWdCLFlBQVk7QUFBQSxNQUNuQztBQUFBLElBQ0Y7QUFDQSxRQUFJLHVCQUFPLGNBQWMsR0FBSztBQUM5QixZQUFRLE1BQU0sNEJBQTRCLEtBQUs7QUFBQSxFQUNqRDtBQUFBO0FBQUEsRUFHQSxnQkFBZ0I7QUFDZCxRQUFJLEtBQUs7QUFBYztBQUN2QixRQUFJLENBQUMsS0FBSyxLQUFLO0FBQ2IsY0FBUSxJQUFJLHdEQUF3RDtBQUNwRTtBQUFBLElBQ0Y7QUFDQSxVQUFNLGlCQUFpQixLQUFLLFNBQVMsaUJBQWlCLEtBQUs7QUFDM0QsUUFBSSxrQkFBa0IsR0FBRztBQUN2QixjQUFRO0FBQUEsUUFDTjtBQUFBLE1BQ0Y7QUFDQTtBQUFBLElBQ0Y7QUFFQSxZQUFRO0FBQUEsTUFDTixzQ0FBc0MsS0FBSyxTQUFTO0FBQUEsSUFDdEQ7QUFDQSxTQUFLLGVBQWUsT0FBTyxZQUFZLE1BQU07QUFDM0MsY0FBUSxJQUFJLDRDQUE0QztBQUN4RCxXQUFLLFVBQVU7QUFBQSxJQUNqQixHQUFHLGNBQWM7QUFBQSxFQUNuQjtBQUFBLEVBRUEsZUFBZTtBQUNiLFFBQUksS0FBSyxjQUFjO0FBQ3JCLGFBQU8sY0FBYyxLQUFLLFlBQVk7QUFDdEMsV0FBSyxlQUFlO0FBQ3BCLGNBQVEsSUFBSSw4QkFBOEI7QUFBQSxJQUM1QztBQUFBLEVBQ0Y7QUFBQTtBQUFBLEVBR0EsZ0JBQWdCLE1BQWM7QUFDNUIsUUFBSSxLQUFLLGlCQUFpQjtBQUN4QixXQUFLLGdCQUFnQixRQUFRLGFBQWEsTUFBTTtBQUFBLElBQ2xEO0FBQUEsRUFDRjtBQUNGO0FBR0EsSUFBTSxvQkFBTixjQUFnQyxpQ0FBaUI7QUFBQSxFQUcvQyxZQUFZLEtBQVUsUUFBdUI7QUFDM0MsVUFBTSxLQUFLLE1BQU07QUFDakIsU0FBSyxTQUFTO0FBQUEsRUFDaEI7QUFBQSxFQUVBLFVBQWdCO0FBQ2QsVUFBTSxFQUFFLFlBQVksSUFBSTtBQUN4QixnQkFBWSxNQUFNO0FBQ2xCLGdCQUFZLFNBQVMsTUFBTSxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFHeEQsZ0JBQVksU0FBUyxNQUFNLEVBQUUsTUFBTSxVQUFVLENBQUM7QUFDOUMsUUFBSSx3QkFBUSxXQUFXLEVBQ3BCLFFBQVEsa0JBQWtCLEVBQzFCLFFBQVEsd0RBQXdELEVBQ2hFO0FBQUEsTUFBVSxDQUFDLFdBQ1YsT0FDRyxTQUFTLEtBQUssT0FBTyxTQUFTLFFBQVEsRUFDdEMsU0FBUyxPQUFPLFVBQVU7QUFDekIsYUFBSyxPQUFPLFNBQVMsV0FBVztBQUNoQyxjQUFNLEtBQUssT0FBTyxhQUFhO0FBQy9CLFlBQUksU0FBUyxLQUFLLE9BQU8sS0FBSztBQUM1QixlQUFLLE9BQU8sY0FBYztBQUFBLFFBQzVCLE9BQU87QUFDTCxlQUFLLE9BQU8sYUFBYTtBQUFBLFFBQzNCO0FBQ0EsYUFBSyxRQUFRO0FBQUEsTUFDZixDQUFDO0FBQUEsSUFDTDtBQUVGLFFBQUksS0FBSyxPQUFPLFNBQVMsVUFBVTtBQUNqQyxVQUFJLHdCQUFRLFdBQVcsRUFDcEIsUUFBUSx5QkFBeUIsRUFDakM7QUFBQSxRQUNDO0FBQUEsTUFDRixFQUNDO0FBQUEsUUFBUSxDQUFDLFNBQ1IsS0FDRyxlQUFlLElBQUksRUFDbkIsU0FBUyxPQUFPLEtBQUssT0FBTyxTQUFTLGNBQWMsQ0FBQyxFQUNwRCxTQUFTLE9BQU8sVUFBVTtBQUN6QixjQUFJLFdBQVcsT0FBTyxLQUFLO0FBQzNCLGNBQUksTUFBTSxRQUFRLEtBQUssV0FBVyxHQUFHO0FBQ25DLHVCQUFXO0FBQ1gsZ0JBQUksdUJBQU8sMENBQTBDO0FBQUEsVUFDdkQ7QUFDQSxlQUFLLE9BQU8sU0FBUyxpQkFBaUI7QUFDdEMsZ0JBQU0sS0FBSyxPQUFPLGFBQWE7QUFFL0IsY0FBSSxLQUFLLE9BQU8sU0FBUyxVQUFVO0FBQ2pDLGlCQUFLLE9BQU8sYUFBYTtBQUN6QixpQkFBSyxPQUFPLGNBQWM7QUFBQSxVQUM1QjtBQUFBLFFBQ0YsQ0FBQztBQUFBLE1BQ0w7QUFBQSxJQUNKO0FBR0EsZ0JBQVksU0FBUyxNQUFNLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDakQsUUFBSSx3QkFBUSxXQUFXLEVBQ3BCLFFBQVEsZ0JBQWdCLEVBQ3hCO0FBQUEsTUFDQztBQUFBLElBQ0YsRUFDQztBQUFBLE1BQVEsQ0FBQyxTQUNSLEtBQ0csZUFBZSxrQ0FBa0MsRUFDakQsU0FBUyxLQUFLLE9BQU8sU0FBUyxPQUFPLEVBQ3JDLFNBQVMsT0FBTyxVQUFVO0FBQ3pCLGFBQUssT0FBTyxTQUFTLFVBQVUsTUFBTSxLQUFLO0FBQzFDLGNBQU0sS0FBSyxPQUFPLGFBQWE7QUFFL0IsYUFBSyxPQUFPLGNBQWM7QUFBQSxNQUM1QixDQUFDO0FBQUEsSUFDTDtBQUVGLFFBQUksd0JBQVEsV0FBVyxFQUNwQixRQUFRLGdCQUFnQixFQUN4QjtBQUFBLE1BQ0M7QUFBQSxJQUNGLEVBQ0M7QUFBQSxNQUFRLENBQUMsU0FDUixLQUNHLGVBQWUsaUJBQWlCLGFBQWEsRUFDN0MsU0FBUyxLQUFLLE9BQU8sU0FBUyxhQUFhLEVBQzNDLFNBQVMsT0FBTyxVQUFVO0FBQ3pCLGFBQUssT0FBTyxTQUFTLGdCQUFnQjtBQUNyQyxjQUFNLEtBQUssT0FBTyxhQUFhO0FBQUEsTUFDakMsQ0FBQztBQUFBLElBQ0w7QUFPRixRQUFJLHdCQUFRLFdBQVcsRUFDcEIsUUFBUSx1QkFBdUIsRUFDL0I7QUFBQSxNQUNDO0FBQUEsSUFDRixFQUNDO0FBQUEsTUFBWSxDQUFDLGFBQ1osU0FDRyxVQUFVLE9BQU8sMkJBQTJCLEVBQzVDLFVBQVUsU0FBUyxpQ0FBaUMsRUFDcEQsU0FBUyxLQUFLLE9BQU8sU0FBUyxVQUFVLEVBQ3hDLFNBQVMsT0FBTyxVQUEyQjtBQUMxQyxhQUFLLE9BQU8sU0FBUyxhQUFhO0FBQ2xDLGNBQU0sS0FBSyxPQUFPLGFBQWE7QUFBQSxNQUNqQyxDQUFDO0FBQUEsSUFDTDtBQUdGLGdCQUFZLFNBQVMsTUFBTSxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDdkQsVUFBTSxXQUFXLFlBQVksU0FBUyxLQUFLO0FBQUEsTUFDekMsTUFBTSxjQUFjLEtBQUssT0FBTyxTQUFTO0FBQUEsSUFDM0MsQ0FBQztBQUVELFNBQUssT0FBTywyQkFBMkIsTUFBTTtBQUMzQyxlQUFTLFFBQVEsY0FBYyxLQUFLLE9BQU8sU0FBUyxVQUFVO0FBQUEsSUFDaEU7QUFFQSxRQUFJLHdCQUFRLFdBQVcsRUFDcEIsUUFBUSxhQUFhLEVBQ3JCLFFBQVEsMkNBQTJDLEVBQ25EO0FBQUEsTUFBVSxDQUFDLFdBQ1YsT0FDRyxjQUFjLFVBQVUsRUFDeEIsT0FBTyxFQUNQLFFBQVEsWUFBWTtBQUNuQixlQUFPLFlBQVksSUFBSTtBQUN2QixlQUFPLGNBQWMsWUFBWTtBQUNqQyxZQUFJLEtBQUssT0FBTyxLQUFLO0FBQ25CLGdCQUFNLEtBQUssT0FBTyxVQUFVO0FBQUEsUUFDOUIsT0FBTztBQUNMLGNBQUk7QUFBQSxZQUNGO0FBQUEsVUFDRjtBQUNBLGVBQUssT0FBTyxnQkFBZ0IscUJBQXFCO0FBQUEsUUFDbkQ7QUFDQSxlQUFPLFlBQVksS0FBSztBQUN4QixlQUFPLGNBQWMsVUFBVTtBQUUvQixpQkFBUyxRQUFRLGNBQWMsS0FBSyxPQUFPLFNBQVMsVUFBVTtBQUFBLE1BQ2hFLENBQUM7QUFBQSxJQUNMO0FBQUEsRUFPSjtBQUlGOyIsCiAgIm5hbWVzIjogWyJtb2R1bGUiLCAibW9kdWxlIiwgImRlYnVnIiwgIm1vZHVsZSIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJ1c2VDb2xvcnMiLCAiZGVidWciLCAibW9kdWxlIiwgImV4aXN0cyIsICJfX2V4cG9ydCIsICJkZWZlcnJlZCIsICJpbXBvcnRfcHJvbWlzZV9kZWZlcnJlZCIsICJ0cmltbWVkIiwgIkV4aXRDb2RlcyIsICJjb21tYW5kcyIsICJwYXJzZXIiLCAicGFyc2VycyIsICJfX2V4cG9ydCIsICJDaGVja1JlcG9BY3Rpb25zIiwgIkNsZWFuT3B0aW9ucyIsICJhcHBlbmQiLCAiR2l0Q29uZmlnU2NvcGUiLCAiRGlmZk5hbWVTdGF0dXMiLCAiUmVzZXRNb2RlIiwgImRlYnVnIiwgIm9uRXJyb3IiLCAiZXhjbHVkZU9wdGlvbnMiLCAiZGlzYWxsb3dlZENvbW1hbmQiLCAiX19jb21tb25KUyIsICJtb2R1bGUiLCAiR2l0RXhlY3V0b3IiLCAiX190b0NvbW1vbkpTIiwgIlNpbXBsZUdpdEFwaSIsICJTY2hlZHVsZXIiLCAiY29uZmlndXJhdGlvbkVycm9yVGFzayIsICJhc0FycmF5IiwgImZpbHRlckFycmF5IiwgImZpbHRlclByaW1pdGl2ZXMiLCAiZmlsdGVyU3RyaW5nIiwgImZpbHRlclN0cmluZ09yU3RyaW5nQXJyYXkiLCAiZmlsdGVyVHlwZSIsICJnZXRUcmFpbGluZ09wdGlvbnMiLCAidHJhaWxpbmdGdW5jdGlvbkFyZ3VtZW50IiwgInRyYWlsaW5nT3B0aW9uc0FyZ3VtZW50IiwgImFwcGx5UGF0Y2hUYXNrIiwgImJyYW5jaFRhc2siLCAiYnJhbmNoTG9jYWxUYXNrIiwgImRlbGV0ZUJyYW5jaGVzVGFzayIsICJkZWxldGVCcmFuY2hUYXNrIiwgImNoZWNrSWdub3JlVGFzayIsICJjaGVja0lzUmVwb1Rhc2siLCAiY2xvbmVUYXNrIiwgImNsb25lTWlycm9yVGFzayIsICJjbGVhbldpdGhPcHRpb25zVGFzayIsICJpc0NsZWFuT3B0aW9uc0FycmF5IiwgImRpZmZTdW1tYXJ5VGFzayIsICJmZXRjaFRhc2siLCAibW92ZVRhc2siLCAicHVsbFRhc2siLCAicHVzaFRhZ3NUYXNrIiwgImFkZFJlbW90ZVRhc2siLCAiZ2V0UmVtb3Rlc1Rhc2siLCAibGlzdFJlbW90ZXNUYXNrIiwgInJlbW90ZVRhc2siLCAicmVtb3ZlUmVtb3RlVGFzayIsICJnZXRSZXNldE1vZGUiLCAicmVzZXRUYXNrIiwgInN0YXNoTGlzdFRhc2siLCAiYWRkU3ViTW9kdWxlVGFzayIsICJpbml0U3ViTW9kdWxlVGFzayIsICJzdWJNb2R1bGVUYXNrIiwgInVwZGF0ZVN1Yk1vZHVsZVRhc2siLCAiYWRkQW5ub3RhdGVkVGFnVGFzayIsICJhZGRUYWdUYXNrIiwgInRhZ0xpc3RUYXNrIiwgInN0cmFpZ2h0VGhyb3VnaEJ1ZmZlclRhc2siLCAic3RyYWlnaHRUaHJvdWdoU3RyaW5nVGFzayIsICJHaXQiLCAiX2EiLCAiaW5wdXQiLCAicGx1Z2luIiwgIl9iIiwgIl9hIl0KfQo=
